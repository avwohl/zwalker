/**
 * Z-Machine JavaScript Runtime
 * Generated by z2js compiler
 *
 * Story: 151001
 * Z-Machine Version: 3
 * Release: 1
 */

"use strict";

// Z-Machine Constants
const VERSION = 3;
const INITIAL_PC = 0x44E3;  // Direct byte address
const DICTIONARY_ADDR = 0x2AF4;
const OBJECT_TABLE_ADDR = 0x0304;
const GLOBALS_ADDR = 0x028C;
const STATIC_MEMORY = 0x2AF4;
const ABBREVIATIONS_ADDR = 0x01CC;
const HIGH_MEMORY = 0x44E1;
// V6/V7 offsets for packed addresses (already multiplied by 8 in header parsing)
const ROUTINES_OFFSET = 0x0000;
const STRINGS_OFFSET = 0x0000;

// Z-Machine Runtime
class ZMachine {
    constructor(storyData) {
        // Memory
        this.memory = new Uint8Array(storyData);
        this.originalMemory = new Uint8Array(storyData);

        // CPU state
        this.pc = INITIAL_PC;
        this.stack = [];
        this.callStack = [];
        this.locals = new Array(16);

        // I/O
        this.outputBuffer = "";
        this.statusLine = { location: "", score: 0, turns: 0 };
        this.windows = [{ text: "", cursor: [1, 1] }, { text: "", cursor: [1, 1] }];
        this.currentWindow = 0;

        // Interpreter state
        this.running = false;
        this.finished = false;
        this.inputCallback = null;
        this.outputCallback = null;
        this.saveCallback = null;
        this.restoreCallback = null;

        // Random state
        this.randomMode = "random";
        this.randomSeed = 0;
        this.randomIndex = 0;

        // Debug state
        this.debugMode = false;  // Enable debug to trace instructions (set to true to enable)
        this.instructionCount = 0;
        this.instructionHistory = [];
        this.maxHistorySize = 100;

        // Multimedia resources (V6 graphics/sound)
        this.pictures = {};       // picture_num -> { data: base64, format: 'png'|'jpeg', width, height }
        this.sounds = {};         // sound_num -> { data: base64, format: 'aiff'|'ogg'|'mod' }
        this.currentSound = null; // Currently playing audio element
        this.graphicsCallback = null;  // Function to call for drawing pictures
        this.soundCallback = null;     // Function to call for playing sounds

        // Transcript recording (zwalker-compatible format)
        this.transcriptEnabled = false;
        this.transcriptData = [];     // Array of { command, from_room, to_room, result }
        this.lastCommand = null;
        this.lastRoomNumber = null;
    }

    // Memory access
    readByte(addr) {
        return this.memory[addr];
    }

    readWord(addr) {
        return (this.memory[addr] << 8) | this.memory[addr + 1];
    }

    writeByte(addr, value) {
        if (addr >= STATIC_MEMORY) {
            throw new Error(`[WRITE PROTECTION] Attempted to write byte to read-only memory at 0x${addr.toString(16)} (value=0x${value.toString(16)}, static memory starts at 0x${STATIC_MEMORY.toString(16)})`);
        }
        const oldValue = this.memory[addr];
        this.memory[addr] = value & 0xFF;
        if (this.debugMode) {
            console.error(`[WRITE #${this.instructionCount}] @0x${addr.toString(16).padStart(4,'0')} byte 0x${oldValue.toString(16).padStart(2,'0')} -> 0x${(value & 0xFF).toString(16).padStart(2,'0')}`);
        }
    }

    writeWord(addr, value) {
        if (addr >= STATIC_MEMORY) {
            throw new Error(`[WRITE PROTECTION] Attempted to write word to read-only memory at 0x${addr.toString(16)} (value=0x${value.toString(16)}, static memory starts at 0x${STATIC_MEMORY.toString(16)})`);
        }
        const oldValue = this.readWord(addr);
        this.memory[addr] = (value >> 8) & 0xFF;
        this.memory[addr + 1] = value & 0xFF;
        if (this.debugMode) {
            console.error(`[WRITE #${this.instructionCount}] @0x${addr.toString(16).padStart(4,'0')} word 0x${oldValue.toString(16).padStart(4,'0')} -> 0x${(value & 0xFFFF).toString(16).padStart(4,'0')}`);
        }
    }

    // Stack operations
    push(value) {
        this.stack.push(value & 0xFFFF);
    }

    pop() {
        if (this.stack.length === 0) {
            throw new Error("Stack underflow");
        }
        return this.stack.pop();
    }

    peek() {
        if (this.stack.length === 0) {
            throw new Error("Stack underflow");
        }
        return this.stack[this.stack.length - 1];
    }

    // Variable access (0=stack, 1-15=locals, 16+=globals)
    getVariable(varNum) {
        if (varNum === 0) {
            return this.pop();
        } else if (varNum < 16) {
            return this.locals[varNum - 1] || 0;
        } else {
            const addr = GLOBALS_ADDR + (varNum - 16) * 2;
            return this.readWord(addr);
        }
    }

    setVariable(varNum, value) {
        value = value & 0xFFFF;
        if (varNum === 0) {
            this.push(value);
        } else if (varNum < 16) {
            this.locals[varNum - 1] = value;
        } else {
            const addr = GLOBALS_ADDR + (varNum - 16) * 2;
            this.writeWord(addr, value);
        }
    }

    // Operand evaluation
    getOperand(operand) {
        if (Array.isArray(operand) && operand[0] === "var") {
            return this.getVariable(operand[1]);
        }
        return operand;
    }

    // Packed address conversion
    // V6/V7 use different offsets for routines vs strings
    // V8 uses divisor of 8 but NO offsets (like V5 semantics)
    unpackAddress(packed, isString = false) {
        switch (VERSION) {
            case 1: case 2: case 3:
                return packed * 2;
            case 4: case 5:
                return packed * 4;
            case 6: case 7:
                // V6/V7: Use appropriate offset based on address type
                if (isString) {
                    return packed * 4 + STRINGS_OFFSET;
                } else {
                    return packed * 4 + ROUTINES_OFFSET;
                }
            case 8:
                // V8 uses divisor of 8 but NO offsets
                return packed * 8;
            default:
                return packed * 2;
        }
    }

    // Z-String decoding with version-specific handling
    // V1: z-char 1 = newline, z-chars 2-3 = shift up/down, z-chars 4-5 = shift lock
    // V2: z-chars 1-3 = abbreviations (only 1 in V2), z-chars 4-5 = shift (temporary in V2)
    // V3+: z-chars 1-3 = abbreviations, z-chars 4-5 = temporary shift
    decodeZString(addr) {
        // A2 alphabet varies by version
        // V1: no newline, digits start at position 1 (z-char 7 = '0')
        // V2+: newline at position 1, digits start at position 2 (z-char 8 = '0')
        const a2_v1 = " 0123456789.,!?_#'\"/<-:()";
        const a2_v2plus = " \n0123456789.,!?_#'\"/-:()";

        const alphabets = [
            "abcdefghijklmnopqrstuvwxyz",      // A0 (lowercase)
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ",      // A1 (uppercase)
            VERSION === 1 ? a2_v1 : a2_v2plus  // A2 (punctuation/digits)
        ];

        let result = "";
        let alphabet = 0;
        let lockAlphabet = 0;  // For V1/V2 shift lock
        let abbrevTable = 0;   // Which abbreviation table (1-3)
        let zsciiState = 0;    // 0=normal, 1=waiting high, 2=waiting low
        let zsciiHigh = 0;

        while (true) {
            const word = this.readWord(addr);
            addr += 2;

            const chars = [
                (word >> 10) & 0x1F,
                (word >> 5) & 0x1F,
                word & 0x1F
            ];

            for (let c of chars) {
                // Handle 10-bit ZSCII escape sequence
                if (zsciiState === 1) {
                    zsciiHigh = c;
                    zsciiState = 2;
                    continue;
                } else if (zsciiState === 2) {
                    const zsciiCode = (zsciiHigh << 5) | c;
                    if (zsciiCode > 0) result += String.fromCharCode(zsciiCode);
                    zsciiState = 0;
                    alphabet = lockAlphabet;
                    continue;
                }

                // Handle abbreviation mode
                if (abbrevTable > 0) {
                    if (VERSION >= 2 && ABBREVIATIONS_ADDR) {
                        const abbrevAddr = ABBREVIATIONS_ADDR + 2 * (32 * (abbrevTable - 1) + c);
                        const wordAddr = this.readWord(abbrevAddr);
                        result += this.decodeZString(wordAddr * 2);
                    }
                    abbrevTable = 0;
                    alphabet = lockAlphabet;
                    continue;
                }

                // Z-char 0: always space
                if (c === 0) {
                    result += " ";
                    alphabet = lockAlphabet;
                    continue;
                }

                // Z-char 1
                if (c === 1) {
                    if (VERSION === 1) {
                        // V1: newline
                        result += "\n";
                        alphabet = lockAlphabet;
                    } else {
                        // V2+: abbreviation table 0
                        abbrevTable = 1;
                    }
                    continue;
                }

                // Z-char 2
                if (c === 2) {
                    if (VERSION === 1) {
                        // V1: temporary shift UP
                        alphabet = (alphabet + 1) % 3;
                    } else if (VERSION === 2) {
                        // V2: temporary shift UP
                        alphabet = (lockAlphabet + 1) % 3;
                    } else {
                        // V3+: abbreviation table 1
                        abbrevTable = 2;
                    }
                    continue;
                }

                // Z-char 3
                if (c === 3) {
                    if (VERSION === 1) {
                        // V1: temporary shift DOWN
                        alphabet = (alphabet + 2) % 3;
                    } else if (VERSION === 2) {
                        // V2: temporary shift DOWN
                        alphabet = (lockAlphabet + 2) % 3;
                    } else {
                        // V3+: abbreviation table 2
                        abbrevTable = 3;
                    }
                    continue;
                }

                // Z-char 4
                if (c === 4) {
                    if (VERSION <= 2) {
                        // V1/V2: shift lock UP
                        lockAlphabet = (lockAlphabet + 1) % 3;
                        alphabet = lockAlphabet;
                    } else {
                        // V3+: temporary shift to A1
                        alphabet = 1;
                    }
                    continue;
                }

                // Z-char 5
                if (c === 5) {
                    if (VERSION <= 2) {
                        // V1/V2: shift lock DOWN
                        lockAlphabet = (lockAlphabet + 2) % 3;
                        alphabet = lockAlphabet;
                    } else {
                        // V3+: temporary shift to A2
                        alphabet = 2;
                    }
                    continue;
                }

                // Z-char 6 in A2: start 10-bit ZSCII escape
                if (c === 6 && alphabet === 2) {
                    zsciiState = 1;
                    continue;
                }

                // Regular character (z-chars 6-31)
                if (c >= 6) {
                    const idx = c - 6;
                    if (alphabet === 0 && idx < alphabets[0].length) {
                        result += alphabets[0][idx];
                    } else if (alphabet === 1 && idx < alphabets[1].length) {
                        result += alphabets[1][idx];
                    } else if (alphabet === 2 && idx < alphabets[2].length) {
                        result += alphabets[2][idx];
                    }
                }

                // Reset alphabet after character
                if (VERSION >= 3) {
                    alphabet = 0;
                } else {
                    alphabet = lockAlphabet;
                }
            }

            if (word & 0x8000) break;
        }

        return result;
    }

    // Object system
    getObject(objNum) {
        if (objNum === 0) return null;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            return {
                attributes: this.readWord(objAddr) << 16 | this.readWord(objAddr + 2),
                parent: this.readByte(objAddr + 4),
                sibling: this.readByte(objAddr + 5),
                child: this.readByte(objAddr + 6),
                properties: this.readWord(objAddr + 7)
            };
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            return {
                attributes: this.readWord(objAddr) << 32 | this.readWord(objAddr + 2) << 16 |
                           this.readWord(objAddr + 4),
                parent: this.readWord(objAddr + 6),
                sibling: this.readWord(objAddr + 8),
                child: this.readWord(objAddr + 10),
                properties: this.readWord(objAddr + 12)
            };
        }
    }

    setObjectParent(objNum, parentNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 4;
            this.writeByte(objAddr, parentNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 6;
            this.writeWord(objAddr, parentNum);
        }
    }

    setObjectSibling(objNum, siblingNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 5;
            this.writeByte(objAddr, siblingNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 8;
            this.writeWord(objAddr, siblingNum);
        }
    }

    setObjectChild(objNum, childNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 6;
            this.writeByte(objAddr, childNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 10;
            this.writeWord(objAddr, childNum);
        }
    }

    testAttribute(objNum, attrNum) {
        if (objNum === 0) return false;

        // Read directly from memory to avoid 32-bit JavaScript bitwise limitations
        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
        }
        const byteNum = Math.floor(attrNum / 8);
        const bitNum = 7 - (attrNum % 8);
        const b = this.readByte(objAddr + byteNum);
        return !!(b & (1 << bitNum));
    }

    setAttribute(objNum, attrNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b | (1 << bitNum));
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b | (1 << bitNum));
        }
    }

    clearAttribute(objNum, attrNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b & ~(1 << bitNum));
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b & ~(1 << bitNum));
        }
    }

    // Room tracking for transcript
    getCurrentRoom() {
        // Method 1: Infocom convention - global 0 is the room
        const room = this.readWord(GLOBALS_ADDR);
        if (room > 0 && room < 1000) {  // Reasonable object number
            return room;
        }

        // Method 2: Inform convention - find player object and get parent
        // Player is usually object 1 in Inform games
        try {
            const player = this.getObject(1);
            if (player && player.parent > 0) {
                return player.parent;
            }
        } catch (e) {
            // Ignore errors
        }

        // Fallback: return 0 (unknown room)
        return 0;
    }

    // Output functions
    print(text) {
        // If printing to status window (window 1) and transcript is enabled,
        // append room number to the status line
        if (this.currentWindow === 1 && this.transcriptEnabled && text.includes('\n')) {
            const room = this.getCurrentRoom();
            if (room > 0) {
                // Insert room number before the newline
                text = text.replace(/\n/g, ` [Room ${room}]\n`);
                // Also update the statusLine object for external rendering
                this.statusLine.room = room;
            }
        }

        this.outputBuffer += text;
        if (this.outputCallback) {
            this.outputCallback(text);
        }
    }

    printNum(num) {
        // Handle signed 16-bit numbers
        if (num > 32767) {
            num = num - 65536;
        }
        this.print(num.toString());
    }

    printChar(charCode) {
        if (charCode === 13) {
            this.print("\n");
        } else {
            this.print(String.fromCharCode(charCode));
        }
    }

    newLine() {
        this.print("\n");
    }

    // Random number generation
    random(range) {
        // Handle as signed 16-bit
        if (range > 32767) range = range - 65536;

        if (range === 0) {
            // random(0): Reset to truly random mode
            this.randomMode = "random";
            return 0;
        }

        if (range < 0) {
            // random(negative): Seed the predictable generator
            this.randomSeed = -range;
            this.randomMode = "predictable";
            this.randomIndex = this.randomSeed;  // Seed IS the initial state
            return 0;
        }

        if (this.randomMode === "predictable") {
            // Linear congruential generator
            this.randomIndex = (this.randomIndex * 1103515245 + 12345) & 0x7FFFFFFF;
            return (this.randomIndex % range) + 1;
        } else {
            return Math.floor(Math.random() * range) + 1;
        }
    }

    // Game state
    save() {
        if (this.saveCallback) {
            const state = {
                memory: Array.from(this.memory.slice(0, STATIC_MEMORY)),
                stack: this.stack.slice(),
                callStack: this.callStack.map(frame => ({
                    returnPC: frame.returnPC,
                    locals: frame.locals.slice(),
                    numLocals: frame.numLocals,
                    storeVar: frame.storeVar
                })),
                pc: this.pc,
                locals: this.locals.slice()
            };
            return this.saveCallback(state);
        }
        return false;
    }

    restore(state) {
        if (state && state.memory) {
            // Restore dynamic memory
            for (let i = 0; i < state.memory.length; i++) {
                this.memory[i] = state.memory[i];
            }
            this.stack = state.stack.slice();
            this.callStack = state.callStack.map(frame => ({
                returnPC: frame.returnPC,
                locals: frame.locals.slice(),
                numLocals: frame.numLocals,
                storeVar: frame.storeVar
            }));
            this.pc = state.pc;
            this.locals = state.locals.slice();
            return true;
        }
        return false;
    }

    restart() {
        // Restore original memory
        this.memory = new Uint8Array(this.originalMemory);
        this.pc = INITIAL_PC;
        this.stack = [];
        this.callStack = [];
        this.locals = new Array(16);
        this.outputBuffer = "";
        this.running = true;
        this.finished = false;
    }

    quit() {
        this.running = false;
        this.finished = true;
        this.print("\n[Game terminated]\n");
    }

    // Transcript recording (zwalker-compatible format)
    enableTranscript() {
        this.transcriptEnabled = true;
        this.transcriptData = [];
        this.lastRoomNumber = this.getCurrentRoom();
        this.print("\n[Transcript recording enabled]\n");
    }

    disableTranscript() {
        this.transcriptEnabled = false;
        this.print("\n[Transcript recording disabled]\n");
    }

    getTranscript() {
        // Return transcript in zwalker-compatible JSON format
        const rooms = new Set();
        const commands = [];

        this.transcriptData.forEach(entry => {
            rooms.add(entry.from_room);
            rooms.add(entry.to_room);
            commands.push(entry.command);
        });

        return {
            game: "unknown",  // Will be filled in by caller
            solved: false,    // User can set this manually
            rooms_visited: Array.from(rooms).filter(r => r > 0),
            solution_commands: commands,
            full_solution_data: this.transcriptData,
            stats: {
                rooms_found: rooms.size,
                commands_tried: this.transcriptData.length
            }
        };
    }

    exportTranscript() {
        // Return transcript as JSON string
        return JSON.stringify(this.getTranscript(), null, 2);
    }

    // Object name lookup
    getObjectName(objNum) {
        const obj = this.getObject(objNum);
        if (!obj) return "";

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr++;

        if (textLength === 0) return "";

        return this.decodeZString(propAddr);
    }

    // Object tree manipulation
    insertObject(objNum, destNum) {
        if (objNum === 0) return;

        // Remove from current parent
        this.removeObject(objNum);

        // Insert as first child of destination
        const dest = this.getObject(destNum);
        if (dest) {
            this.setObjectSibling(objNum, dest.child);
            this.setObjectChild(destNum, objNum);
            this.setObjectParent(objNum, destNum);
        }
    }

    removeObject(objNum) {
        if (objNum === 0) return;

        const obj = this.getObject(objNum);
        if (!obj || obj.parent === 0) return;

        const parent = this.getObject(obj.parent);
        if (!parent) return;

        // Remove from sibling chain
        if (parent.child === objNum) {
            // Object is first child
            this.setObjectChild(obj.parent, obj.sibling);
        } else {
            // Find previous sibling
            let prevSibling = parent.child;
            while (prevSibling !== 0) {
                const prevObj = this.getObject(prevSibling);
                if (prevObj.sibling === objNum) {
                    this.setObjectSibling(prevSibling, obj.sibling);
                    break;
                }
                prevSibling = prevObj.sibling;
            }
        }

        this.setObjectParent(objNum, 0);
        this.setObjectSibling(objNum, 0);
    }

    // Property access
    getPropertyAddr(objNum, propNum) {
        if (objNum === 0) return 0;

        const obj = this.getObject(objNum);
        if (!obj) return 0;

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr += 1 + textLength * 2;

        // Search for property
        while (propAddr < this.memory.length) {
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) break;

            let num, size, dataOffset;
            if (VERSION <= 3) {
                // V1-3: Property number in bits 4-0, size in bits 7-5
                num = sizeByte & 0x1F;
                size = (sizeByte >> 5) + 1;
                dataOffset = 1;
            } else {
                // V4+: Property number in bits 5-0
                num = sizeByte & 0x3F;
                if (sizeByte & 0x80) {
                    // Two-byte size: second byte bits 5-0 = size (0 means 64)
                    const sizeByte2 = this.readByte(propAddr + 1);
                    size = sizeByte2 & 0x3F;
                    if (size === 0) size = 64;
                    dataOffset = 2;
                } else {
                    // One-byte size: bit 6 set = 2 bytes, clear = 1 byte
                    size = (sizeByte & 0x40) ? 2 : 1;
                    dataOffset = 1;
                }
            }

            if (num === propNum) {
                return propAddr + dataOffset;
            }

            propAddr += dataOffset + size;
        }

        return 0;
    }

    getPropertySize(propAddr) {
        // Get the size of a property given the address of its DATA (after size byte(s))
        // We need to look at the byte(s) before propAddr
        if (VERSION <= 3) {
            const sizeByte = this.readByte(propAddr - 1);
            return (sizeByte >> 5) + 1;
        } else {
            // V4+: Could be 1 or 2 size bytes before the data
            const prevByte = this.readByte(propAddr - 1);
            if (prevByte & 0x80) {
                // This is a second size byte
                const size = prevByte & 0x3F;
                return size === 0 ? 64 : size;
            } else {
                // This is a single size byte
                return (prevByte & 0x40) ? 2 : 1;
            }
        }
    }

    getProperty(objNum, propNum) {
        const propAddr = this.getPropertyAddr(objNum, propNum);
        if (propAddr === 0) {
            // Return default property value
            const defaultAddr = OBJECT_TABLE_ADDR + (propNum - 1) * 2;
            return this.readWord(defaultAddr);
        }

        const size = this.getPropertySize(propAddr);

        if (size === 1) {
            return this.readByte(propAddr);
        } else {
            return this.readWord(propAddr);
        }
    }

    putProperty(objNum, propNum, value) {
        const propAddr = this.getPropertyAddr(objNum, propNum);
        if (propAddr === 0) return;

        const size = this.getPropertySize(propAddr);

        if (size === 1) {
            this.writeByte(propAddr, value);
        } else {
            this.writeWord(propAddr, value);
        }
    }

    getNextProperty(objNum, propNum) {
        if (objNum === 0) return 0;

        const obj = this.getObject(objNum);
        if (!obj) return 0;

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr += 1 + textLength * 2;

        if (propNum === 0) {
            // Return first property
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) return 0;
            return VERSION <= 3 ? (sizeByte & 0x1F) : (sizeByte & 0x3F);
        }

        // Search for property
        while (propAddr < this.memory.length) {
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) break;

            let num, size, dataOffset;
            if (VERSION <= 3) {
                num = sizeByte & 0x1F;
                size = (sizeByte >> 5) + 1;
                dataOffset = 1;
            } else {
                num = sizeByte & 0x3F;
                if (sizeByte & 0x80) {
                    const sizeByte2 = this.readByte(propAddr + 1);
                    size = sizeByte2 & 0x3F;
                    if (size === 0) size = 64;
                    dataOffset = 2;
                } else {
                    size = (sizeByte & 0x40) ? 2 : 1;
                    dataOffset = 1;
                }
            }

            if (num === propNum) {
                // Found current property, return next
                propAddr += dataOffset + size;
                const nextSizeByte = this.readByte(propAddr);
                if (nextSizeByte === 0) return 0;
                return VERSION <= 3 ? (nextSizeByte & 0x1F) : (nextSizeByte & 0x3F);
            }

            propAddr += dataOffset + size;
        }

        return 0;
    }

    // Table scanning
    scanTable(value, tableAddr, length, form) {
        const fieldSize = form & 0x7F;
        const isWord = !(form & 0x80);

        for (let i = 0; i < length; i++) {
            const entryAddr = tableAddr + i * fieldSize;
            const entryValue = isWord ? this.readWord(entryAddr) : this.readByte(entryAddr);

            if (entryValue === value) {
                return entryAddr;
            }
        }

        return 0;
    }

    // Input handling
    read(textBuffer, parseBuffer, storeVar) {
        if (this.debugMode) {
            console.error(`[READ] textBuffer=0x${textBuffer.toString(16)}, parseBuffer=0x${parseBuffer.toString(16)}, storeVar=${storeVar}`);
        }

        this.running = false;

        // Set up the input handler - will be called when input arrives
        const self = this;
        this.inputCallback = function(input) {
            if (self.debugMode) {
                console.error(`[INPUT] Received: "${input}"`);
            }

            // Record room before command for transcript
            const roomBefore = self.transcriptEnabled ? self.getCurrentRoom() : null;

            // Store input in text buffer
            const maxLen = self.readByte(textBuffer);
            const actualLen = Math.min(input.length, maxLen);

            if (VERSION <= 4) {
                for (let i = 0; i < actualLen; i++) {
                    self.writeByte(textBuffer + 1 + i, input.toLowerCase().charCodeAt(i));
                }
                self.writeByte(textBuffer + 1 + actualLen, 0);
            } else {
                self.writeByte(textBuffer + 1, actualLen);
                for (let i = 0; i < actualLen; i++) {
                    self.writeByte(textBuffer + 2 + i, input.toLowerCase().charCodeAt(i));
                }
            }

            // Tokenize if parse buffer provided
            if (parseBuffer && parseBuffer !== 0) {
                self.tokenize(textBuffer, parseBuffer);
            }

            // For V5+, store the terminating character (13 = Enter/newline)
            if (storeVar !== null) {
                self.setVariable(storeVar, 13);
            }

            // Record transcript data after command is processed
            if (self.transcriptEnabled) {
                // Use a short delay to let the game process the command first
                setTimeout(() => {
                    const roomAfter = self.getCurrentRoom();
                    self.transcriptData.push({
                        command: input.toUpperCase(),
                        from_room: roomBefore,
                        to_room: roomAfter,
                        result: roomBefore !== roomAfter ? "moved" : "boring"
                    });
                    self.lastCommand = input.toUpperCase();
                    self.lastRoomNumber = roomAfter;
                }, 10);
            }

            // Clear the callback and continue execution
            self.inputCallback = null;
            self.running = true;
            setTimeout(() => self.run(), 0);
        };
    }

    // Single character input (read_char opcode)
    readChar(storeVar) {
        if (this.debugMode) {
            console.error(`[READ_CHAR] storeVar=${storeVar}`);
        }

        this.running = false;

        // Set up the input handler - will be called when input arrives
        const self = this;
        this.inputCallback = function(input) {
            if (self.debugMode) {
                console.error(`[READ_CHAR INPUT] Received: "${input}"`);
            }

            // Get the character code (first character of input, or 13 for empty/enter)
            let charCode;
            if (input.length === 0) {
                charCode = 13; // Enter/newline
            } else {
                charCode = input.charCodeAt(0);
            }

            // Store the character code
            self.setVariable(storeVar, charCode);

            // Clear the callback and continue execution
            self.inputCallback = null;
            self.running = true;
            setTimeout(() => self.run(), 0);
        };
    }

    // Dictionary and tokenization
    tokenize(textBuffer, parseBuffer) {
        // DEBUG: Dump parse buffer BEFORE tokenization
        if (this.debugMode) {
            console.error(`[TOKENIZE] Parse buffer BEFORE (at 0x${parseBuffer.toString(16)}):`);
            console.error(`[TOKENIZE] Text buffer at 0x${textBuffer.toString(16)}`);

            // Show what's currently in the parse buffer
            for (let i = 0; i < 3; i++) {
                const entryAddr = parseBuffer + 2 + i * 4;
                const addr = this.readWord(entryAddr);
                const len = this.readByte(entryAddr + 2);
                const pos = this.readByte(entryAddr + 3);
                console.error(`[TOKENIZE]   Entry ${i}: addr=0x${addr.toString(16)}, len=${len}, pos=${pos}`);
            }
        }

        // Simplified tokenization
        let text;
        if (VERSION <= 4) {
            text = "";
            let addr = textBuffer + 1;
            let ch = this.readByte(addr);
            while (ch !== 0) {
                text += String.fromCharCode(ch);
                addr++;
                ch = this.readByte(addr);
            }
        } else {
            const len = this.readByte(textBuffer + 1);
            text = "";
            for (let i = 0; i < len; i++) {
                text += String.fromCharCode(this.readByte(textBuffer + 2 + i));
            }
        }

        // Split into words
        const words = text.trim().split(/\s+/).filter(w => w.length > 0);
        const maxWords = this.readByte(parseBuffer);

        // Write number of words parsed
        this.writeByte(parseBuffer + 1, Math.min(words.length, maxWords));

        // Write each word entry
        let textPos = 0;  // Track position in original text
        for (let i = 0; i < Math.min(words.length, maxWords); i++) {
            const word = words[i];
            const dictAddr = this.lookupWord(word);

            if (this.debugMode) {
                console.error(`[TOKENIZE] Word ${i}: "${word}" -> dictAddr=0x${dictAddr.toString(16)}`);
            }

            // Find word position in text (1-indexed)
            const wordStart = text.indexOf(word, textPos);
            const position = wordStart + 1;  // 1-indexed position in text
            textPos = wordStart + word.length;

            // Write word entry: dict-addr (2 bytes), length (1 byte), position (1 byte)
            const entryAddr = parseBuffer + 2 + i * 4;
            this.writeWord(entryAddr, dictAddr);
            this.writeByte(entryAddr + 2, word.length);
            this.writeByte(entryAddr + 3, position);

            if (this.debugMode) {
                console.error(`[TOKENIZE]   Wrote to 0x${entryAddr.toString(16)}: addr=0x${dictAddr.toString(16)}, len=${word.length}, pos=${position}`);
            }
        }

        // DEBUG: Dump parse buffer contents
        if (this.debugMode) {
            console.error(`[TOKENIZE] Parse buffer dump (buffer starts at 0x${parseBuffer.toString(16)}):`);
            console.error(`[TOKENIZE]   Max words: ${this.readByte(parseBuffer)}`);
            console.error(`[TOKENIZE]   Num words: ${this.readByte(parseBuffer + 1)}`);
            const numWords = this.readByte(parseBuffer + 1);
            for (let i = 0; i < Math.max(numWords, 3); i++) {  // Show at least 3 entries
                const entryAddr = parseBuffer + 2 + i * 4;
                const addr = this.readWord(entryAddr);
                const len = this.readByte(entryAddr + 2);
                const pos = this.readByte(entryAddr + 3);
                console.error(`[TOKENIZE]   Entry ${i} at 0x${entryAddr.toString(16)}: addr=0x${addr.toString(16)}, len=${len}, pos=${pos}`);
            }
        }
    }

    lookupWord(word) {
        // Simplified dictionary lookup
        // Returns 0 if word not found
        const dict = DICTIONARY_ADDR;
        const numSeparators = this.readByte(dict);
        let addr = dict + 1 + numSeparators;

        const entryLength = this.readByte(addr);
        addr++;
        const numEntries = this.readWord(addr);
        addr += 2;

        // Encode the word using Z-string encoding
        const encoded = this.encodeWord(word);

        // Linear search through dictionary
        for (let i = 0; i < numEntries; i++) {
            const entryAddr = addr + i * entryLength;
            let match = true;

            for (let j = 0; j < Math.min(encoded.length, VERSION <= 3 ? 4 : 6); j++) {
                if (this.readByte(entryAddr + j) !== encoded[j]) {
                    match = false;
                    break;
                }
            }

            if (match) return entryAddr;
        }

        return 0;
    }

    encodeWord(word) {
        // Z-string encoding for dictionary words
        // V1-3 use 4 bytes (2 Z-chars per byte, 6 chars total)
        // V4+ use 6 bytes (9 chars total)
        const maxChars = VERSION <= 3 ? 6 : 9;
        const maxBytes = VERSION <= 3 ? 4 : 6;

        const alphabet = "abcdefghijklmnopqrstuvwxyz";
        const zchars = [];

        for (let i = 0; i < maxChars; i++) {
            if (i < word.length) {
                const ch = word[i].toLowerCase();
                const idx = alphabet.indexOf(ch);
                if (idx >= 0) {
                    zchars.push(idx + 6);  // A0 alphabet starts at 6
                } else {
                    zchars.push(5);  // Default to space character
                }
            } else {
                zchars.push(5);  // Pad with spaces
            }
        }

        // Pack Z-chars into bytes (3 Z-chars per 2-byte word)
        const bytes = [];
        for (let wordIdx = 0; wordIdx < maxBytes / 2; wordIdx++) {
            const z1 = zchars[wordIdx * 3] || 5;
            const z2 = zchars[wordIdx * 3 + 1] || 5;
            const z3 = zchars[wordIdx * 3 + 2] || 5;

            let word = (z1 << 10) | (z2 << 5) | z3;

            // Set top bit on last word only
            if (wordIdx === (maxBytes / 2) - 1) {
                word |= 0x8000;
            }

            bytes.push((word >> 8) & 0xFF);
            bytes.push(word & 0xFF);
        }

        return bytes;
    }
}

// Story Data (Base64 encoded)
const STORY_DATA_BASE64 = [
    "AwAAAUThROMq9AMEAowq9AAAMTUxMDAxAcyBt+dgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAWkFQRgMtqAUT1OgFEy2opQPU6KUB2IClANOkBQKLgKUDNIClAqZjBrFFGuqApZZgTLjkBZZA",
    "gMADjuWlZa7NhYHTNVeopRHZlxiaMUXZ5ioaNyjJ+AVE17FFAy1emrGlgOoBLi1qXVPkpQMtmyUB",
    "d9JFAXTcpQI0UhiApRzZZVe5WDTbqKUQyW1TZ1eopV6UyKXTWXGuoaWCiwIqmSUBNPJlgpMClyXT",
    "Gv6ApXFY5KUT1OilgnRhyailgdkChz1I5wUAis0lAfrjJQMUyUUBBsyl5aoDCqilAnpI6tyl4LKD",
    "NADcm8VtV/ilLjTS5Rk7Knnq6l6azSUDLbsAAKYFRRgqFMEopoVFYzeo0mbqGxrdRQDmogUAiBp+",
    "0mWQwEXQqKUR04Clqmke7qWKFkXIskaIwUlTatylJdepGS3YY1eopcacIi7I5SKXXcnS5XDZquWa",
    "aQDH02oDlOopQdOwpSLm8iUBaqslJ4ZfauClKNjkpdXZAaZWqsylNpGopYNVESqZJRTANKcUwLSn",
    "J4bdZQAgACIAJAAmACgAKgAsAC4AMAAzADUANgA4ADkAOgA8AD4APwBBAEMARABGAEkASwBOAE8A",
    "UwBVAFcAWQBcAF8AYQBlAGcAaABqAGsAbQBvAHAAdAB2AHgAeQB7AHwAfwCBAIMAhQCHAIgAigCN",
    "AI4AjwCRAJMAlQCYAJoAnACiAKQApwCpAKwArQCvALEAsgC0ALYAuAC6ALwAvwDAAMIAxQDHAMgA",
    "ygDMAM4A0ADSANUA1wDYANsA3QDeAOAA5AAAAAAAAAAAAAQAAAABAAEAAiHeIqYA3AAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAACWHJbol7QAAAAAAAAAA//8AAAAAAUoAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAFAAAAAAAAAAAAAAAAAAA/vD44Pvo9fgAAAAAAAAAAAAoAAAAAAAAAAP//AAAAAAAA",
    "AAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOACAAs9AAAAAOADAAtWAAAA",
    "AOAEAAtrAAAAAOAFAAt9AAAAAOAAAAuLAAAAAgkHAAukADAAAAkAAAvSAAAEgQkGAAv9AEAAAN8N",
    "CAwYALCAAA0AAAw7ADAAAA0KAAxYAQAAAN0xAAyBAEAAAN8UCwyhAgAAAgAAAAy7ABAAAAAAAAzV",
    "AADAAAAAAAzmAAAAAgAAAA0FAAAAAhMAAA0hABAAABQAEg05AAgAAN8VEw1VAAAAAN8WAA1zAAAA",
    "AN8XAA2QAAAAAN8YAA2tAAAAAN8ZAA3KAAAAAN8aAA3nAAAAAN8bAA4EAAAAAN8cAA4hAAAAAN8d",
    "AA4+AAAAAN8eAA5bAAAAAN8fAA54AAAAAN8iAA6VAhgEAiIAAA6yAADAACIgAA7WAAgAAN8jIQ7z",
    "AAgAAN8lAA8JALAAACUAAA8pAAgAAN8oJA9KAKgAAigAAA9lALAAACgmAA9+AAgAAN8qJw+MALAA",
    "ACoAAA+jAEAAAN8rKQ+7AAgAAN8sAA/dAAgAAN8tAA/+AAgAAN8uABAXAAgAAN80ABAoAADAADMA",
    "ABBLABAQAN0zABBjBAAAAN0yABBvBAAAAN0wABB/AAABAd1JLxCTAAAAAN81ABCoAAAAAN82ABDO",
    "AAAAAN83ABDmAAAAAN85ABD/AAAAADkAABEYAAAAAN86OBE5AAAAAN89ABFMAqAQAj0AABFhAAAQ",
    "AD07ABGTAAAAAN8+PBGlAAAAAN8/ABG2AAAAAN9CABHJAAgAAgAAABHeAAAAAkIAABH8AAAAAN9D",
    "QRIVAAAAAN9GABIqAAgAAkYAABI5AAAAAEZEABJVAAgAAN9IRRJoAQgAAkgAABJ5AEAAAN9KRxKn",
    "ABAAAN1xABLCAAAAAN9LABLVAAAAAN9PABLrAKAAAgAAABMDAAgAAk8AABMoAbAAAE9NABNBAAAA",
    "AN9SThNjAAAAAlIAABN6ALAAAFJQABOQAAAAAN9UUROmAAgAAlQAABO6AAAAAN9WUxPXAAAEAVYA",
    "ABP3AAAAAN9XVRQVAAAAAN9ZABQ1ACgAAlkAABRIAAAAAN9aWBRyAAAAAN9cABSIALAAAFwAABSp",
    "AAAAAN9gWxS7AAAAAAAAABTXAggAAmAAABTzAADAAGBeABUQAAAAAN9hXxUyAAAAAN9iABVMAAAA",
    "AN9jABVpAAAAAN9kABV5AAAAAN9lABWOAAAAAN9mABWdAAAAAN9nABWsAAAAAN9oABXQAAAAAN9p",
    "ABXhAAAAAN9qABX4AAAAAN9rABYXAAAAAN9tABYuALAAAG0AABZIAAAAAN9vbBZcABQAAG8AABZy",
    "AAgAAN9ybhaIALAAAHIAABaZABAAAN11ABa3AAAAAN90cBbKAAGAAHQAABbtAAgAAN93cxcIAAAA",
    "AN12ABccBAGAAN2fABcyAAAAAN94ABdMAAAAAN95ABdzAAAAAN96ABeYAAAAAN98ABe0AAgAAgAA",
    "ABfRAAgAAN99ABfvAAAAAN9+ABf/AAAAAN9/ABgPAAAAAN+AABgfAAAAAN+BABgvAAAAAN+CABhB",
    "AAAAAN+DABhTAAAAAN+EABhjAAAAAN+FABhzAAAAAN+IABiHABAAAIgAABiXABAAAIiGABioAAAA",
    "AN+Jhxi+AAAAAN+KABjZAAAAAN+LABjpAAAAAN+MABj9AAAAAN+NABkNAAAAAN+OABkfAAAAAN+P",
    "ABk3AAAAAN+QABlLAAAAAN+RABlfAAAAAN+SABlvAAAAAN+TABl/AAAAAN+UABmPAAAAAN+VABmf",
    "AAAAAN+WABm3AAAAAN+XABnLAAAAAN+ZABndALAAAJkAABnzAAAAAN+bmBoDALAAAJsAABoaAAgA",
    "AN+dmhouABAAAJ0AABo+AAAAAN+enBpTAAAAAN+jABpmAAAAAN2gABp7AKAAAN2hABqWAAAAAN2i",
    "ABqqAAAAAN21ABq7AAAAAN+kABrJAAAAAN+lABriAAAAAN+nABr1AKgAAqcAABsOAAAAAN+pphsk",
    "AAgAAqkAABs/AAAAAN+rqBtlAIgAAqsAABt8AAAAAN+tqhuTAADAAK0AABusAAAAAN+urBvOAAAA",
    "AN+vABvyAAAAAN+wABwCAAAAAN+xABwiAAAAAN+yABw9AAAAAN+0ABxcAKgAArQAAByAAAAAAN+3",
    "sxyXAAAAAN22ABy6BAAAAd27ABzGAAAAAN+5ABzYAAgAArkAABz+AAAAAN+6uB0ZAAAAAN+9AB0r",
    "ALAAAN28AB1MAAAAAN3FAB1lAAgAAN+/AB15AACAAL8AAB2bAAgAAN/Avh22AAgAAN/CAB3PAAAA",
    "AsIAAB3oAAgAAN/EwR4SCAABwsQAAB4vAEAAAN/Gwx5IAKAAAN3HAB5fAEAAAN/IAB5xAAAEgd3X",
    "AB6OAEgAAN/JAB6rAEgAAN/KAB7WAEgAAN/LAB8CAEgAAN/MAB8nAEgAAN/VAB9BAAIAAAAAAB9e",
    "AAIAAM8AAB+AAAABQtXQzh+gAAAIAtXRAB+4AAAgAtXSAB/WAAACAtXTAB/6ABAAANUAACAbABQA",
    "ANXPACBHAEgAAN/W1CBYAEgAAN8AACB0ACAAAN3YACCWAAAAAN3ZACCmAAQAAN0AACC4AAAAAN0M",
    "ACDRAEgAAN8JACDuMICAAAAAACESAAAAAAAA2iEhAAAAAAAAACEl/////wAA2yEpAAAAAAAA4SEx",
    "AAAAAOABACE1FJAAAAAAACFBEAAAAAAAACFJAmJmwUXy//79/Pv6+fikNtItaiuqI2GWAAQGwCDb",
    "KDia5XL69/z2JCv+I2GWAAQfV0fAZvTGJRL1JDjfI2GWAAJV15sqEvQkNFUjYZYABmW3KNkqbk2A",
    "BoCP5XLz8vHwJC6XI2GWAAoeJiIAXokFwTb6Yz4CRl4CHCCMxZLv7u3s6zBpby5r3eQ1ZjKjLqwv",
    "MSNeQAAKIpFFSGXUTCYLYDDSKBIbKl3GxwWS6uno/v0ugaTkMrg22TULM3wjXbwABGMqKiAy5uVF",
    "MufmMG8/Lms0ZDB6MIEjXioABxMEcE8ExF1VUw5ml/ilGw2UyAgAAAAxddUPDCc7qCNeIwAEYioq",
    "rk2AjuVy5eTj4i5q5ilqyWQuly6eI13lAAoikUVIZdRMJgtgMNIoEhsqXcbHBVLq6egugaTkMrg4",
    "oDULM3wjXbwABSp0XlRrAEnX3pfy4f/5+uDf3t0ua1BkMuI5ayNdmgAHEmQoTwTEXVVTDmaX+KUY",
    "CTF1Nw8MI11eAAQnhl9uYaCbqlLx3dwwce8ubAAkK78jW2gAAkJurUUy3NpkMgIyCSNbVgAGZbco",
    "2SpuTYAGgI/lcvPy8fAwaU4ubBgkLpcjWbwABHKXTLwIQIfFUtnY1zBtsS5yvGQr6SvpI1m2AAMu",
    "6mGgh8US1jBxsC5ywmQr6SvpI1m2AAVsZjpsAkYhrs1FctXp1NMub51kMpU2tiNZMgAJD6I8Kk1G",
    "XARsZjpsAJIZDbpqHx4WHTGAayc7vAACEkb9RR8aHhYdHBwbGx4aHRkYGB8VFxQZMXk7AAISRv1F",
    "HxkeGB0dHBobHBoeGRcYFRUbFB8xeS8AAhJG/UUfGB4cHRUcHhsdGhkZHxgWFRoUGzF4lwACEkb9",
    "RR8eHhkdHxwdGxUaFxkWGBsVHBQaMXsxAAISRv1FHx8eGx0aHBgbFhoVGR0YFxUeFBwxeyUAAhJG",
    "/UUfHR4XHRkcFRsfGhwZGxgeFRYUGDF7DAACEkb9RR8XHh4dGBwcGxoaFhkVGBkVHxQdMXsZAAIS",
    "Rv1FHxseGh0WHBkbFxofGR4YGBUdFBUxeIsAAhJG/UUfFh4VHR4cHxsZGhsZHBgaFRgUFzF5RwAC",
    "Ekb9RR8cHhQdGxwXGxgaGhkZGB0VFRQWMXh/AAISRv1FHxUeHR0XHBYbGxoYGRoYHBUZFLAxeV8A",
    "BDKRJVMBDZnTctDPzs0xaUAubwglAA7kLRYyXTYOLR0jWLgABAbAINsoOJrlcvr3/PYsVqpoJbsl",
    "4yQr/iNXDwAFDKQc111TAJfSkhwjFiMxfLYnO8oACAykLvRPIRiHGvcqYBL00kUdIhwlFyIVJTF/",
    "Qyc71wAGRdIrGVJqB5IbLtJ4ssnIx8bFxi5qoeQv9TYjNjEyVgAHDKRF0isZUmoAlRsYmYofLB4j",
    "FSwUIzF/ZgADXClirqFYMsPCKWkGJQAOZDctNyYjVpwAAx6aRSrfBS5zJyNWjgAHDKQhpkjqXCYQ",
    "9GopqvgcKxYrMXqPAARipl4YBMbhpRLBLnDF5DcKNxgroytrAAgQ2QCHXUZlpXCZGHQAm7lcHisW",
    "KzRqkzF9mCc8GCNWhQALENkAj2poZdRMBHHZNARw10gEcDPgpR8qHiwdKDFxWwAGENkAi1LwBgAS",
    "puWlHC0bKxklFCUxb+sABAykIpddydLlHSwcLjGBVQAIEpMAkxFAEw4lQRiINNjIpRstWFU8ADF+",
    "+28zMjEwI1ZyAAQfV0fAZvTGJRL1MGhzLnOnJDjfI1XVAAJhzMylLnCrJDZpAAMlRiQ4muUSrSQr",
    "/iNWaAAFcuoiBjFCECCM5WQ6UiyfI1ZeAARdyEFZeAOcpXKsq6qpJCyfI1XIAAgSkwCYE4ATDiVB",
    "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",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7AAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOwAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "JIkksQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJOAlCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAJTclXwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAJjombQAAJqAnBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAADsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgMKD8AAChyKNYAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAALgAswCqAKgApgBeAHsAWABTAE0ARwBEAEAAJgAgAG0J",
    "f8Rs03PBbYpq4WnlbUxtOQAIAAoACgACAAIAAgAEAAUAAwAIAAAAAAAAAAAAAAAAAAAAAAMsLiIH",
    "AjwVJai8InkAFUWgvCJZABVF8dMiVwAWRZSlBPAAFmWUpQTvABZz6keAAQAWeaoxQcUAFwWUpQAA",
    "ABcllKUE7gAYpZSlBP8AGPTrJQj3ABj07UUifAAY95kGQbMAGRm7aiLAABk7qnki6gAZhrplQekA",
    "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",
    "gAEAZuqrBYABAGbupVOAAQBm7tVFgAEAZvTGJYABAGdSni4iRgBnU81RgAEAZ1fMpUHsAGeKx2oi",
    "eQBnis8+IlsAZ47jKiK4AGeUlKUipwBnlJeYIqgAZ9W5BiKNAGillKUY/RVqaarlCPQAamnQpUTy",
    "z2pxuY1BrABqcdEQQe0Aanii7kHHAGp45MciqwBqfKjXQfQAaqWUpRj9FWsKlKVBsABs07s+gAEA",
    "bNXS5YABAGzYqKWAAQBtUe1ZIpIAbVOl0yLVAG1T0lQi+wBtV56YQckAbVfh1EHQAG6RoNOAAQBw",
    "pZSlExwAcM7kpUHqAHDQqKVB2ABw0cClQf4AcNmq5cG/AXDZquuAAQBw26ilQd0AcUbcpUH1AHFR",
    "xKWgAUJxUcW0gAEAcVjkpRMcAHGu3i4ihgBxrt41gAEAca7lRSJhAHHIwVciXgBxyailImUAcdOm",
    "nIABAHHY1KWAAQBx2NcFgAEAcdm0pQj2AHKHnj4iqgByl8ylItkAcpfMvCLXAHKX5bEilwBy6qIG",
    "gAEAcu7l04ABAHSllKVB9gB33//FQbsAeKWUpUHSAHiqlKWibAF408ClQeMAeViUpUHSAHtSy8Ui",
    "TwB8pZSlQeoAfdOrBYABAFVVSUQ6Ly8wRTEyM0Y1MC0yMEEyLTRGNUItOEYwMS0yNjQ2NzhFRDQx",
    "OUQvLwASAV1p1AFKgNsBLIDpAPqA9wDIgFUAgoC/AGSAGAAjgQUACnz2AAgAAAAAAAQABQAIAEsA",
    "GQAUAAgCngEsADwAPAA8AHgAlgBaAAEAyAABAL8AAQCtABgAlwCWAJUAlACQAI8AjgCNAIwAigCE",
    "AIEAgAB9AJMAkgCRAIkAiQCFAIMAggB/AH4AAwBKAEgARgABADoACAAAAAA7FjsaOx47IjtUO1wA",
    "CAAAAABmBmYOZhhmIGYnAAAACAAAAABqPGolakZqh2ovanwACG3kaFJvRW3Af5l/g3JkapoAAQAB",
    "AAA2aWYs0tEyzTXPOlk11gABAgQ7sju0ZkcukDKqAAEAAgAAO8ZmYszLygABAwE71DZpZmvAv76+",
    "vLu6OaM1Ubm4t7Y1bS/1MkgrlbW0szBsLSQ1UbKxNTwvmi4ENFzgsMyvrjA0N3oxkjIXAAUHAjvh",
    "O+hmfQQEO+w78GbBAwM7+Dv7ZvcCBDwBPANnGQUEPAs8EGdEu/0AAQIBPEIySGduAAEBAQC7Mkhn",
    "fC+hLQ8AAQACAAA8WGeKj46QzY2MAAIEATxmLOxnnAIBPGoy91Kdh4Y5zTn+AAECAjx+PIBSXzFo",
    "Olk1zwABAQMA0TyOZ6c3VzdeN14AAQEDAPo8nlBiAAEBAQDgNoxQMPp3LCEsWQABAgI8uDy6Thw1",
    "UTp1AAEBAgBsPMhnujPsLbAAAQECAGk81mfKAAEBAQBjM2dn2WXHN0I3UDdJAAICAzzuPPBLOgAB",
    "AAAuPEt0AAIBAQCRNFxKcwEBAJEtm0qILeE3wDMFAAIAAwAAPRpn6gABAAAzZ2fwW+xaWS39LicA",
    "AQQCPTI9NmgCp1hXAAEDAT1ENqhH7JFWWlVULBo1UTerAAEFAz1RPVZoDDDjLMIxTAACAAMAAD1m",
    "aBYBAQBHNltoIEAGQCdAQEBJQFpAY0B8QI1AlkDHQNBA2UDiQOtA9ED9QQ5BH0EoQTFBUkFbQWRB",
    "bUF2QX9BiEGRQZpBo0G8Qc1B3kHvQfhCCUIaQiNCLEI1Qk5CV0JgQnFCekKDQoxClUKeQqdCsEK5",
    "QsJCy0LUQt1C9kL/QwhDEUMaQytDPENVQ15DZ0NwQ3lDikOTQ5xDpUPOQ+9ECEQRRBpEI0QsRDVE",
    "PkRHRFBEWURiRHtElESdRK5Et0TARMlE0jfNO7g78DwHOtY7XDyRO5k/hTxCPhs/ej5BPsI/3kAC",
    "QGxAPkBnQQ9BMkFZQHFAiUDpP5RBoUG1QXBBhUGtX9FBsV/AQb5hB0HxQi5CSkJZQl5B1UK1QqZC",
    "kkJvQmtCYkJ0QopBmUGdP7hCy0LYQuhC8UMHQyFDEkMuQ08makJWQ3xfFF8jXzJfRV+QX5Bf1WA9",
    "YFlgXWBhYGVg0GBpYG1gcWB1YL9g1mDzYPhhDGEvYUBhGmFFYVphamG3YvBkR2UTAAA3wDfAN8AA",
    "AAAAAAAAAAAAAAA+EgAAPi8+sQAAAAAAAAAAAAAAAAAAAAAAAAAAN8AAAAAAAAAAAAAAAAAAAAAA",
    "X6AAAAAAAAAAAEIzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "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",
    "IWQIUnkruYrF"
].join("");

// Decode base64 to Uint8Array
function decodeStoryData() {
    if (typeof atob !== "undefined") {
        // Browser
        const binary = atob(STORY_DATA_BASE64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    } else {
        // Node.js
        return new Uint8Array(Buffer.from(STORY_DATA_BASE64, "base64"));
    }
}

// Opcode Implementations
ZMachine.prototype.executeInstruction = function() {
    const instrPC = this.pc;
    const opcode = this.readByte(this.pc);
    this.pc++;

    // Add comprehensive debug logging matching frotz output format
    if (this.debugMode) {
        // Get local variables from current frame
        const l1 = this.locals[0] || 0;
        const l2 = this.locals[1] || 0;
        const l3 = this.locals[2] || 0;
        const l4 = this.locals[3] || 0;
        const l5 = this.locals[4] || 0;

        console.error(`[STEP ${this.instructionCount}] PC=0x${instrPC.toString(16).padStart(4, '0')} Op=0x${opcode.toString(16).padStart(2, '0')} L1=0x${l1.toString(16).padStart(4, '0')} L2=0x${l2.toString(16).padStart(4, '0')} L3=0x${l3.toString(16).padStart(4, '0')} L4=0x${l4.toString(16).padStart(4, '0')} L5=0x${l5.toString(16).padStart(4, '0')}`);
    }

    // Decode instruction form
    if (opcode === 0xBE && VERSION >= 5) {
        return this.executeExtended();
    } else if ((opcode & 0xC0) === 0xC0) {
        // Variable form
        if (opcode < 0xE0) {
            return this.execute2OPVar(opcode & 0x1F);
        } else {
            return this.executeVAR(opcode & 0x1F);
        }
    } else if ((opcode & 0x80) === 0x80) {
        // Short form
        const operandType = (opcode >> 4) & 0x03;
        const opcodeNum = opcode & 0x0F;

        if (operandType === 0x03) {
            return this.execute0OP(opcodeNum);
        } else {
            let operand;
            if (operandType === 0x00) {
                operand = this.readWord(this.pc);
                this.pc += 2;
            } else if (operandType === 0x01) {
                operand = this.readByte(this.pc);
                this.pc++;
            } else {
                operand = ["var", this.readByte(this.pc)];
                this.pc++;
            }
            return this.execute1OP(opcodeNum, operand);
        }
    } else {
        // Long form
        const opcodeNum = opcode & 0x1F;
        const op1 = (opcode & 0x40) ? ["var", this.readByte(this.pc)] : this.readByte(this.pc);
        this.pc++;
        const op2 = (opcode & 0x20) ? ["var", this.readByte(this.pc)] : this.readByte(this.pc);
        this.pc++;
        return this.execute2OP(opcodeNum, op1, op2);
    }
};

// 0OP Instructions
ZMachine.prototype.execute0OP = function(opcode) {
    switch (opcode) {
        case 0x00: // rtrue
            this.returnFromRoutine(1);
            break;
        case 0x01: // rfalse
            this.returnFromRoutine(0);
            break;
        case 0x02: // print
            this.printLiteral();
            break;
        case 0x03: // print_ret
            this.printLiteral();
            this.newLine();
            this.returnFromRoutine(1);
            break;
        case 0x08: // ret_popped
            {
                const value = this.pop();
                this.returnFromRoutine(value);
            }
            break;
        case 0x09: // pop (discard top of stack)
            this.pop();
            break;
        case 0x0A: // quit
            this.quit();
            break;
        case 0x0B: // new_line
            this.newLine();
            break;
        case 0x0C: // show_status (V3 only)
            // In V3, this updates the status line at the top of the screen
            // We just no-op this since we don't have a proper status line implementation
            // Games call this frequently but it's not critical for gameplay
            break;
        case 0x0D: // verify
            this.branch(true); // Always succeed for now
            break;
        default:
            throw new Error(`Unimplemented 0OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 1OP Instructions
ZMachine.prototype.execute1OP = function(opcode, operand) {
    const value = this.getOperand(operand);

    switch (opcode) {
        case 0x00: // jz
            this.branch(value === 0);
            break;
        case 0x01: // get_sibling
            {
                const obj = this.getObject(value);
                const sibling = obj ? obj.sibling : 0;
                this.store(sibling);
                this.branch(sibling !== 0);
            }
            break;
        case 0x02: // get_child
            {
                const obj = this.getObject(value);
                const child = obj ? obj.child : 0;
                this.store(child);
                this.branch(child !== 0);
            }
            break;
        case 0x03: // get_parent
            {
                const obj = this.getObject(value);
                this.store(obj ? obj.parent : 0);
            }
            break;
        case 0x04: // get_prop_len
            {
                const propAddr = value;
                if (propAddr === 0) {
                    this.store(0);
                } else {
                    // Use the shared getPropertySize function
                    this.store(this.getPropertySize(propAddr));
                }
            }
            break;
        case 0x05: // inc
            {
                const varNum = value;
                const val = this.getVariable(varNum);
                this.setVariable(varNum, val + 1);
            }
            break;
        case 0x06: // dec
            {
                const varNum = value;
                const val = this.getVariable(varNum);
                this.setVariable(varNum, val - 1);
            }
            break;
        case 0x07: // print_addr
            {
                const addr = value;
                const text = this.decodeZString(addr);
                this.print(text);
            }
            break;
        case 0x08: // call_1s (V4+)
            if (VERSION >= 4) {
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(value, [], storeVar);
            }
            break;
        case 0x09: // remove_obj
            {
                const objNum = value;
                const obj = this.getObject(objNum);
                if (obj && obj.parent) {
                    const parent = this.getObject(obj.parent);
                    if (parent) {
                        // Remove from parent's child list
                        if (parent.child === objNum) {
                            this.setObjectChild(obj.parent, obj.sibling);
                        } else {
                            // Find in sibling chain
                            let prev = parent.child;
                            while (prev) {
                                const prevObj = this.getObject(prev);
                                if (prevObj && prevObj.sibling === objNum) {
                                    this.setObjectSibling(prev, obj.sibling);
                                    break;
                                }
                                prev = prevObj ? prevObj.sibling : 0;
                            }
                        }
                    }
                    this.setObjectParent(objNum, 0);
                    this.setObjectSibling(objNum, 0);
                }
            }
            break;
        case 0x0A: // print_obj
            {
                const name = this.getObjectName(value);
                this.print(name);
            }
            break;
        case 0x0B: // ret
            this.returnFromRoutine(value);
            break;
        case 0x0C: // jump
            {
                // Sign extend 16-bit value
                let offset = value;
                if (offset > 32767) offset -= 65536;
                this.pc += offset - 2;
            }
            break;
        case 0x0D: // print_paddr - packed string address
            {
                // This is a packed STRING address, so pass isString=true for V6/V7
                const addr = this.unpackAddress(value, true);
                const text = this.decodeZString(addr);
                this.print(text);
            }
            break;
        case 0x0E: // load
            {
                const varNum = value;
                if (this.debugMode && this.instructionCount < 20) {
                    console.error(`  LOAD from var ${varNum} (stack size: ${this.stack.length})`);
                }
                // When loading from sp (var 0) indirectly, peek instead of pop
                const val = (varNum === 0) ? this.peek() : this.getVariable(varNum);
                this.store(val);
            }
            break;
        case 0x0F: // not (V4) / call_1n (V5+)
            if (VERSION >= 5) {
                // call_1n
                this.callRoutine(value, [], null);
            } else if (VERSION >= 4) {
                // not (bitwise complement)
                this.store(~value & 0xFFFF);
            }
            break;
        default:
            throw new Error(`Unimplemented 1OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 2OP Instructions (Long form)
ZMachine.prototype.execute2OP = function(opcode, operand1, operand2) {
    const val1 = this.getOperand(operand1);
    const val2 = this.getOperand(operand2);

    switch (opcode) {
        case 0x00: // Illegal opcode - reserved
            // This should never be encountered in valid Z-code
            // If we hit this, something is very wrong with our implementation
            throw new Error(`Illegal 2OP opcode 0x00 encountered at PC 0x${(this.pc - 3).toString(16)} - this indicates a serious bug in instruction decoding or PC management`);
        case 0x01: // je (jump if equal)
            this.branch(val1 === val2);
            break;
        case 0x02: // jl (jump if less than - signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(a < b);
            }
            break;
        case 0x03: // jg (jump if greater than - signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(a > b);
            }
            break;
        case 0x04: // dec_chk
            {
                const varNum = val1;
                const currentVal = this.getVariable(varNum);
                const newVal = (currentVal - 1) & 0xFFFF;
                this.setVariable(varNum, newVal);
                const signedNew = newVal > 32767 ? newVal - 65536 : newVal;
                const signedCheck = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(signedNew < signedCheck);
            }
            break;
        case 0x05: // inc_chk
            {
                const varNum = val1;
                const currentVal = this.getVariable(varNum);
                const newVal = (currentVal + 1) & 0xFFFF;
                this.setVariable(varNum, newVal);
                const signedNew = newVal > 32767 ? newVal - 65536 : newVal;
                const signedCheck = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(signedNew > signedCheck);
            }
            break;
        case 0x06: // jin (jump if object is in another object)
            {
                const obj1 = this.getObject(val1);
                this.branch(obj1 && obj1.parent === val2);
            }
            break;
        case 0x07: // test (test bitmap)
            this.branch((val1 & val2) === val2);
            break;
        case 0x08: // or
            this.store(val1 | val2);
            break;
        case 0x09: // and
            this.store(val1 & val2);
            break;
        case 0x0A: // test_attr
            this.branch(this.testAttribute(val1, val2));
            break;
        case 0x0B: // set_attr
            this.setAttribute(val1, val2);
            break;
        case 0x0C: // clear_attr
            this.clearAttribute(val1, val2);
            break;
        case 0x0D: // store (variable)
            // When storing to sp (var 0) indirectly, replace top instead of push
            if (val1 === 0) {
                this.pop();  // Remove current top
                this.push(val2);  // Push new value
            } else {
                this.setVariable(val1, val2);
            }
            break;
        case 0x0E: // insert_obj
            this.insertObject(val1, val2);
            break;
        case 0x0F: // loadw (load word from array)
            {
                const addr = val1 + 2 * val2;
                this.store(this.readWord(addr));
            }
            break;
        case 0x10: // loadb (load byte from array)
            {
                const addr = val1 + val2;
                this.store(this.readByte(addr));
            }
            break;
        case 0x11: // get_prop
            this.store(this.getProperty(val1, val2));
            break;
        case 0x12: // get_prop_addr
            this.store(this.getPropertyAddr(val1, val2));
            break;
        case 0x13: // get_next_prop
            this.store(this.getNextProperty(val1, val2));
            break;
        case 0x14: // add (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a + b;
                if (result < -32768) result += 65536;
                if (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x15: // sub (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a - b;
                if (result < -32768) result += 65536;
                if (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x16: // mul (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a * b;
                while (result < -32768) result += 65536;
                while (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x17: // div (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                if (b === 0) throw new Error("Division by zero");
                const result = Math.trunc(a / b);
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x18: // mod (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                if (b === 0) throw new Error("Division by zero");
                const result = a % b;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x19: // call_2s (V4+)
            if (VERSION >= 4) {
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(val1, [val2], storeVar);
            }
            break;
        case 0x1A: // call_2n (V5+)
            if (VERSION >= 5) {
                this.callRoutine(val1, [val2], null);
            }
            break;
        case 0x1B: // set_colour (V5+)
            // Not implemented - no-op
            break;
        case 0x1C: // throw (V5+)
            // Not implemented
            break;
        default:
            throw new Error(`Unimplemented 2OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 2OP Instructions (Variable form) - reads operands and redirects to execute2OP
// Note: Some 2OP instructions like 'je' can take more than 2 operands in variable form!
ZMachine.prototype.execute2OPVar = function(opcode) {
    // Read operand types
    const types = this.readByte(this.pc);
    this.pc++;

    const operands = [];
    // Read up to 4 operands (je and some others can use all 4)
    for (let i = 0; i < 4; i++) {
        const opType = (types >> (6 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // For je opcode (0x01), handle multiple operands specially
    if (opcode === 0x01 && operands.length > 2) {
        // je with more than 2 operands: check if first equals any of the rest
        const val1 = this.getOperand(operands[0]);
        let result = false;
        for (let i = 1; i < operands.length; i++) {
            if (val1 === this.getOperand(operands[i])) {
                result = true;
                break;
            }
        }
        this.branch(result);
        return;
    }

    // For other 2OP instructions, just use first 2 operands
    return this.execute2OP(opcode, operands[0], operands[1]);
};

// VAR Instructions
ZMachine.prototype.executeVAR = function(opcode) {
    // Double-VAR opcodes (call_vs2 = 0x0C, call_vn2 = 0x1A) use 2 types bytes for up to 8 operands
    const isDoubleVar = (opcode === 0x0C || opcode === 0x1A);

    // Read operand types (1 or 2 bytes depending on opcode)
    let types;
    let maxOperands;
    if (isDoubleVar) {
        types = (this.readByte(this.pc) << 8) | this.readByte(this.pc + 1);
        this.pc += 2;
        maxOperands = 8;
    } else {
        types = this.readByte(this.pc) << 8;  // Shift to high byte for consistent handling
        this.pc++;
        maxOperands = 4;
    }

    const operands = [];
    for (let i = 0; i < maxOperands; i++) {
        const opType = (types >> (14 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // Get actual values
    const values = operands.map(op => this.getOperand(op));

    if (this.debugMode && this.instructionCount < 20 && (opcode === 0x00 || opcode === 0x01)) {
        console.error(`  -> VAR operand types: 0x${types.toString(16)}, operands:`, operands, 'values:', values);
    }

    switch (opcode) {
        case 0x00: // call (call routine with 0-3 args)
            {
                const packedAddr = values[0];
                const args = values.slice(1);
                const storeVar = this.readByte(this.pc);
                this.pc++;
                if (this.debugMode && this.instructionCount < 20) {
                    console.error(`  CALL routine 0x${packedAddr.toString(16)} with args [${args.map(a => '0x' + a.toString(16)).join(', ')}] store to var ${storeVar}`);
                }
                this.callRoutine(packedAddr, args, storeVar);
            }
            break;
        case 0x01: // storew
            this.writeWord(values[0] + 2 * values[1], values[2]);
            break;
        case 0x02: // storeb
            {
                const addr = values[0] + values[1];
                this.writeByte(addr, values[2]);
            }
            break;
        case 0x03: // put_prop
            this.putProperty(values[0], values[1], values[2]);
            break;
        case 0x04: // read (sread V1-4, aread V5+)
            if (this.debugMode) {
                console.error(`[VAR 0x04 READ] Called with values[0]=0x${values[0].toString(16)}, values[1]=0x${values[1].toString(16)}`);
            }
            if (VERSION >= 5) {
                // V5+: aread has a store byte
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.read(values[0], values[1], storeVar);
            } else {
                // V1-4: sread has no store byte
                this.read(values[0], values[1], null);
            }
            break;
        case 0x05: // print_char
            this.printChar(values[0]);
            break;
        case 0x06: // print_num
            this.printNum(values[0]);
            break;
        case 0x07: // random
            {
                const result = this.random(values[0]);
                this.store(result);
            }
            break;
        case 0x08: // push
            this.push(values[0]);
            break;
        case 0x09: // pull - version-specific behavior!
            // V1-5, V8: pull (variable) - operand is target variable number, no store byte
            // V6-7: pull stack -> (result) - has store byte, operand defaults to user stack
            if (VERSION === 6 || VERSION === 7) {
                // V6/V7: Pop from user stack (if specified) or evaluation stack
                // The operand (if provided) is a user stack address, result goes to store variable
                // For now, we just pop from evaluation stack like other versions
                const value = this.pop();
                this.store(value);
            } else {
                // V1-5, V8: Pop and store in variable specified by operand
                const value = this.pop();
                // When pulling to sp (var 0) indirectly, replace top instead of push
                if (values[0] === 0) {
                    this.pop();  // Remove current top
                    this.push(value);  // Push the pulled value
                } else {
                    this.setVariable(values[0], value);
                }
            }
            break;
        case 0x0A: // split_window (V3+)
            // Not implemented - no-op
            break;
        case 0x0B: // set_window (V3+)
            this.currentWindow = values[0];
            break;
        case 0x0C: // call_vs2 (V4+)
            if (VERSION >= 4) {
                const packedAddr = values[0];
                const args = values.slice(1);
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(packedAddr, args, storeVar);
            }
            break;
        case 0x0D: // erase_window (V4+)
            // Not implemented - no-op
            break;
        case 0x0E: // erase_line (V4+)
            // Not implemented - no-op
            break;
        case 0x0F: // set_cursor (V4+)
            // Not implemented - no-op
            break;
        case 0x10: // get_cursor (V4+)
            // Not implemented - no-op
            break;
        case 0x11: // set_text_style (V4+)
            // Not implemented - no-op
            break;
        case 0x12: // buffer_mode (V4+)
            // Not implemented - no-op
            break;
        case 0x13: // output_stream (V3+)
            // Not implemented - no-op
            break;
        case 0x14: // input_stream (V3+)
            // Not implemented - no-op
            break;
        case 0x15: // sound_effect (V3+)
            {
                // sound_effect number effect volume routine
                // effect: 1=prepare, 2=start, 3=stop, 4=finish
                // volume: high byte = repeats (255=forever), low byte = volume (1-8, 8=loudest)
                const soundNum = values[0] || 0;
                const effect = values[1] || 2;  // Default to start
                const volume = values[2] || 8;  // Default to max volume
                // values[3] would be interrupt routine (V5+)

                if (this.soundCallback) {
                    this.soundCallback(soundNum, effect, volume);
                } else if (typeof Audio !== 'undefined' && this.sounds[soundNum]) {
                    // Basic browser audio support
                    const sound = this.sounds[soundNum];
                    if (effect === 2) {
                        // Start playing
                        if (this.currentSound) {
                            this.currentSound.pause();
                        }
                        try {
                            const audio = new Audio('data:audio/' + sound.format + ';base64,' + sound.data);
                            audio.volume = (volume & 0xFF) / 8;
                            const repeats = (volume >> 8) & 0xFF;
                            if (repeats === 255) {
                                audio.loop = true;
                            }
                            audio.play().catch(() => {});
                            this.currentSound = audio;
                        } catch (e) {
                            if (this.debugMode) console.error('[SOUND] Failed to play:', e);
                        }
                    } else if (effect === 3 || effect === 4) {
                        // Stop/finish
                        if (this.currentSound) {
                            this.currentSound.pause();
                            this.currentSound = null;
                        }
                    }
                }
            }
            break;
        case 0x16: // read_char (V4+)
            {
                // read_char device [time routine] -> (result)
                // device is always 1 (keyboard)
                // For now we ignore timed input
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.readChar(storeVar);
            }
            break;
        case 0x17: // scan_table (V4+)
            {
                const result = this.scanTable(values[0], values[1], values[2], values[3] || 0x82);
                this.store(result);
                this.branch(result !== 0);
            }
            break;
        case 0x18: // not (bitwise not) - V5+, but also used in V1-4 as VAR form
            this.store(~values[0] & 0xFFFF);
            break;
        case 0x19: // call_vn (V5+)
            if (VERSION >= 5) {
                this.callRoutine(values[0], values.slice(1), null);
            }
            break;
        case 0x1A: // call_vn2 (V5+)
            if (VERSION >= 5) {
                this.callRoutine(values[0], values.slice(1), null);
            }
            break;
        case 0x1B: // tokenise (V5+)
            // Not implemented - no-op
            break;
        case 0x1C: // encode_text (V5+)
            // Not implemented - no-op
            break;
        case 0x1D: // copy_table (V5+)
            // Not implemented - no-op
            break;
        case 0x1E: // print_table (V5+)
            // Not implemented - no-op
            break;
        case 0x1F: // check_arg_count (V5+)
            {
                // Check if argument number N was provided to current routine
                const argNum = values[0];
                // For now, assume all explicitly passed args are present
                // This is a simplification - would need to track actual arg count
                this.branch(argNum <= this.locals.length);
            }
            break;
        default:
            throw new Error(`Unimplemented VAR opcode: 0x${opcode.toString(16)}`);
    }
};

// Extended Instructions (V5+ only, opcode 0xBE prefix)
ZMachine.prototype.executeExtended = function() {
    // Read the extended opcode number
    const extOpcode = this.readByte(this.pc);
    this.pc++;

    // Read operand types
    const types = this.readByte(this.pc);
    this.pc++;

    const operands = [];
    for (let i = 0; i < 4; i++) {
        const opType = (types >> (6 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // Get actual values
    const values = operands.map(op => this.getOperand(op));

    if (this.debugMode) {
        console.error(`[EXT 0x${extOpcode.toString(16)}] values: [${values.map(v => '0x' + v.toString(16)).join(', ')}]`);
    }

    switch (extOpcode) {
        case 0x00: // save (extended form, V5+)
            {
                // V5+ save with optional table/bytes/name
                // Returns 0 on failure, 1 on save, 2 on restore
                const result = this.save() ? 1 : 0;
                this.store(result);
            }
            break;

        case 0x01: // restore (extended form, V5+)
            {
                // V5+ restore with optional table/bytes/name
                if (this.restoreCallback) {
                    const state = this.restoreCallback();
                    if (this.restore(state)) {
                        // Restore succeeded - store 2 to indicate success
                        this.store(2);
                    } else {
                        this.store(0);
                    }
                } else {
                    this.store(0);
                }
            }
            break;

        case 0x02: // log_shift - logical shift
            {
                const number = values[0];
                const places = values[1] > 32767 ? values[1] - 65536 : values[1]; // signed
                let result;
                if (places >= 0) {
                    result = (number << places) & 0xFFFF;
                } else {
                    result = (number >>> -places) & 0xFFFF;
                }
                this.store(result);
            }
            break;

        case 0x03: // art_shift - arithmetic shift
            {
                let number = values[0] > 32767 ? values[0] - 65536 : values[0]; // signed
                const places = values[1] > 32767 ? values[1] - 65536 : values[1]; // signed
                let result;
                if (places >= 0) {
                    result = (number << places);
                } else {
                    result = (number >> -places); // arithmetic right shift preserves sign
                }
                result = result & 0xFFFF;
                this.store(result);
            }
            break;

        case 0x04: // set_font
            {
                // Font 1 = normal, 3 = character graphics, 4 = fixed-pitch
                // Return previous font number, or 0 if requested font not available
                const font = values[0];
                // For now, accept font 1 (normal) and 4 (fixed)
                if (font === 1 || font === 4) {
                    this.store(1); // Pretend we were using font 1
                } else {
                    this.store(0); // Font not available
                }
            }
            break;

        case 0x05: // draw_picture (V6 graphics)
            {
                // draw_picture picture-number y x
                const picNum = values[0];
                const y = values.length > 1 ? values[1] : 1;
                const x = values.length > 2 ? values[2] : 1;

                if (this.graphicsCallback) {
                    this.graphicsCallback('draw', picNum, x, y);
                } else if (this.pictures[picNum]) {
                    // Basic browser support - create an img element
                    if (typeof document !== 'undefined') {
                        const pic = this.pictures[picNum];
                        const img = document.createElement('img');
                        img.src = 'data:image/' + pic.format + ';base64,' + pic.data;
                        img.style.position = 'absolute';
                        img.style.left = x + 'px';
                        img.style.top = y + 'px';
                        const container = document.getElementById('graphics-container');
                        if (container) container.appendChild(img);
                    }
                }
                if (this.debugMode) console.error(`[EXT] draw_picture: pic=${picNum} at (${x},${y})`);
            }
            break;

        case 0x06: // picture_data (V6 graphics)
            {
                // picture_data picture-number array -> (result)
                // If picture-number is 0, returns number of pictures
                // Otherwise stores width and height in array and branches if exists
                const picNum = values[0];
                const array = values.length > 1 ? values[1] : 0;

                if (picNum === 0) {
                    // Return total number of pictures
                    this.store(Object.keys(this.pictures).length);
                } else if (this.pictures[picNum]) {
                    const pic = this.pictures[picNum];
                    if (array) {
                        this.writeWord(array, pic.height || 0);
                        this.writeWord(array + 2, pic.width || 0);
                    }
                    this.branch(true);
                } else {
                    this.branch(false);
                }
            }
            break;

        case 0x07: // erase_picture (V6 graphics)
            {
                // erase_picture picture-number y x - erase area same size as picture
                const picNum = values[0];
                const y = values.length > 1 ? values[1] : 1;
                const x = values.length > 2 ? values[2] : 1;

                if (this.graphicsCallback) {
                    this.graphicsCallback('erase', picNum, x, y);
                }
                if (this.debugMode) console.error(`[EXT] erase_picture: pic=${picNum} at (${x},${y})`);
            }
            break;

        case 0x08: // set_margins (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] set_margins: not implemented');
            break;

        case 0x09: // save_undo
            {
                // Save undo state
                // Returns -1 if undo not available, 0 on failure, 1 on save, 2 on successful restore
                if (!this.undoStates) {
                    this.undoStates = [];
                }
                try {
                    const state = {
                        memory: this.memory.slice(0, STATIC_MEMORY),
                        stack: this.stack.slice(),
                        callStack: JSON.parse(JSON.stringify(this.callStack)),
                        pc: this.pc,
                        locals: this.locals.slice()
                    };
                    this.undoStates.push(state);
                    // Limit undo history
                    if (this.undoStates.length > 10) {
                        this.undoStates.shift();
                    }
                    this.store(1);
                } catch (e) {
                    this.store(0);
                }
            }
            break;

        case 0x0A: // restore_undo
            {
                if (!this.undoStates || this.undoStates.length === 0) {
                    this.store(0);
                } else {
                    const state = this.undoStates.pop();
                    // Restore dynamic memory
                    for (let i = 0; i < state.memory.length; i++) {
                        this.memory[i] = state.memory[i];
                    }
                    this.stack = state.stack.slice();
                    this.callStack = JSON.parse(JSON.stringify(state.callStack));
                    this.pc = state.pc;
                    this.locals = state.locals.slice();
                    this.store(2); // Successful restore
                }
            }
            break;

        case 0x0B: // print_unicode
            {
                const charCode = values[0];
                this.print(String.fromCharCode(charCode));
            }
            break;

        case 0x0C: // check_unicode
            {
                // Check if unicode character can be printed (bit 0) or read (bit 1)
                // For simplicity, assume all characters can be printed and read
                this.store(3); // Both bits set
            }
            break;

        case 0x0D: // set_true_colour (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] set_true_colour: not implemented');
            break;

        case 0x10: // move_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] move_window: not implemented');
            break;

        case 0x11: // window_size (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] window_size: not implemented');
            break;

        case 0x12: // window_style (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] window_style: not implemented');
            break;

        case 0x13: // get_wind_prop (V6)
            // Return 0 for all window properties
            this.store(0);
            break;

        case 0x14: // scroll_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] scroll_window: not implemented');
            break;

        case 0x15: // pop_stack (V6)
            {
                // Pop items from a stack
                const items = values[0];
                const stack = values.length > 1 ? values[1] : 0; // 0 = evaluation stack
                for (let i = 0; i < items; i++) {
                    this.pop();
                }
            }
            break;

        case 0x16: // read_mouse (V6)
            // Not implemented - just return zeros
            if (values[0]) {
                this.writeWord(values[0], 0);     // Y coordinate
                this.writeWord(values[0] + 2, 0); // X coordinate
                this.writeWord(values[0] + 4, 0); // Buttons
                this.writeWord(values[0] + 6, 0); // Menu selection
            }
            break;

        case 0x17: // mouse_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] mouse_window: not implemented');
            break;

        case 0x18: // push_stack (V6)
            {
                // Push value onto a user stack, branch on success
                // For simplicity, just push to evaluation stack
                this.push(values[0]);
                this.branch(true);
            }
            break;

        case 0x19: // put_wind_prop (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] put_wind_prop: not implemented');
            break;

        case 0x1A: // print_form (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] print_form: not implemented');
            break;

        case 0x1B: // make_menu (V6)
            // Not implemented - always fail
            this.branch(false);
            break;

        case 0x1C: // picture_table (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] picture_table: not implemented');
            break;

        case 0x1D: // buffer_screen (V6)
            // Return 0 (buffer screen mode not supported)
            this.store(0);
            break;

        default:
            throw new Error(`Unimplemented extended opcode: 0x${extOpcode.toString(16)}`);
    }
};

// Helper functions
ZMachine.prototype.printLiteral = function() {
    const text = this.decodeZString(this.pc);
    this.print(text);
    // Skip past the Z-string (which uses 2-byte words)
    // The high bit of each word indicates if it's the last word
    let addr = this.pc;
    while (true) {
        const word = this.readWord(addr);
        addr += 2;
        if (word & 0x8000) {
            // This was the last word
            break;
        }
    }
    this.pc = addr;
};

ZMachine.prototype.branch = function(condition) {
    // Save the address of the branch data for offset calculation
    const branchDataAddr = this.pc;
    const branchByte = this.readByte(this.pc);
    this.pc++;

    const branchOnTrue = !!(branchByte & 0x80);
    let offset;
    let offsetSize;

    if (branchByte & 0x40) {
        // Short form (6-bit offset)
        offset = branchByte & 0x3F;
        offsetSize = 1;  // 1 byte total
    } else {
        // Long form (14-bit signed offset)
        const secondByte = this.readByte(this.pc);
        offset = ((branchByte & 0x3F) << 8) | secondByte;
        this.pc++;
        offsetSize = 2;  // 2 bytes total

        if (offset & 0x2000) {
            offset |= 0xC000; // Sign extend
        }
        // Convert to signed
        if (offset > 32767) offset -= 65536;
    }

    if (condition === branchOnTrue) {
        if (offset === 0) {
            this.returnFromRoutine(0);
        } else if (offset === 1) {
            this.returnFromRoutine(1);
        } else {
            // Offset is relative to the address AFTER the branch data
            // The offset of 2 means "branch to the instruction immediately after this one"
            // So we calculate: (address of branch data) + (size of branch data) + (offset) - 2
            const newPC = branchDataAddr + offsetSize + offset - 2;

            // Safety check: don't branch to header area (first 64 bytes)
            if (newPC < 0x40) {
                if (this.debugMode) {
                    console.error(`[BRANCH] WARNING: Attempted to branch to 0x${newPC.toString(16)} which is in the header`);
                    console.error(`[BRANCH] This usually indicates a bug in parsing or variable handling`);
                    console.error(`[BRANCH] Branch from 0x${branchDataAddr.toString(16)} with offset ${offset}`);
                    console.error(`[BRANCH] This is likely a parse error - returning 0 to indicate failure`);
                }
                // Treat this as a catastrophic error and return false from the routine
                this.returnFromRoutine(0);
            } else {
                this.pc = newPC;
            }
        }
    }
};

ZMachine.prototype.store = function(value) {
    const varNum = this.readByte(this.pc);
    this.pc++;
    this.setVariable(varNum, value);
};

ZMachine.prototype.returnFromRoutine = function(value) {
    if (this.callStack.length === 0) {
        this.quit();
        return;
    }

    const frame = this.callStack.pop();

    this.pc = frame.returnPC;
    this.locals = frame.locals;

    if (frame.storeVar !== null) {
        this.setVariable(frame.storeVar, value);
    }
};

ZMachine.prototype.getObjectName = function(objNum) {
    const obj = this.getObject(objNum);
    if (!obj) return "";

    let propAddr = obj.properties;
    const textLength = this.readByte(propAddr);
    propAddr++;

    if (textLength === 0) return "";

    return this.decodeZString(propAddr);
};

// Routine call handling
ZMachine.prototype.callRoutine = function(packedAddr, args, storeVar) {
    if (packedAddr === 0) {
        if (storeVar !== null) {
            this.setVariable(storeVar, 0);
        }
        return;
    }

    const addr = this.unpackAddress(packedAddr);

    // Sanity check - routine address should be at least in static memory region
    if (addr < STATIC_MEMORY) {
        console.warn(`Warning: Attempted to call routine at invalid address 0x${addr.toString(16)} (packed: 0x${packedAddr.toString(16)})`);
        if (storeVar !== null) {
            this.setVariable(storeVar, 0);
        }
        return;
    }

    // Read routine header
    const numLocals = this.readByte(addr);

    if (this.debugMode && this.instructionCount < 20) {
        console.error(`  -> Unpacked to addr 0x${addr.toString(16)}, numLocals=${numLocals}`);
    }

    // Sanity check - Z-Machine routines can have at most 15 locals
    if (numLocals > 15) {
        console.error(`[CALL ERROR] Invalid routine - dumping call stack:`);
        for (let i = this.callStack.length - 1; i >= 0; i--) {
            const frame = this.callStack[i];
            console.error(`  Frame ${i}: returnPC=0x${frame.returnPC.toString(16)}, storeVar=${frame.storeVar}`);
        }
        console.error(`[CALL ERROR] Current locals: ${this.locals.slice(0, 16).map((v, i) => `L${i+1}=0x${(v||0).toString(16)}`).join(', ')}`);
        console.error(`[CALL ERROR] Stack top 10: [${this.stack.slice(-10).map(v => '0x' + v.toString(16)).join(', ')}]`);
        throw new Error(`Invalid routine at 0x${addr.toString(16)} (packed: 0x${packedAddr.toString(16)}): numLocals=${numLocals} exceeds maximum of 15`);
    }

    // Save current state (make a copy of locals array!)

    this.callStack.push({
        returnPC: this.pc,
        locals: this.locals.slice(),
        numLocals: numLocals,
        storeVar: storeVar
    });

    // Initialize new locals
    this.locals = new Array(16);

    // Set up locals
    if (VERSION <= 4) {
        // Read default local values
        for (let i = 0; i < numLocals; i++) {
            this.locals[i] = this.readWord(addr + 1 + i * 2);
        }
        this.pc = addr + 1 + numLocals * 2;
    } else {
        // V5+ - locals start at 0
        for (let i = 0; i < numLocals; i++) {
            this.locals[i] = 0;
        }
        this.pc = addr + 1;
    }

    // Copy arguments to locals
    if (this.debugMode) {
        console.error(`[CALL ${this.instructionCount}] To addr 0x${addr.toString(16)}: numLocals=${numLocals}, args=[${args.map(a => '0x'+a.toString(16)).join(', ')}]`);
        console.error(`[CALL ${this.instructionCount}] Defaults: ${this.locals.slice(0, numLocals).map((v,i) => `L${i+1}=0x${v.toString(16)}`).join(' ')}`);
    }
    for (let i = 0; i < args.length && i < numLocals; i++) {
        this.locals[i] = args[i];
    }
    if (this.debugMode) {
        console.error(`[CALL ${this.instructionCount}] Final:    ${this.locals.slice(0, numLocals).map((v,i) => `L${i+1}=0x${v.toString(16)}`).join(' ')}`);
    }
};

// Crash dump generation
ZMachine.prototype.generateCrashDump = function(error) {
    const dump = {
        timestamp: new Date().toISOString(),
        error: {
            message: error.message,
            stack: error.stack,
            name: error.name
        },
        machine: {
            version: VERSION,
            pc: `0x${this.pc.toString(16)}`,
            instructionCount: this.instructionCount,
            running: this.running,
            finished: this.finished
        },
        memory: {
            staticMemoryStart: `0x${STATIC_MEMORY.toString(16)}`,
            highMemoryStart: `0x${HIGH_MEMORY.toString(16)}`,
            pcBytes: Array.from(this.memory.slice(Math.max(0, this.pc - 10), this.pc + 20)).map(b => `0x${b.toString(16).padStart(2, '0')}`)
        },
        stack: {
            evaluationStack: this.stack.slice(-20).map(v => `0x${v.toString(16)}`),
            stackDepth: this.stack.length,
            callStack: this.callStack.map((frame, i) => ({
                frameNumber: i,
                returnPC: `0x${frame.returnPC.toString(16)}`,
                numLocals: frame.numLocals,
                storeVar: frame.storeVar,
                locals: frame.locals.slice(0, frame.numLocals).map(v => v === undefined ? 'undefined' : `0x${v.toString(16)}`)
            })),
            callDepth: this.callStack.length
        },
        locals: this.locals.map((v, i) => v === undefined ? undefined : `0x${v.toString(16)}`),
        globals: {
            sample: Array.from({length: 10}, (_, i) => {
                const addr = GLOBALS_ADDR + i * 2;
                return `g${i.toString().padStart(3, '0')}: 0x${this.readWord(addr).toString(16).padStart(4, '0')}`;
            })
        },
        instructionHistory: this.instructionHistory,
        output: {
            buffer: this.outputBuffer.substring(Math.max(0, this.outputBuffer.length - 500)),
            totalLength: this.outputBuffer.length
        }
    };

    return dump;
};

ZMachine.prototype.saveCrashDump = function(dump) {
    const json = JSON.stringify(dump, null, 2);

    if (typeof window !== "undefined" && typeof document !== "undefined") {
        // Browser environment - offer download
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `zmachine-crash-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.error('Crash dump saved to downloads');
    } else if (typeof require !== "undefined") {
        // Node.js environment
        try {
            const fs = require('fs');
            const filename = `zmachine-crash-${Date.now()}.json`;
            fs.writeFileSync(filename, json);
            console.error(`Crash dump saved to ${filename}`);
        } catch (e) {
            console.error('Failed to save crash dump:', e.message);
            console.error('Crash dump:', json);
        }
    } else {
        console.error('Crash dump:', json);
    }
};

ZMachine.prototype.recordInstruction = function(pc, opcode) {
    if (!this.debugMode) return;

    const record = {
        count: this.instructionCount,
        pc: `0x${pc.toString(16)}`,
        opcode: `0x${opcode.toString(16)}`,
        stackDepth: this.stack.length,
        callDepth: this.callStack.length
    };

    this.instructionHistory.push(record);
    if (this.instructionHistory.length > this.maxHistorySize) {
        this.instructionHistory.shift();
    }
};

// Main execution loop
ZMachine.prototype.run = function() {
    const entryPC = this.pc;
    const entryStack = this.stack.length;
    const entryInst = this.instructionCount;
    this.running = true;
    if (this.debugMode) {
        console.error(`[RUN] Entry: PC=0x${entryPC.toString(16)} stack=${entryStack} inst=${entryInst}`);
    }

    // Always increment instruction count (used for yielding in browser)
    let localInstructionCount = 0;

    while (this.running && !this.finished) {
        try {
            const currentPC = this.pc;
            const opcode = this.readByte(this.pc);

            if (this.debugMode) {
                this.recordInstruction(currentPC, opcode);
                this.instructionCount++;
            }
            localInstructionCount++;

            this.executeInstruction();

            // Safety check - detect infinite loops
            if (this.debugMode && this.instructionCount > 100000) {
                throw new Error(`Instruction count exceeded 100000 - possible infinite loop`);
            }

        } catch (e) {
            console.error(`\n========== Z-MACHINE CRASH ==========`);
            console.error(`Error at PC 0x${this.pc.toString(16)}: ${e.message}`);
            console.error(`Instruction count: ${this.instructionCount}`);
            console.error(`Call depth: ${this.callStack.length}`);
            console.error(`Stack depth: ${this.stack.length}`);
            console.error(`=====================================\n`);

            if (this.debugMode) {
                const dump = this.generateCrashDump(e);
                this.saveCrashDump(dump);
                console.error('Full crash dump has been saved');
            }

            console.error('\nStack trace:', e.stack);
            this.running = false;
            break;
        }

        // Yield periodically for UI updates (every 1000 instructions)
        if (localInstructionCount % 1000 === 0 && typeof window !== "undefined") {
            setTimeout(() => this.run(), 0);
            return;
        }
    }

    if (this.finished) {
        console.error('\n[Z-Machine execution completed]');
    } else if (!this.running) {
        console.error('\n[Z-Machine execution stopped]');
    }
};

// Initialize and start the Z-Machine
function createZMachine() {
    const storyData = decodeStoryData();
    return new ZMachine(storyData);
}

// Module exports
if (typeof module !== "undefined" && module.exports) {
    // Node.js
    module.exports = {
        ZMachine,
        createZMachine,
        VERSION,
        decodeStoryData
    };

    // Auto-run if executed directly (not required as a module)
    if (require.main === module) {
        console.error('Starting Z-Machine game...\n');
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        const m = createZMachine();

        // Check for --debug flag
        if (process.argv.includes('--debug')) {
            m.debugMode = true;
            console.error('[DEBUG MODE ENABLED]\n');
        }

        // Output handler
        m.outputCallback = (text) => {
            process.stdout.write(text);
        };

        // Input handler will be set by read() opcode when needed
        m.inputCallback = null;

        // Input polling function
        function checkForInput() {
            if (m.inputCallback && !m.running) {
                // Game is waiting for input
                rl.question('\n> ', (answer) => {
                    if (m.inputCallback) {
                        m.inputCallback(answer);
                        // Check again after execution
                        setTimeout(checkForInput, 10);
                    }
                });
            } else if (m.finished) {
                // Game is done
                rl.close();
            } else if (!m.running) {
                // Check again soon
                setTimeout(checkForInput, 10);
            } else {
                // Still running, check again
                setTimeout(checkForInput, 10);
            }
        }

        // Start the game
        try {
            m.run();
            // Start polling for input
            setTimeout(checkForInput, 10);
        } catch (e) {
            console.error('Fatal error:', e.message);
            console.error(e.stack);
            rl.close();
            process.exit(1);
        }
    }
} else if (typeof define === "function" && define.amd) {
    // AMD
    define([], function() {
        return {
            ZMachine,
            createZMachine,
            VERSION,
            decodeStoryData
        };
    });
} else {
    // Browser global
    window.ZMachine = ZMachine;
    window.createZMachine = createZMachine;
}