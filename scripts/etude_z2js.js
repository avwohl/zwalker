/**
 * Z-Machine JavaScript Runtime
 * Generated by z2js compiler
 *
 * Story: 970325
 * Z-Machine Version: 5
 * Release: 2
 */

"use strict";

// Z-Machine Constants
const VERSION = 5;
const INITIAL_PC = 0x05F5;  // Direct byte address
const DICTIONARY_ADDR = 0x05EC;
const OBJECT_TABLE_ADDR = 0x0102;
const GLOBALS_ADDR = 0x02E0;
const STATIC_MEMORY = 0x05EA;
const ABBREVIATIONS_ADDR = 0x0042;
const HIGH_MEMORY = 0x05F4;
// V6/V7 offsets for packed addresses (already multiplied by 8 in header parsing)
const ROUTINES_OFFSET = 0x0000;
const STRINGS_OFFSET = 0x0000;

// Z-Machine Runtime
class ZMachine {
    constructor(storyData) {
        // Memory
        this.memory = new Uint8Array(storyData);
        this.originalMemory = new Uint8Array(storyData);

        // CPU state
        this.pc = INITIAL_PC;
        this.stack = [];
        this.callStack = [];
        this.locals = new Array(16);

        // I/O
        this.outputBuffer = "";
        this.statusLine = { location: "", score: 0, turns: 0 };
        this.windows = [{ text: "", cursor: [1, 1] }, { text: "", cursor: [1, 1] }];
        this.currentWindow = 0;

        // Interpreter state
        this.running = false;
        this.finished = false;
        this.inputCallback = null;
        this.outputCallback = null;
        this.saveCallback = null;
        this.restoreCallback = null;

        // Random state
        this.randomMode = "random";
        this.randomSeed = 0;
        this.randomIndex = 0;

        // Debug state
        this.debugMode = false;  // Enable debug to trace instructions (set to true to enable)
        this.instructionCount = 0;
        this.instructionHistory = [];
        this.maxHistorySize = 100;

        // Multimedia resources (V6 graphics/sound)
        this.pictures = {};       // picture_num -> { data: base64, format: 'png'|'jpeg', width, height }
        this.sounds = {};         // sound_num -> { data: base64, format: 'aiff'|'ogg'|'mod' }
        this.currentSound = null; // Currently playing audio element
        this.graphicsCallback = null;  // Function to call for drawing pictures
        this.soundCallback = null;     // Function to call for playing sounds

        // Transcript recording (zwalker-compatible format)
        this.transcriptEnabled = false;
        this.transcriptData = [];     // Array of { command, from_room, to_room, result }
        this.lastCommand = null;
        this.lastRoomNumber = null;
    }

    // Memory access
    readByte(addr) {
        return this.memory[addr];
    }

    readWord(addr) {
        return (this.memory[addr] << 8) | this.memory[addr + 1];
    }

    writeByte(addr, value) {
        if (addr >= STATIC_MEMORY) {
            throw new Error(`[WRITE PROTECTION] Attempted to write byte to read-only memory at 0x${addr.toString(16)} (value=0x${value.toString(16)}, static memory starts at 0x${STATIC_MEMORY.toString(16)})`);
        }
        const oldValue = this.memory[addr];
        this.memory[addr] = value & 0xFF;
        if (this.debugMode) {
            console.error(`[WRITE #${this.instructionCount}] @0x${addr.toString(16).padStart(4,'0')} byte 0x${oldValue.toString(16).padStart(2,'0')} -> 0x${(value & 0xFF).toString(16).padStart(2,'0')}`);
        }
    }

    writeWord(addr, value) {
        if (addr >= STATIC_MEMORY) {
            throw new Error(`[WRITE PROTECTION] Attempted to write word to read-only memory at 0x${addr.toString(16)} (value=0x${value.toString(16)}, static memory starts at 0x${STATIC_MEMORY.toString(16)})`);
        }
        const oldValue = this.readWord(addr);
        this.memory[addr] = (value >> 8) & 0xFF;
        this.memory[addr + 1] = value & 0xFF;
        if (this.debugMode) {
            console.error(`[WRITE #${this.instructionCount}] @0x${addr.toString(16).padStart(4,'0')} word 0x${oldValue.toString(16).padStart(4,'0')} -> 0x${(value & 0xFFFF).toString(16).padStart(4,'0')}`);
        }
    }

    // Stack operations
    push(value) {
        this.stack.push(value & 0xFFFF);
    }

    pop() {
        if (this.stack.length === 0) {
            throw new Error("Stack underflow");
        }
        return this.stack.pop();
    }

    peek() {
        if (this.stack.length === 0) {
            throw new Error("Stack underflow");
        }
        return this.stack[this.stack.length - 1];
    }

    // Variable access (0=stack, 1-15=locals, 16+=globals)
    getVariable(varNum) {
        if (varNum === 0) {
            return this.pop();
        } else if (varNum < 16) {
            return this.locals[varNum - 1] || 0;
        } else {
            const addr = GLOBALS_ADDR + (varNum - 16) * 2;
            return this.readWord(addr);
        }
    }

    setVariable(varNum, value) {
        value = value & 0xFFFF;
        if (varNum === 0) {
            this.push(value);
        } else if (varNum < 16) {
            this.locals[varNum - 1] = value;
        } else {
            const addr = GLOBALS_ADDR + (varNum - 16) * 2;
            this.writeWord(addr, value);
        }
    }

    // Operand evaluation
    getOperand(operand) {
        if (Array.isArray(operand) && operand[0] === "var") {
            return this.getVariable(operand[1]);
        }
        return operand;
    }

    // Packed address conversion
    // V6/V7 use different offsets for routines vs strings
    // V8 uses divisor of 8 but NO offsets (like V5 semantics)
    unpackAddress(packed, isString = false) {
        switch (VERSION) {
            case 1: case 2: case 3:
                return packed * 2;
            case 4: case 5:
                return packed * 4;
            case 6: case 7:
                // V6/V7: Use appropriate offset based on address type
                if (isString) {
                    return packed * 4 + STRINGS_OFFSET;
                } else {
                    return packed * 4 + ROUTINES_OFFSET;
                }
            case 8:
                // V8 uses divisor of 8 but NO offsets
                return packed * 8;
            default:
                return packed * 2;
        }
    }

    // Z-String decoding with version-specific handling
    // V1: z-char 1 = newline, z-chars 2-3 = shift up/down, z-chars 4-5 = shift lock
    // V2: z-chars 1-3 = abbreviations (only 1 in V2), z-chars 4-5 = shift (temporary in V2)
    // V3+: z-chars 1-3 = abbreviations, z-chars 4-5 = temporary shift
    decodeZString(addr) {
        // A2 alphabet varies by version
        // V1: no newline, digits start at position 1 (z-char 7 = '0')
        // V2+: newline at position 1, digits start at position 2 (z-char 8 = '0')
        const a2_v1 = " 0123456789.,!?_#'\"/<-:()";
        const a2_v2plus = " \n0123456789.,!?_#'\"/-:()";

        const alphabets = [
            "abcdefghijklmnopqrstuvwxyz",      // A0 (lowercase)
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ",      // A1 (uppercase)
            VERSION === 1 ? a2_v1 : a2_v2plus  // A2 (punctuation/digits)
        ];

        let result = "";
        let alphabet = 0;
        let lockAlphabet = 0;  // For V1/V2 shift lock
        let abbrevTable = 0;   // Which abbreviation table (1-3)
        let zsciiState = 0;    // 0=normal, 1=waiting high, 2=waiting low
        let zsciiHigh = 0;

        while (true) {
            const word = this.readWord(addr);
            addr += 2;

            const chars = [
                (word >> 10) & 0x1F,
                (word >> 5) & 0x1F,
                word & 0x1F
            ];

            for (let c of chars) {
                // Handle 10-bit ZSCII escape sequence
                if (zsciiState === 1) {
                    zsciiHigh = c;
                    zsciiState = 2;
                    continue;
                } else if (zsciiState === 2) {
                    const zsciiCode = (zsciiHigh << 5) | c;
                    if (zsciiCode > 0) result += String.fromCharCode(zsciiCode);
                    zsciiState = 0;
                    alphabet = lockAlphabet;
                    continue;
                }

                // Handle abbreviation mode
                if (abbrevTable > 0) {
                    if (VERSION >= 2 && ABBREVIATIONS_ADDR) {
                        const abbrevAddr = ABBREVIATIONS_ADDR + 2 * (32 * (abbrevTable - 1) + c);
                        const wordAddr = this.readWord(abbrevAddr);
                        result += this.decodeZString(wordAddr * 2);
                    }
                    abbrevTable = 0;
                    alphabet = lockAlphabet;
                    continue;
                }

                // Z-char 0: always space
                if (c === 0) {
                    result += " ";
                    alphabet = lockAlphabet;
                    continue;
                }

                // Z-char 1
                if (c === 1) {
                    if (VERSION === 1) {
                        // V1: newline
                        result += "\n";
                        alphabet = lockAlphabet;
                    } else {
                        // V2+: abbreviation table 0
                        abbrevTable = 1;
                    }
                    continue;
                }

                // Z-char 2
                if (c === 2) {
                    if (VERSION === 1) {
                        // V1: temporary shift UP
                        alphabet = (alphabet + 1) % 3;
                    } else if (VERSION === 2) {
                        // V2: temporary shift UP
                        alphabet = (lockAlphabet + 1) % 3;
                    } else {
                        // V3+: abbreviation table 1
                        abbrevTable = 2;
                    }
                    continue;
                }

                // Z-char 3
                if (c === 3) {
                    if (VERSION === 1) {
                        // V1: temporary shift DOWN
                        alphabet = (alphabet + 2) % 3;
                    } else if (VERSION === 2) {
                        // V2: temporary shift DOWN
                        alphabet = (lockAlphabet + 2) % 3;
                    } else {
                        // V3+: abbreviation table 2
                        abbrevTable = 3;
                    }
                    continue;
                }

                // Z-char 4
                if (c === 4) {
                    if (VERSION <= 2) {
                        // V1/V2: shift lock UP
                        lockAlphabet = (lockAlphabet + 1) % 3;
                        alphabet = lockAlphabet;
                    } else {
                        // V3+: temporary shift to A1
                        alphabet = 1;
                    }
                    continue;
                }

                // Z-char 5
                if (c === 5) {
                    if (VERSION <= 2) {
                        // V1/V2: shift lock DOWN
                        lockAlphabet = (lockAlphabet + 2) % 3;
                        alphabet = lockAlphabet;
                    } else {
                        // V3+: temporary shift to A2
                        alphabet = 2;
                    }
                    continue;
                }

                // Z-char 6 in A2: start 10-bit ZSCII escape
                if (c === 6 && alphabet === 2) {
                    zsciiState = 1;
                    continue;
                }

                // Regular character (z-chars 6-31)
                if (c >= 6) {
                    const idx = c - 6;
                    if (alphabet === 0 && idx < alphabets[0].length) {
                        result += alphabets[0][idx];
                    } else if (alphabet === 1 && idx < alphabets[1].length) {
                        result += alphabets[1][idx];
                    } else if (alphabet === 2 && idx < alphabets[2].length) {
                        result += alphabets[2][idx];
                    }
                }

                // Reset alphabet after character
                if (VERSION >= 3) {
                    alphabet = 0;
                } else {
                    alphabet = lockAlphabet;
                }
            }

            if (word & 0x8000) break;
        }

        return result;
    }

    // Object system
    getObject(objNum) {
        if (objNum === 0) return null;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            return {
                attributes: this.readWord(objAddr) << 16 | this.readWord(objAddr + 2),
                parent: this.readByte(objAddr + 4),
                sibling: this.readByte(objAddr + 5),
                child: this.readByte(objAddr + 6),
                properties: this.readWord(objAddr + 7)
            };
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            return {
                attributes: this.readWord(objAddr) << 32 | this.readWord(objAddr + 2) << 16 |
                           this.readWord(objAddr + 4),
                parent: this.readWord(objAddr + 6),
                sibling: this.readWord(objAddr + 8),
                child: this.readWord(objAddr + 10),
                properties: this.readWord(objAddr + 12)
            };
        }
    }

    setObjectParent(objNum, parentNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 4;
            this.writeByte(objAddr, parentNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 6;
            this.writeWord(objAddr, parentNum);
        }
    }

    setObjectSibling(objNum, siblingNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 5;
            this.writeByte(objAddr, siblingNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 8;
            this.writeWord(objAddr, siblingNum);
        }
    }

    setObjectChild(objNum, childNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 6;
            this.writeByte(objAddr, childNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 10;
            this.writeWord(objAddr, childNum);
        }
    }

    testAttribute(objNum, attrNum) {
        if (objNum === 0) return false;

        // Read directly from memory to avoid 32-bit JavaScript bitwise limitations
        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
        }
        const byteNum = Math.floor(attrNum / 8);
        const bitNum = 7 - (attrNum % 8);
        const b = this.readByte(objAddr + byteNum);
        return !!(b & (1 << bitNum));
    }

    setAttribute(objNum, attrNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b | (1 << bitNum));
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b | (1 << bitNum));
        }
    }

    clearAttribute(objNum, attrNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b & ~(1 << bitNum));
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b & ~(1 << bitNum));
        }
    }

    // Room tracking for transcript
    getCurrentRoom() {
        // Method 1: Infocom convention - global 0 is the room
        const room = this.readWord(GLOBALS_ADDR);
        if (room > 0 && room < 1000) {  // Reasonable object number
            return room;
        }

        // Method 2: Inform convention - find player object and get parent
        // Player is usually object 1 in Inform games
        try {
            const player = this.getObject(1);
            if (player && player.parent > 0) {
                return player.parent;
            }
        } catch (e) {
            // Ignore errors
        }

        // Fallback: return 0 (unknown room)
        return 0;
    }

    // Output functions
    print(text) {
        // If printing to status window (window 1) and transcript is enabled,
        // append room number to the status line
        if (this.currentWindow === 1 && this.transcriptEnabled && text.includes('\n')) {
            const room = this.getCurrentRoom();
            if (room > 0) {
                // Insert room number before the newline
                text = text.replace(/\n/g, ` [Room ${room}]\n`);
                // Also update the statusLine object for external rendering
                this.statusLine.room = room;
            }
        }

        this.outputBuffer += text;
        if (this.outputCallback) {
            this.outputCallback(text);
        }
    }

    printNum(num) {
        // Handle signed 16-bit numbers
        if (num > 32767) {
            num = num - 65536;
        }
        this.print(num.toString());
    }

    printChar(charCode) {
        if (charCode === 13) {
            this.print("\n");
        } else {
            this.print(String.fromCharCode(charCode));
        }
    }

    newLine() {
        this.print("\n");
    }

    // Random number generation
    random(range) {
        // Handle as signed 16-bit
        if (range > 32767) range = range - 65536;

        if (range === 0) {
            // random(0): Reset to truly random mode
            this.randomMode = "random";
            return 0;
        }

        if (range < 0) {
            // random(negative): Seed the predictable generator
            this.randomSeed = -range;
            this.randomMode = "predictable";
            this.randomIndex = this.randomSeed;  // Seed IS the initial state
            return 0;
        }

        if (this.randomMode === "predictable") {
            // Linear congruential generator
            this.randomIndex = (this.randomIndex * 1103515245 + 12345) & 0x7FFFFFFF;
            return (this.randomIndex % range) + 1;
        } else {
            return Math.floor(Math.random() * range) + 1;
        }
    }

    // Game state
    save() {
        if (this.saveCallback) {
            const state = {
                memory: Array.from(this.memory.slice(0, STATIC_MEMORY)),
                stack: this.stack.slice(),
                callStack: this.callStack.map(frame => ({
                    returnPC: frame.returnPC,
                    locals: frame.locals.slice(),
                    numLocals: frame.numLocals,
                    storeVar: frame.storeVar
                })),
                pc: this.pc,
                locals: this.locals.slice()
            };
            return this.saveCallback(state);
        }
        return false;
    }

    restore(state) {
        if (state && state.memory) {
            // Restore dynamic memory
            for (let i = 0; i < state.memory.length; i++) {
                this.memory[i] = state.memory[i];
            }
            this.stack = state.stack.slice();
            this.callStack = state.callStack.map(frame => ({
                returnPC: frame.returnPC,
                locals: frame.locals.slice(),
                numLocals: frame.numLocals,
                storeVar: frame.storeVar
            }));
            this.pc = state.pc;
            this.locals = state.locals.slice();
            return true;
        }
        return false;
    }

    restart() {
        // Restore original memory
        this.memory = new Uint8Array(this.originalMemory);
        this.pc = INITIAL_PC;
        this.stack = [];
        this.callStack = [];
        this.locals = new Array(16);
        this.outputBuffer = "";
        this.running = true;
        this.finished = false;
    }

    quit() {
        this.running = false;
        this.finished = true;
        this.print("\n[Game terminated]\n");
    }

    // Transcript recording (zwalker-compatible format)
    enableTranscript() {
        this.transcriptEnabled = true;
        this.transcriptData = [];
        this.lastRoomNumber = this.getCurrentRoom();
        this.print("\n[Transcript recording enabled]\n");
    }

    disableTranscript() {
        this.transcriptEnabled = false;
        this.print("\n[Transcript recording disabled]\n");
    }

    getTranscript() {
        // Return transcript in zwalker-compatible JSON format
        const rooms = new Set();
        const commands = [];

        this.transcriptData.forEach(entry => {
            rooms.add(entry.from_room);
            rooms.add(entry.to_room);
            commands.push(entry.command);
        });

        return {
            game: "unknown",  // Will be filled in by caller
            solved: false,    // User can set this manually
            rooms_visited: Array.from(rooms).filter(r => r > 0),
            solution_commands: commands,
            full_solution_data: this.transcriptData,
            stats: {
                rooms_found: rooms.size,
                commands_tried: this.transcriptData.length
            }
        };
    }

    exportTranscript() {
        // Return transcript as JSON string
        return JSON.stringify(this.getTranscript(), null, 2);
    }

    // Object name lookup
    getObjectName(objNum) {
        const obj = this.getObject(objNum);
        if (!obj) return "";

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr++;

        if (textLength === 0) return "";

        return this.decodeZString(propAddr);
    }

    // Object tree manipulation
    insertObject(objNum, destNum) {
        if (objNum === 0) return;

        // Remove from current parent
        this.removeObject(objNum);

        // Insert as first child of destination
        const dest = this.getObject(destNum);
        if (dest) {
            this.setObjectSibling(objNum, dest.child);
            this.setObjectChild(destNum, objNum);
            this.setObjectParent(objNum, destNum);
        }
    }

    removeObject(objNum) {
        if (objNum === 0) return;

        const obj = this.getObject(objNum);
        if (!obj || obj.parent === 0) return;

        const parent = this.getObject(obj.parent);
        if (!parent) return;

        // Remove from sibling chain
        if (parent.child === objNum) {
            // Object is first child
            this.setObjectChild(obj.parent, obj.sibling);
        } else {
            // Find previous sibling
            let prevSibling = parent.child;
            while (prevSibling !== 0) {
                const prevObj = this.getObject(prevSibling);
                if (prevObj.sibling === objNum) {
                    this.setObjectSibling(prevSibling, obj.sibling);
                    break;
                }
                prevSibling = prevObj.sibling;
            }
        }

        this.setObjectParent(objNum, 0);
        this.setObjectSibling(objNum, 0);
    }

    // Property access
    getPropertyAddr(objNum, propNum) {
        if (objNum === 0) return 0;

        const obj = this.getObject(objNum);
        if (!obj) return 0;

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr += 1 + textLength * 2;

        // Search for property
        while (propAddr < this.memory.length) {
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) break;

            let num, size, dataOffset;
            if (VERSION <= 3) {
                // V1-3: Property number in bits 4-0, size in bits 7-5
                num = sizeByte & 0x1F;
                size = (sizeByte >> 5) + 1;
                dataOffset = 1;
            } else {
                // V4+: Property number in bits 5-0
                num = sizeByte & 0x3F;
                if (sizeByte & 0x80) {
                    // Two-byte size: second byte bits 5-0 = size (0 means 64)
                    const sizeByte2 = this.readByte(propAddr + 1);
                    size = sizeByte2 & 0x3F;
                    if (size === 0) size = 64;
                    dataOffset = 2;
                } else {
                    // One-byte size: bit 6 set = 2 bytes, clear = 1 byte
                    size = (sizeByte & 0x40) ? 2 : 1;
                    dataOffset = 1;
                }
            }

            if (num === propNum) {
                return propAddr + dataOffset;
            }

            propAddr += dataOffset + size;
        }

        return 0;
    }

    getPropertySize(propAddr) {
        // Get the size of a property given the address of its DATA (after size byte(s))
        // We need to look at the byte(s) before propAddr
        if (VERSION <= 3) {
            const sizeByte = this.readByte(propAddr - 1);
            return (sizeByte >> 5) + 1;
        } else {
            // V4+: Could be 1 or 2 size bytes before the data
            const prevByte = this.readByte(propAddr - 1);
            if (prevByte & 0x80) {
                // This is a second size byte
                const size = prevByte & 0x3F;
                return size === 0 ? 64 : size;
            } else {
                // This is a single size byte
                return (prevByte & 0x40) ? 2 : 1;
            }
        }
    }

    getProperty(objNum, propNum) {
        const propAddr = this.getPropertyAddr(objNum, propNum);
        if (propAddr === 0) {
            // Return default property value
            const defaultAddr = OBJECT_TABLE_ADDR + (propNum - 1) * 2;
            return this.readWord(defaultAddr);
        }

        const size = this.getPropertySize(propAddr);

        if (size === 1) {
            return this.readByte(propAddr);
        } else {
            return this.readWord(propAddr);
        }
    }

    putProperty(objNum, propNum, value) {
        const propAddr = this.getPropertyAddr(objNum, propNum);
        if (propAddr === 0) return;

        const size = this.getPropertySize(propAddr);

        if (size === 1) {
            this.writeByte(propAddr, value);
        } else {
            this.writeWord(propAddr, value);
        }
    }

    getNextProperty(objNum, propNum) {
        if (objNum === 0) return 0;

        const obj = this.getObject(objNum);
        if (!obj) return 0;

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr += 1 + textLength * 2;

        if (propNum === 0) {
            // Return first property
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) return 0;
            return VERSION <= 3 ? (sizeByte & 0x1F) : (sizeByte & 0x3F);
        }

        // Search for property
        while (propAddr < this.memory.length) {
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) break;

            let num, size, dataOffset;
            if (VERSION <= 3) {
                num = sizeByte & 0x1F;
                size = (sizeByte >> 5) + 1;
                dataOffset = 1;
            } else {
                num = sizeByte & 0x3F;
                if (sizeByte & 0x80) {
                    const sizeByte2 = this.readByte(propAddr + 1);
                    size = sizeByte2 & 0x3F;
                    if (size === 0) size = 64;
                    dataOffset = 2;
                } else {
                    size = (sizeByte & 0x40) ? 2 : 1;
                    dataOffset = 1;
                }
            }

            if (num === propNum) {
                // Found current property, return next
                propAddr += dataOffset + size;
                const nextSizeByte = this.readByte(propAddr);
                if (nextSizeByte === 0) return 0;
                return VERSION <= 3 ? (nextSizeByte & 0x1F) : (nextSizeByte & 0x3F);
            }

            propAddr += dataOffset + size;
        }

        return 0;
    }

    // Table scanning
    scanTable(value, tableAddr, length, form) {
        const fieldSize = form & 0x7F;
        const isWord = !(form & 0x80);

        for (let i = 0; i < length; i++) {
            const entryAddr = tableAddr + i * fieldSize;
            const entryValue = isWord ? this.readWord(entryAddr) : this.readByte(entryAddr);

            if (entryValue === value) {
                return entryAddr;
            }
        }

        return 0;
    }

    // Input handling
    read(textBuffer, parseBuffer, storeVar) {
        if (this.debugMode) {
            console.error(`[READ] textBuffer=0x${textBuffer.toString(16)}, parseBuffer=0x${parseBuffer.toString(16)}, storeVar=${storeVar}`);
        }

        this.running = false;

        // Set up the input handler - will be called when input arrives
        const self = this;
        this.inputCallback = function(input) {
            if (self.debugMode) {
                console.error(`[INPUT] Received: "${input}"`);
            }

            // Record room before command for transcript
            const roomBefore = self.transcriptEnabled ? self.getCurrentRoom() : null;

            // Store input in text buffer
            const maxLen = self.readByte(textBuffer);
            const actualLen = Math.min(input.length, maxLen);

            if (VERSION <= 4) {
                for (let i = 0; i < actualLen; i++) {
                    self.writeByte(textBuffer + 1 + i, input.toLowerCase().charCodeAt(i));
                }
                self.writeByte(textBuffer + 1 + actualLen, 0);
            } else {
                self.writeByte(textBuffer + 1, actualLen);
                for (let i = 0; i < actualLen; i++) {
                    self.writeByte(textBuffer + 2 + i, input.toLowerCase().charCodeAt(i));
                }
            }

            // Tokenize if parse buffer provided
            if (parseBuffer && parseBuffer !== 0) {
                self.tokenize(textBuffer, parseBuffer);
            }

            // For V5+, store the terminating character (13 = Enter/newline)
            if (storeVar !== null) {
                self.setVariable(storeVar, 13);
            }

            // Record transcript data after command is processed
            if (self.transcriptEnabled) {
                // Use a short delay to let the game process the command first
                setTimeout(() => {
                    const roomAfter = self.getCurrentRoom();
                    self.transcriptData.push({
                        command: input.toUpperCase(),
                        from_room: roomBefore,
                        to_room: roomAfter,
                        result: roomBefore !== roomAfter ? "moved" : "boring"
                    });
                    self.lastCommand = input.toUpperCase();
                    self.lastRoomNumber = roomAfter;
                }, 10);
            }

            // Clear the callback and continue execution
            self.inputCallback = null;
            self.running = true;
            setTimeout(() => self.run(), 0);
        };
    }

    // Dictionary and tokenization
    tokenize(textBuffer, parseBuffer) {
        // DEBUG: Dump parse buffer BEFORE tokenization
        if (this.debugMode) {
            console.error(`[TOKENIZE] Parse buffer BEFORE (at 0x${parseBuffer.toString(16)}):`);
            console.error(`[TOKENIZE] Text buffer at 0x${textBuffer.toString(16)}`);

            // Show what's currently in the parse buffer
            for (let i = 0; i < 3; i++) {
                const entryAddr = parseBuffer + 2 + i * 4;
                const addr = this.readWord(entryAddr);
                const len = this.readByte(entryAddr + 2);
                const pos = this.readByte(entryAddr + 3);
                console.error(`[TOKENIZE]   Entry ${i}: addr=0x${addr.toString(16)}, len=${len}, pos=${pos}`);
            }
        }

        // Simplified tokenization
        let text;
        if (VERSION <= 4) {
            text = "";
            let addr = textBuffer + 1;
            let ch = this.readByte(addr);
            while (ch !== 0) {
                text += String.fromCharCode(ch);
                addr++;
                ch = this.readByte(addr);
            }
        } else {
            const len = this.readByte(textBuffer + 1);
            text = "";
            for (let i = 0; i < len; i++) {
                text += String.fromCharCode(this.readByte(textBuffer + 2 + i));
            }
        }

        // Split into words
        const words = text.trim().split(/\s+/).filter(w => w.length > 0);
        const maxWords = this.readByte(parseBuffer);

        // Write number of words parsed
        this.writeByte(parseBuffer + 1, Math.min(words.length, maxWords));

        // Write each word entry
        let textPos = 0;  // Track position in original text
        for (let i = 0; i < Math.min(words.length, maxWords); i++) {
            const word = words[i];
            const dictAddr = this.lookupWord(word);

            if (this.debugMode) {
                console.error(`[TOKENIZE] Word ${i}: "${word}" -> dictAddr=0x${dictAddr.toString(16)}`);
            }

            // Find word position in text (1-indexed)
            const wordStart = text.indexOf(word, textPos);
            const position = wordStart + 1;  // 1-indexed position in text
            textPos = wordStart + word.length;

            // Write word entry: dict-addr (2 bytes), length (1 byte), position (1 byte)
            const entryAddr = parseBuffer + 2 + i * 4;
            this.writeWord(entryAddr, dictAddr);
            this.writeByte(entryAddr + 2, word.length);
            this.writeByte(entryAddr + 3, position);

            if (this.debugMode) {
                console.error(`[TOKENIZE]   Wrote to 0x${entryAddr.toString(16)}: addr=0x${dictAddr.toString(16)}, len=${word.length}, pos=${position}`);
            }
        }

        // DEBUG: Dump parse buffer contents
        if (this.debugMode) {
            console.error(`[TOKENIZE] Parse buffer dump (buffer starts at 0x${parseBuffer.toString(16)}):`);
            console.error(`[TOKENIZE]   Max words: ${this.readByte(parseBuffer)}`);
            console.error(`[TOKENIZE]   Num words: ${this.readByte(parseBuffer + 1)}`);
            const numWords = this.readByte(parseBuffer + 1);
            for (let i = 0; i < Math.max(numWords, 3); i++) {  // Show at least 3 entries
                const entryAddr = parseBuffer + 2 + i * 4;
                const addr = this.readWord(entryAddr);
                const len = this.readByte(entryAddr + 2);
                const pos = this.readByte(entryAddr + 3);
                console.error(`[TOKENIZE]   Entry ${i} at 0x${entryAddr.toString(16)}: addr=0x${addr.toString(16)}, len=${len}, pos=${pos}`);
            }
        }
    }

    lookupWord(word) {
        // Simplified dictionary lookup
        // Returns 0 if word not found
        const dict = DICTIONARY_ADDR;
        const numSeparators = this.readByte(dict);
        let addr = dict + 1 + numSeparators;

        const entryLength = this.readByte(addr);
        addr++;
        const numEntries = this.readWord(addr);
        addr += 2;

        // Encode the word using Z-string encoding
        const encoded = this.encodeWord(word);

        // Linear search through dictionary
        for (let i = 0; i < numEntries; i++) {
            const entryAddr = addr + i * entryLength;
            let match = true;

            for (let j = 0; j < Math.min(encoded.length, VERSION <= 3 ? 4 : 6); j++) {
                if (this.readByte(entryAddr + j) !== encoded[j]) {
                    match = false;
                    break;
                }
            }

            if (match) return entryAddr;
        }

        return 0;
    }

    encodeWord(word) {
        // Z-string encoding for dictionary words
        // V1-3 use 4 bytes (2 Z-chars per byte, 6 chars total)
        // V4+ use 6 bytes (9 chars total)
        const maxChars = VERSION <= 3 ? 6 : 9;
        const maxBytes = VERSION <= 3 ? 4 : 6;

        const alphabet = "abcdefghijklmnopqrstuvwxyz";
        const zchars = [];

        for (let i = 0; i < maxChars; i++) {
            if (i < word.length) {
                const ch = word[i].toLowerCase();
                const idx = alphabet.indexOf(ch);
                if (idx >= 0) {
                    zchars.push(idx + 6);  // A0 alphabet starts at 6
                } else {
                    zchars.push(5);  // Default to space character
                }
            } else {
                zchars.push(5);  // Pad with spaces
            }
        }

        // Pack Z-chars into bytes (3 Z-chars per 2-byte word)
        const bytes = [];
        for (let wordIdx = 0; wordIdx < maxBytes / 2; wordIdx++) {
            const z1 = zchars[wordIdx * 3] || 5;
            const z2 = zchars[wordIdx * 3 + 1] || 5;
            const z3 = zchars[wordIdx * 3 + 2] || 5;

            let word = (z1 << 10) | (z2 << 5) | z3;

            // Set top bit on last word only
            if (wordIdx === (maxBytes / 2) - 1) {
                word |= 0x8000;
            }

            bytes.push((word >> 8) & 0xFF);
            bytes.push(word & 0xFF);
        }

        return bytes;
    }
}

// Story Data (Base64 encoded)
const STORY_DATA_BASE64 = [
    "BQAAAgX0BfUF7AECAuAF6gBQOTcwMzI1AEIQH7YdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAANi4xMYAAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAg",
    "ACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAA",
    "IAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAg",
    "ACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbgA",
    "AAAAAAAAAAAAAAABwgAAAAAAAAAAAAAAAAHOAAAAAAAAAAAAAAAAAdoCERGbGABCAAEAAxKHPUjk",
    "pQBCAAIAAxL0ay7NRQBCAAMAAxMZXdOwpQBCAAQAAAEAAgADAAQAAABIEBEAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBIQ",
    "ExAVEBcQGRAaEBsQHA8hDyYPKw8wDzUPOg8/D0QPSQ9OD1MPWA9dD2IPZw9sD3EPdg97D4APhQ+K",
    "D48PlA+ZD54Pow+oD60Psg+3D7wPwQ/GD8sP0A/VD9oP3w/kD+kP7g/zD/gP/RACEAcQDAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAA3lDeYN5w3oDekN6g3sDe0N7w3wAEUOEA4TDhYOGQ4cDh8OIg4l",
    "DikOLQ4wDjMONg45DjwOPw5CDkUOSA5LDk4OUQ5UDlcOWg5dDmAOYw5mDmkObA5vDnIOdQ54DnsO",
    "fg6CDoYOig6ODpIOlg6aDp4Oog6mDqkOrA6vDrIOtQ64DrsOvg7BDsQOxw7LDs4O0Q7TDtUO1w7Z",
    "Dt0O4A7kDucAHA7qDMUO7A1JDvEBfw71ArQO9wJTDvoEAw8BBLwPBgbbDwkGhw8MBw4PEAgLDxQJ",
    "ZQ8ZCf8PHAvdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMuLCIJAAAAAOA/DEj/ugACEDIAARAy",
    "AQKgAQBGoAIAQrIT1GrgOnkq9V1ZKuAmimATUyAiJjpAZoAukUacANN4FRr5ORpE1wNqXw5SYFFg",
    "ZaoAnxeEYqogshTlnKWMADuyE9Rq4Dp5KvVdWSrgIiY6WAM0AXRGNHAXK25h1MwF5r8BspZF5r8C",
    "sgKLAy0oBHy8ExUpBUinlOUQAAEBSQEBAKAAgCyyEdNlV1bqZVcBERnSYBk02QEURpcpIGVdZAQ4",
    "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",
    "SReUayBlWGS9AIYlKiQGHdE7PgM0AS5isRvAIaZcyGVXYA5MB1IpFmBqaSrxOmoWYBppAW51SRec",
    "OTk0GGfRKwXIp7IQyCFTZUkXlGsgZVhkvQCTUyokGTTZAKYHxRg+ANMkBRg8FMFwBl1FTA5MCxkZ",
    "FmBlWGVJARRe6iMxeLKU5bIRjm1TF5kruQMqYyV0BDslYwBlqgGGSUAt0Si4YA9Q4GaAVu5PIGWq",
    "AY5tUwMqdyAdS1LqAdkBBkY4AKYIFyjJFkARbnVJAypjIGaAJoBlrmCylOWyEy5JSReYZu5NgGVY",
    "ZL0AiDTTMUkDKmMgZoAmgB6ZNAVl023YOPEouQDTJAVnbmHHRUVkDk8qXvpXOAC+UnF4FE1AOnkq",
    "92q5AdMDLV1KAMhnRkY+Arc6eWAZK7kWRfynshTgAARqqFJOTYATKmMgEWobOl1YF6WcpbISLmMg",
    "UWBlV0nTGy5NgCGmXMhlV2CnEXRPOBTkYzco0gCrAmpjLk2FnKWyFOAABCLqJdlgvZTlshMuZioX",
    "oBH0TAQtV16FnKWyExUpABDOJL0AjFzNGkVMBGCPFmASpCSJFmAaaQMtKBcrGQKLAy0oCF6cpKew",
    "Ey07ABsVKRkCiwPUauA6eSr1XVkq4Bq1KNdgGVAHKaZtQBkIUuk6bAM0AxUpBcinEy07ABsVKRkC",
    "iwPUauA6eSr1XVkq4Bq1KNdgGVAHKaZtQBOEXJQSZDCylOWUpQAAlKUAABDxmRAS6qSlEZepUxPK",
    "RjTwpQAAEPHpRRJGMVPkxQAAER6aZRONuyoVJSwFGCqArRUlLAUYKgC8laUAABeFJKsApgVAlaUA",
    "ABeFJKsApgVAF4W0pRUlLAVoBbSlFSUsBWgF8K0XhSSrALqArReFJKsAugC8laUAABUlLAUYJYCt",
    "FSUsBRglALyVpQAAF4UkqwCmBKCVpQAAF4UkqwCmBKAXhbSlGLxqURtZF6WYmwAAULxqURtZF6WY",
    "nAAAaLxqURtZF6WYnQAAEMVzUkTaZL0UxPilEoVzUkTaZL0UxPylE0VzUkTaZL0UxYClY+VyLjDZ",
    "auoXpZihFMF4pgfFctpTKmC9FMWIpRTBcKYHhXLaUypgvRTFjKUovGpRG1kXpZikAAA4vGpRG1kX",
    "pZilAAB4vGpRG1kXpZimAAARRXNSRNpkvRTFnKURxXNSRNpkvRTFoKUYvBkaZUV0ppUlAAAovBka",
    "ZUV0ppVFAAA4vBkaZUV0ppVlAABQvBkaZUV0ppWFAABovBkaZUV0ppWlAAB4vBkaZUV0ppXFAAAQ",
    "xXDIayoXpZivAAARRXDIayoXpZiwAAARxXDIayoXpZixAAAShXDIayoXpZiyAAATRXDIayoXpZiz",
    "AAATxXDIayoXpZi0AAAYvDLmbUV0ppalAAAovDLmbUV0ppbFAAA4vDLmbUV0ppblAABQvDLmbUV0",
    "ppcFAABovDLmbUV0ppclAAAQxXGXG2oXpZi6AAARRXGXG2oXpZi7AAARxXGXG2oXpZi8AAAShXGX",
    "G2oXpZi9AAATRXGXG2oXpZi+AAAYvCHXI1IuKnS9FMX8pQAAKLwh1yNSLip0vRTGgKUAADi8Idcj",
    "Ui4qdL0UxoSlAABQvCHXI1IuKnS9FMaIpQAAaLwh1yNSLip0vRTGjKUAABDFcQ5dGklxK6V0ppiF",
    "AAARRXEOXRpJcSuldKaYpQAAEcVxDl0aSXErpXSmmMUAABKFcQ5dGklxK6V0ppjlAAATRXEOXRpJ",
    "cSuldKaZBQAAGLxd0zC9FMakpQAAEMVy7k2FdKaZRQAAULxiJmGldKaZZQAAEoVzERsNF6WYzAAA",
    "GLxl0SVFdKaZpQAATLxl0SVFdKaZxQAAULxl0SVFdKaZ5QAAEMVzLkUqF6WY0AAAEmVzLkUqF6WY",
    "0QAAEoVzLkUqF6WY0gAAGUVyLjDZauoXpZjTEMQovEXMGzpdRXSmmoUAACC8IUk6MRi9FMbUpREF",
    "cQol0UTFdKaaxWW0XmV0pprlKy0XpZjYAAATLVLzF6WY2RFZNL0UxuilVppNJXMeSPREvRTG7KUA",
    "AFFFci4w2WrqF6WY3BKEKLxFzBs6XUV0ppulAAA6eyr4KLwWhXSmm8U6eyr4KLwWpXSmm+UTal8O",
    "0mUAABLqIVNkCDTTMVgDNACZKvURWekqEaoZKlwLRMxgBkzRew7gpRMZeiokGau5ERRGlykgZV3k",
    "pQAAElpHLlYuINk6kxZgJds7DlJlTBcqRjppquUAABDIIVNlSQENGuYjKlwUazXrJQAAEw5NkSi8",
    "QV4B09dZEXpGJXIuTUA6deslEy5JSQMOTZEovEFeAdPXWRMuSUkBekYlci5NQDp16yUStyi8RoYl",
    "0zAULA5OumQRumoAABNTJoAg1RjuRdn4pRK3Onk6bADqLpcoFmnZZdOwpQAAFMFzU0J0cmAbOV3H",
    "ayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAb",
    "OV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0",
    "cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFz",
    "U0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAA",
    "FMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4",
    "pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sq",
    "FMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzld",
    "x2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NCdHJg",
    "Gzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTBc1NC",
    "dHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUAABTB",
    "c1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB+KUA",
    "ABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5XcdrKhTB",
    "+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5Xcdr",
    "KhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRyYBs5",
    "XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNTQnRy",
    "YBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAAFMFzU0J0cmAbOV3HayoUwfilAAAUwXNT",
    "QnRyYBs5XcdrKhTB+KUAABTBc1NCdHJgGzldx2sqFMH4pQAATNKopSLqmypdSF1G5UUAACVYZvT4",
    "pQAAXVIZ07psAAAilfilINHEpVbuzyVW7k8lWzQWxl7m+KUAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
].join("");

// Decode base64 to Uint8Array
function decodeStoryData() {
    if (typeof atob !== "undefined") {
        // Browser
        const binary = atob(STORY_DATA_BASE64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    } else {
        // Node.js
        return new Uint8Array(Buffer.from(STORY_DATA_BASE64, "base64"));
    }
}

// Opcode Implementations
ZMachine.prototype.executeInstruction = function() {
    const instrPC = this.pc;
    const opcode = this.readByte(this.pc);
    this.pc++;

    // Add comprehensive debug logging matching frotz output format
    if (this.debugMode) {
        // Get local variables from current frame
        const l1 = this.locals[0] || 0;
        const l2 = this.locals[1] || 0;
        const l3 = this.locals[2] || 0;
        const l4 = this.locals[3] || 0;
        const l5 = this.locals[4] || 0;

        console.error(`[STEP ${this.instructionCount}] PC=0x${instrPC.toString(16).padStart(4, '0')} Op=0x${opcode.toString(16).padStart(2, '0')} L1=0x${l1.toString(16).padStart(4, '0')} L2=0x${l2.toString(16).padStart(4, '0')} L3=0x${l3.toString(16).padStart(4, '0')} L4=0x${l4.toString(16).padStart(4, '0')} L5=0x${l5.toString(16).padStart(4, '0')}`);
    }

    // Decode instruction form
    if (opcode === 0xBE && VERSION >= 5) {
        return this.executeExtended();
    } else if ((opcode & 0xC0) === 0xC0) {
        // Variable form
        if (opcode < 0xE0) {
            return this.execute2OPVar(opcode & 0x1F);
        } else {
            return this.executeVAR(opcode & 0x1F);
        }
    } else if ((opcode & 0x80) === 0x80) {
        // Short form
        const operandType = (opcode >> 4) & 0x03;
        const opcodeNum = opcode & 0x0F;

        if (operandType === 0x03) {
            return this.execute0OP(opcodeNum);
        } else {
            let operand;
            if (operandType === 0x00) {
                operand = this.readWord(this.pc);
                this.pc += 2;
            } else if (operandType === 0x01) {
                operand = this.readByte(this.pc);
                this.pc++;
            } else {
                operand = ["var", this.readByte(this.pc)];
                this.pc++;
            }
            return this.execute1OP(opcodeNum, operand);
        }
    } else {
        // Long form
        const opcodeNum = opcode & 0x1F;
        const op1 = (opcode & 0x40) ? ["var", this.readByte(this.pc)] : this.readByte(this.pc);
        this.pc++;
        const op2 = (opcode & 0x20) ? ["var", this.readByte(this.pc)] : this.readByte(this.pc);
        this.pc++;
        return this.execute2OP(opcodeNum, op1, op2);
    }
};

// 0OP Instructions
ZMachine.prototype.execute0OP = function(opcode) {
    switch (opcode) {
        case 0x00: // rtrue
            this.returnFromRoutine(1);
            break;
        case 0x01: // rfalse
            this.returnFromRoutine(0);
            break;
        case 0x02: // print
            this.printLiteral();
            break;
        case 0x03: // print_ret
            this.printLiteral();
            this.newLine();
            this.returnFromRoutine(1);
            break;
        case 0x08: // ret_popped
            {
                const value = this.pop();
                this.returnFromRoutine(value);
            }
            break;
        case 0x09: // pop (discard top of stack)
            this.pop();
            break;
        case 0x0A: // quit
            this.quit();
            break;
        case 0x0B: // new_line
            this.newLine();
            break;
        case 0x0C: // show_status (V3 only)
            // In V3, this updates the status line at the top of the screen
            // We just no-op this since we don't have a proper status line implementation
            // Games call this frequently but it's not critical for gameplay
            break;
        case 0x0D: // verify
            this.branch(true); // Always succeed for now
            break;
        default:
            throw new Error(`Unimplemented 0OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 1OP Instructions
ZMachine.prototype.execute1OP = function(opcode, operand) {
    const value = this.getOperand(operand);

    switch (opcode) {
        case 0x00: // jz
            this.branch(value === 0);
            break;
        case 0x01: // get_sibling
            {
                const obj = this.getObject(value);
                const sibling = obj ? obj.sibling : 0;
                this.store(sibling);
                this.branch(sibling !== 0);
            }
            break;
        case 0x02: // get_child
            {
                const obj = this.getObject(value);
                const child = obj ? obj.child : 0;
                this.store(child);
                this.branch(child !== 0);
            }
            break;
        case 0x03: // get_parent
            {
                const obj = this.getObject(value);
                this.store(obj ? obj.parent : 0);
            }
            break;
        case 0x04: // get_prop_len
            {
                const propAddr = value;
                if (propAddr === 0) {
                    this.store(0);
                } else {
                    // Use the shared getPropertySize function
                    this.store(this.getPropertySize(propAddr));
                }
            }
            break;
        case 0x05: // inc
            {
                const varNum = value;
                const val = this.getVariable(varNum);
                this.setVariable(varNum, val + 1);
            }
            break;
        case 0x06: // dec
            {
                const varNum = value;
                const val = this.getVariable(varNum);
                this.setVariable(varNum, val - 1);
            }
            break;
        case 0x07: // print_addr
            {
                const addr = value;
                const text = this.decodeZString(addr);
                this.print(text);
            }
            break;
        case 0x08: // call_1s (V4+)
            if (VERSION >= 4) {
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(value, [], storeVar);
            }
            break;
        case 0x09: // remove_obj
            {
                const objNum = value;
                const obj = this.getObject(objNum);
                if (obj && obj.parent) {
                    const parent = this.getObject(obj.parent);
                    if (parent) {
                        // Remove from parent's child list
                        if (parent.child === objNum) {
                            this.setObjectChild(obj.parent, obj.sibling);
                        } else {
                            // Find in sibling chain
                            let prev = parent.child;
                            while (prev) {
                                const prevObj = this.getObject(prev);
                                if (prevObj && prevObj.sibling === objNum) {
                                    this.setObjectSibling(prev, obj.sibling);
                                    break;
                                }
                                prev = prevObj ? prevObj.sibling : 0;
                            }
                        }
                    }
                    this.setObjectParent(objNum, 0);
                    this.setObjectSibling(objNum, 0);
                }
            }
            break;
        case 0x0A: // print_obj
            {
                const name = this.getObjectName(value);
                this.print(name);
            }
            break;
        case 0x0B: // ret
            this.returnFromRoutine(value);
            break;
        case 0x0C: // jump
            {
                // Sign extend 16-bit value
                let offset = value;
                if (offset > 32767) offset -= 65536;
                this.pc += offset - 2;
            }
            break;
        case 0x0D: // print_paddr - packed string address
            {
                // This is a packed STRING address, so pass isString=true for V6/V7
                const addr = this.unpackAddress(value, true);
                const text = this.decodeZString(addr);
                this.print(text);
            }
            break;
        case 0x0E: // load
            {
                const varNum = value;
                if (this.debugMode && this.instructionCount < 20) {
                    console.error(`  LOAD from var ${varNum} (stack size: ${this.stack.length})`);
                }
                // When loading from sp (var 0) indirectly, peek instead of pop
                const val = (varNum === 0) ? this.peek() : this.getVariable(varNum);
                this.store(val);
            }
            break;
        case 0x0F: // not (V4) / call_1n (V5+)
            if (VERSION >= 5) {
                // call_1n
                this.callRoutine(value, [], null);
            } else if (VERSION >= 4) {
                // not (bitwise complement)
                this.store(~value & 0xFFFF);
            }
            break;
        default:
            throw new Error(`Unimplemented 1OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 2OP Instructions (Long form)
ZMachine.prototype.execute2OP = function(opcode, operand1, operand2) {
    const val1 = this.getOperand(operand1);
    const val2 = this.getOperand(operand2);

    switch (opcode) {
        case 0x00: // Illegal opcode - reserved
            // This should never be encountered in valid Z-code
            // If we hit this, something is very wrong with our implementation
            throw new Error(`Illegal 2OP opcode 0x00 encountered at PC 0x${(this.pc - 3).toString(16)} - this indicates a serious bug in instruction decoding or PC management`);
        case 0x01: // je (jump if equal)
            this.branch(val1 === val2);
            break;
        case 0x02: // jl (jump if less than - signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(a < b);
            }
            break;
        case 0x03: // jg (jump if greater than - signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(a > b);
            }
            break;
        case 0x04: // dec_chk
            {
                const varNum = val1;
                const currentVal = this.getVariable(varNum);
                const newVal = (currentVal - 1) & 0xFFFF;
                this.setVariable(varNum, newVal);
                const signedNew = newVal > 32767 ? newVal - 65536 : newVal;
                const signedCheck = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(signedNew < signedCheck);
            }
            break;
        case 0x05: // inc_chk
            {
                const varNum = val1;
                const currentVal = this.getVariable(varNum);
                const newVal = (currentVal + 1) & 0xFFFF;
                this.setVariable(varNum, newVal);
                const signedNew = newVal > 32767 ? newVal - 65536 : newVal;
                const signedCheck = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(signedNew > signedCheck);
            }
            break;
        case 0x06: // jin (jump if object is in another object)
            {
                const obj1 = this.getObject(val1);
                this.branch(obj1 && obj1.parent === val2);
            }
            break;
        case 0x07: // test (test bitmap)
            this.branch((val1 & val2) === val2);
            break;
        case 0x08: // or
            this.store(val1 | val2);
            break;
        case 0x09: // and
            this.store(val1 & val2);
            break;
        case 0x0A: // test_attr
            this.branch(this.testAttribute(val1, val2));
            break;
        case 0x0B: // set_attr
            this.setAttribute(val1, val2);
            break;
        case 0x0C: // clear_attr
            this.clearAttribute(val1, val2);
            break;
        case 0x0D: // store (variable)
            // When storing to sp (var 0) indirectly, replace top instead of push
            if (val1 === 0) {
                this.pop();  // Remove current top
                this.push(val2);  // Push new value
            } else {
                this.setVariable(val1, val2);
            }
            break;
        case 0x0E: // insert_obj
            this.insertObject(val1, val2);
            break;
        case 0x0F: // loadw (load word from array)
            {
                const addr = val1 + 2 * val2;
                this.store(this.readWord(addr));
            }
            break;
        case 0x10: // loadb (load byte from array)
            {
                const addr = val1 + val2;
                this.store(this.readByte(addr));
            }
            break;
        case 0x11: // get_prop
            this.store(this.getProperty(val1, val2));
            break;
        case 0x12: // get_prop_addr
            this.store(this.getPropertyAddr(val1, val2));
            break;
        case 0x13: // get_next_prop
            this.store(this.getNextProperty(val1, val2));
            break;
        case 0x14: // add (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a + b;
                if (result < -32768) result += 65536;
                if (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x15: // sub (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a - b;
                if (result < -32768) result += 65536;
                if (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x16: // mul (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a * b;
                while (result < -32768) result += 65536;
                while (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x17: // div (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                if (b === 0) throw new Error("Division by zero");
                const result = Math.trunc(a / b);
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x18: // mod (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                if (b === 0) throw new Error("Division by zero");
                const result = a % b;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x19: // call_2s (V4+)
            if (VERSION >= 4) {
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(val1, [val2], storeVar);
            }
            break;
        case 0x1A: // call_2n (V5+)
            if (VERSION >= 5) {
                this.callRoutine(val1, [val2], null);
            }
            break;
        case 0x1B: // set_colour (V5+)
            // Not implemented - no-op
            break;
        case 0x1C: // throw (V5+)
            // Not implemented
            break;
        default:
            throw new Error(`Unimplemented 2OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 2OP Instructions (Variable form) - reads operands and redirects to execute2OP
// Note: Some 2OP instructions like 'je' can take more than 2 operands in variable form!
ZMachine.prototype.execute2OPVar = function(opcode) {
    // Read operand types
    const types = this.readByte(this.pc);
    this.pc++;

    const operands = [];
    // Read up to 4 operands (je and some others can use all 4)
    for (let i = 0; i < 4; i++) {
        const opType = (types >> (6 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // For je opcode (0x01), handle multiple operands specially
    if (opcode === 0x01 && operands.length > 2) {
        // je with more than 2 operands: check if first equals any of the rest
        const val1 = this.getOperand(operands[0]);
        let result = false;
        for (let i = 1; i < operands.length; i++) {
            if (val1 === this.getOperand(operands[i])) {
                result = true;
                break;
            }
        }
        this.branch(result);
        return;
    }

    // For other 2OP instructions, just use first 2 operands
    return this.execute2OP(opcode, operands[0], operands[1]);
};

// VAR Instructions
ZMachine.prototype.executeVAR = function(opcode) {
    // Double-VAR opcodes (call_vs2 = 0x0C, call_vn2 = 0x1A) use 2 types bytes for up to 8 operands
    const isDoubleVar = (opcode === 0x0C || opcode === 0x1A);

    // Read operand types (1 or 2 bytes depending on opcode)
    let types;
    let maxOperands;
    if (isDoubleVar) {
        types = (this.readByte(this.pc) << 8) | this.readByte(this.pc + 1);
        this.pc += 2;
        maxOperands = 8;
    } else {
        types = this.readByte(this.pc) << 8;  // Shift to high byte for consistent handling
        this.pc++;
        maxOperands = 4;
    }

    const operands = [];
    for (let i = 0; i < maxOperands; i++) {
        const opType = (types >> (14 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // Get actual values
    const values = operands.map(op => this.getOperand(op));

    if (this.debugMode && this.instructionCount < 20 && (opcode === 0x00 || opcode === 0x01)) {
        console.error(`  -> VAR operand types: 0x${types.toString(16)}, operands:`, operands, 'values:', values);
    }

    switch (opcode) {
        case 0x00: // call (call routine with 0-3 args)
            {
                const packedAddr = values[0];
                const args = values.slice(1);
                const storeVar = this.readByte(this.pc);
                this.pc++;
                if (this.debugMode && this.instructionCount < 20) {
                    console.error(`  CALL routine 0x${packedAddr.toString(16)} with args [${args.map(a => '0x' + a.toString(16)).join(', ')}] store to var ${storeVar}`);
                }
                this.callRoutine(packedAddr, args, storeVar);
            }
            break;
        case 0x01: // storew
            this.writeWord(values[0] + 2 * values[1], values[2]);
            break;
        case 0x02: // storeb
            {
                const addr = values[0] + values[1];
                this.writeByte(addr, values[2]);
            }
            break;
        case 0x03: // put_prop
            this.putProperty(values[0], values[1], values[2]);
            break;
        case 0x04: // read (sread V1-4, aread V5+)
            if (this.debugMode) {
                console.error(`[VAR 0x04 READ] Called with values[0]=0x${values[0].toString(16)}, values[1]=0x${values[1].toString(16)}`);
            }
            if (VERSION >= 5) {
                // V5+: aread has a store byte
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.read(values[0], values[1], storeVar);
            } else {
                // V1-4: sread has no store byte
                this.read(values[0], values[1], null);
            }
            break;
        case 0x05: // print_char
            this.printChar(values[0]);
            break;
        case 0x06: // print_num
            this.printNum(values[0]);
            break;
        case 0x07: // random
            {
                const result = this.random(values[0]);
                this.store(result);
            }
            break;
        case 0x08: // push
            this.push(values[0]);
            break;
        case 0x09: // pull - version-specific behavior!
            // V1-5, V8: pull (variable) - operand is target variable number, no store byte
            // V6-7: pull stack -> (result) - has store byte, operand defaults to user stack
            if (VERSION === 6 || VERSION === 7) {
                // V6/V7: Pop from user stack (if specified) or evaluation stack
                // The operand (if provided) is a user stack address, result goes to store variable
                // For now, we just pop from evaluation stack like other versions
                const value = this.pop();
                this.store(value);
            } else {
                // V1-5, V8: Pop and store in variable specified by operand
                const value = this.pop();
                // When pulling to sp (var 0) indirectly, replace top instead of push
                if (values[0] === 0) {
                    this.pop();  // Remove current top
                    this.push(value);  // Push the pulled value
                } else {
                    this.setVariable(values[0], value);
                }
            }
            break;
        case 0x0A: // split_window (V3+)
            // Not implemented - no-op
            break;
        case 0x0B: // set_window (V3+)
            this.currentWindow = values[0];
            break;
        case 0x0C: // call_vs2 (V4+)
            if (VERSION >= 4) {
                const packedAddr = values[0];
                const args = values.slice(1);
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(packedAddr, args, storeVar);
            }
            break;
        case 0x0D: // erase_window (V4+)
            // Not implemented - no-op
            break;
        case 0x0E: // erase_line (V4+)
            // Not implemented - no-op
            break;
        case 0x0F: // set_cursor (V4+)
            // Not implemented - no-op
            break;
        case 0x10: // get_cursor (V4+)
            // Not implemented - no-op
            break;
        case 0x11: // set_text_style (V4+)
            // Not implemented - no-op
            break;
        case 0x12: // buffer_mode (V4+)
            // Not implemented - no-op
            break;
        case 0x13: // output_stream (V3+)
            // Not implemented - no-op
            break;
        case 0x14: // input_stream (V3+)
            // Not implemented - no-op
            break;
        case 0x15: // sound_effect (V3+)
            {
                // sound_effect number effect volume routine
                // effect: 1=prepare, 2=start, 3=stop, 4=finish
                // volume: high byte = repeats (255=forever), low byte = volume (1-8, 8=loudest)
                const soundNum = values[0] || 0;
                const effect = values[1] || 2;  // Default to start
                const volume = values[2] || 8;  // Default to max volume
                // values[3] would be interrupt routine (V5+)

                if (this.soundCallback) {
                    this.soundCallback(soundNum, effect, volume);
                } else if (typeof Audio !== 'undefined' && this.sounds[soundNum]) {
                    // Basic browser audio support
                    const sound = this.sounds[soundNum];
                    if (effect === 2) {
                        // Start playing
                        if (this.currentSound) {
                            this.currentSound.pause();
                        }
                        try {
                            const audio = new Audio('data:audio/' + sound.format + ';base64,' + sound.data);
                            audio.volume = (volume & 0xFF) / 8;
                            const repeats = (volume >> 8) & 0xFF;
                            if (repeats === 255) {
                                audio.loop = true;
                            }
                            audio.play().catch(() => {});
                            this.currentSound = audio;
                        } catch (e) {
                            if (this.debugMode) console.error('[SOUND] Failed to play:', e);
                        }
                    } else if (effect === 3 || effect === 4) {
                        // Stop/finish
                        if (this.currentSound) {
                            this.currentSound.pause();
                            this.currentSound = null;
                        }
                    }
                }
            }
            break;
        case 0x16: // read_char (V4+)
            // Would need async input - for now just return immediately with newline
            // This is a stub that doesn't wait for actual input
            this.store(13); // Return newline for now
            break;
        case 0x17: // scan_table (V4+)
            {
                const result = this.scanTable(values[0], values[1], values[2], values[3] || 0x82);
                this.store(result);
                this.branch(result !== 0);
            }
            break;
        case 0x18: // not (bitwise not) - V5+, but also used in V1-4 as VAR form
            this.store(~values[0] & 0xFFFF);
            break;
        case 0x19: // call_vn (V5+)
            if (VERSION >= 5) {
                this.callRoutine(values[0], values.slice(1), null);
            }
            break;
        case 0x1A: // call_vn2 (V5+)
            if (VERSION >= 5) {
                this.callRoutine(values[0], values.slice(1), null);
            }
            break;
        case 0x1B: // tokenise (V5+)
            // Not implemented - no-op
            break;
        case 0x1C: // encode_text (V5+)
            // Not implemented - no-op
            break;
        case 0x1D: // copy_table (V5+)
            // Not implemented - no-op
            break;
        case 0x1E: // print_table (V5+)
            // Not implemented - no-op
            break;
        case 0x1F: // check_arg_count (V5+)
            {
                // Check if argument number N was provided to current routine
                const argNum = values[0];
                // For now, assume all explicitly passed args are present
                // This is a simplification - would need to track actual arg count
                this.branch(argNum <= this.locals.length);
            }
            break;
        default:
            throw new Error(`Unimplemented VAR opcode: 0x${opcode.toString(16)}`);
    }
};

// Extended Instructions (V5+ only, opcode 0xBE prefix)
ZMachine.prototype.executeExtended = function() {
    // Read the extended opcode number
    const extOpcode = this.readByte(this.pc);
    this.pc++;

    // Read operand types
    const types = this.readByte(this.pc);
    this.pc++;

    const operands = [];
    for (let i = 0; i < 4; i++) {
        const opType = (types >> (6 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // Get actual values
    const values = operands.map(op => this.getOperand(op));

    if (this.debugMode) {
        console.error(`[EXT 0x${extOpcode.toString(16)}] values: [${values.map(v => '0x' + v.toString(16)).join(', ')}]`);
    }

    switch (extOpcode) {
        case 0x00: // save (extended form, V5+)
            {
                // V5+ save with optional table/bytes/name
                // Returns 0 on failure, 1 on save, 2 on restore
                const result = this.save() ? 1 : 0;
                this.store(result);
            }
            break;

        case 0x01: // restore (extended form, V5+)
            {
                // V5+ restore with optional table/bytes/name
                if (this.restoreCallback) {
                    const state = this.restoreCallback();
                    if (this.restore(state)) {
                        // Restore succeeded - store 2 to indicate success
                        this.store(2);
                    } else {
                        this.store(0);
                    }
                } else {
                    this.store(0);
                }
            }
            break;

        case 0x02: // log_shift - logical shift
            {
                const number = values[0];
                const places = values[1] > 32767 ? values[1] - 65536 : values[1]; // signed
                let result;
                if (places >= 0) {
                    result = (number << places) & 0xFFFF;
                } else {
                    result = (number >>> -places) & 0xFFFF;
                }
                this.store(result);
            }
            break;

        case 0x03: // art_shift - arithmetic shift
            {
                let number = values[0] > 32767 ? values[0] - 65536 : values[0]; // signed
                const places = values[1] > 32767 ? values[1] - 65536 : values[1]; // signed
                let result;
                if (places >= 0) {
                    result = (number << places);
                } else {
                    result = (number >> -places); // arithmetic right shift preserves sign
                }
                result = result & 0xFFFF;
                this.store(result);
            }
            break;

        case 0x04: // set_font
            {
                // Font 1 = normal, 3 = character graphics, 4 = fixed-pitch
                // Return previous font number, or 0 if requested font not available
                const font = values[0];
                // For now, accept font 1 (normal) and 4 (fixed)
                if (font === 1 || font === 4) {
                    this.store(1); // Pretend we were using font 1
                } else {
                    this.store(0); // Font not available
                }
            }
            break;

        case 0x05: // draw_picture (V6 graphics)
            {
                // draw_picture picture-number y x
                const picNum = values[0];
                const y = values.length > 1 ? values[1] : 1;
                const x = values.length > 2 ? values[2] : 1;

                if (this.graphicsCallback) {
                    this.graphicsCallback('draw', picNum, x, y);
                } else if (this.pictures[picNum]) {
                    // Basic browser support - create an img element
                    if (typeof document !== 'undefined') {
                        const pic = this.pictures[picNum];
                        const img = document.createElement('img');
                        img.src = 'data:image/' + pic.format + ';base64,' + pic.data;
                        img.style.position = 'absolute';
                        img.style.left = x + 'px';
                        img.style.top = y + 'px';
                        const container = document.getElementById('graphics-container');
                        if (container) container.appendChild(img);
                    }
                }
                if (this.debugMode) console.error(`[EXT] draw_picture: pic=${picNum} at (${x},${y})`);
            }
            break;

        case 0x06: // picture_data (V6 graphics)
            {
                // picture_data picture-number array -> (result)
                // If picture-number is 0, returns number of pictures
                // Otherwise stores width and height in array and branches if exists
                const picNum = values[0];
                const array = values.length > 1 ? values[1] : 0;

                if (picNum === 0) {
                    // Return total number of pictures
                    this.store(Object.keys(this.pictures).length);
                } else if (this.pictures[picNum]) {
                    const pic = this.pictures[picNum];
                    if (array) {
                        this.writeWord(array, pic.height || 0);
                        this.writeWord(array + 2, pic.width || 0);
                    }
                    this.branch(true);
                } else {
                    this.branch(false);
                }
            }
            break;

        case 0x07: // erase_picture (V6 graphics)
            {
                // erase_picture picture-number y x - erase area same size as picture
                const picNum = values[0];
                const y = values.length > 1 ? values[1] : 1;
                const x = values.length > 2 ? values[2] : 1;

                if (this.graphicsCallback) {
                    this.graphicsCallback('erase', picNum, x, y);
                }
                if (this.debugMode) console.error(`[EXT] erase_picture: pic=${picNum} at (${x},${y})`);
            }
            break;

        case 0x08: // set_margins (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] set_margins: not implemented');
            break;

        case 0x09: // save_undo
            {
                // Save undo state
                // Returns -1 if undo not available, 0 on failure, 1 on save, 2 on successful restore
                if (!this.undoStates) {
                    this.undoStates = [];
                }
                try {
                    const state = {
                        memory: this.memory.slice(0, STATIC_MEMORY),
                        stack: this.stack.slice(),
                        callStack: JSON.parse(JSON.stringify(this.callStack)),
                        pc: this.pc,
                        locals: this.locals.slice()
                    };
                    this.undoStates.push(state);
                    // Limit undo history
                    if (this.undoStates.length > 10) {
                        this.undoStates.shift();
                    }
                    this.store(1);
                } catch (e) {
                    this.store(0);
                }
            }
            break;

        case 0x0A: // restore_undo
            {
                if (!this.undoStates || this.undoStates.length === 0) {
                    this.store(0);
                } else {
                    const state = this.undoStates.pop();
                    // Restore dynamic memory
                    for (let i = 0; i < state.memory.length; i++) {
                        this.memory[i] = state.memory[i];
                    }
                    this.stack = state.stack.slice();
                    this.callStack = JSON.parse(JSON.stringify(state.callStack));
                    this.pc = state.pc;
                    this.locals = state.locals.slice();
                    this.store(2); // Successful restore
                }
            }
            break;

        case 0x0B: // print_unicode
            {
                const charCode = values[0];
                this.print(String.fromCharCode(charCode));
            }
            break;

        case 0x0C: // check_unicode
            {
                // Check if unicode character can be printed (bit 0) or read (bit 1)
                // For simplicity, assume all characters can be printed and read
                this.store(3); // Both bits set
            }
            break;

        case 0x0D: // set_true_colour (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] set_true_colour: not implemented');
            break;

        case 0x10: // move_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] move_window: not implemented');
            break;

        case 0x11: // window_size (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] window_size: not implemented');
            break;

        case 0x12: // window_style (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] window_style: not implemented');
            break;

        case 0x13: // get_wind_prop (V6)
            // Return 0 for all window properties
            this.store(0);
            break;

        case 0x14: // scroll_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] scroll_window: not implemented');
            break;

        case 0x15: // pop_stack (V6)
            {
                // Pop items from a stack
                const items = values[0];
                const stack = values.length > 1 ? values[1] : 0; // 0 = evaluation stack
                for (let i = 0; i < items; i++) {
                    this.pop();
                }
            }
            break;

        case 0x16: // read_mouse (V6)
            // Not implemented - just return zeros
            if (values[0]) {
                this.writeWord(values[0], 0);     // Y coordinate
                this.writeWord(values[0] + 2, 0); // X coordinate
                this.writeWord(values[0] + 4, 0); // Buttons
                this.writeWord(values[0] + 6, 0); // Menu selection
            }
            break;

        case 0x17: // mouse_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] mouse_window: not implemented');
            break;

        case 0x18: // push_stack (V6)
            {
                // Push value onto a user stack, branch on success
                // For simplicity, just push to evaluation stack
                this.push(values[0]);
                this.branch(true);
            }
            break;

        case 0x19: // put_wind_prop (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] put_wind_prop: not implemented');
            break;

        case 0x1A: // print_form (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] print_form: not implemented');
            break;

        case 0x1B: // make_menu (V6)
            // Not implemented - always fail
            this.branch(false);
            break;

        case 0x1C: // picture_table (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] picture_table: not implemented');
            break;

        case 0x1D: // buffer_screen (V6)
            // Return 0 (buffer screen mode not supported)
            this.store(0);
            break;

        default:
            throw new Error(`Unimplemented extended opcode: 0x${extOpcode.toString(16)}`);
    }
};

// Helper functions
ZMachine.prototype.printLiteral = function() {
    const text = this.decodeZString(this.pc);
    this.print(text);
    // Skip past the Z-string (which uses 2-byte words)
    // The high bit of each word indicates if it's the last word
    let addr = this.pc;
    while (true) {
        const word = this.readWord(addr);
        addr += 2;
        if (word & 0x8000) {
            // This was the last word
            break;
        }
    }
    this.pc = addr;
};

ZMachine.prototype.branch = function(condition) {
    // Save the address of the branch data for offset calculation
    const branchDataAddr = this.pc;
    const branchByte = this.readByte(this.pc);
    this.pc++;

    const branchOnTrue = !!(branchByte & 0x80);
    let offset;
    let offsetSize;

    if (branchByte & 0x40) {
        // Short form (6-bit offset)
        offset = branchByte & 0x3F;
        offsetSize = 1;  // 1 byte total
    } else {
        // Long form (14-bit signed offset)
        const secondByte = this.readByte(this.pc);
        offset = ((branchByte & 0x3F) << 8) | secondByte;
        this.pc++;
        offsetSize = 2;  // 2 bytes total

        if (offset & 0x2000) {
            offset |= 0xC000; // Sign extend
        }
        // Convert to signed
        if (offset > 32767) offset -= 65536;
    }

    if (condition === branchOnTrue) {
        if (offset === 0) {
            this.returnFromRoutine(0);
        } else if (offset === 1) {
            this.returnFromRoutine(1);
        } else {
            // Offset is relative to the address AFTER the branch data
            // The offset of 2 means "branch to the instruction immediately after this one"
            // So we calculate: (address of branch data) + (size of branch data) + (offset) - 2
            const newPC = branchDataAddr + offsetSize + offset - 2;

            // Safety check: don't branch to header area (first 64 bytes)
            if (newPC < 0x40) {
                if (this.debugMode) {
                    console.error(`[BRANCH] WARNING: Attempted to branch to 0x${newPC.toString(16)} which is in the header`);
                    console.error(`[BRANCH] This usually indicates a bug in parsing or variable handling`);
                    console.error(`[BRANCH] Branch from 0x${branchDataAddr.toString(16)} with offset ${offset}`);
                    console.error(`[BRANCH] This is likely a parse error - returning 0 to indicate failure`);
                }
                // Treat this as a catastrophic error and return false from the routine
                this.returnFromRoutine(0);
            } else {
                this.pc = newPC;
            }
        }
    }
};

ZMachine.prototype.store = function(value) {
    const varNum = this.readByte(this.pc);
    this.pc++;
    this.setVariable(varNum, value);
};

ZMachine.prototype.returnFromRoutine = function(value) {
    if (this.callStack.length === 0) {
        this.quit();
        return;
    }

    const frame = this.callStack.pop();

    this.pc = frame.returnPC;
    this.locals = frame.locals;

    if (frame.storeVar !== null) {
        this.setVariable(frame.storeVar, value);
    }
};

ZMachine.prototype.getObjectName = function(objNum) {
    const obj = this.getObject(objNum);
    if (!obj) return "";

    let propAddr = obj.properties;
    const textLength = this.readByte(propAddr);
    propAddr++;

    if (textLength === 0) return "";

    return this.decodeZString(propAddr);
};

// Routine call handling
ZMachine.prototype.callRoutine = function(packedAddr, args, storeVar) {
    if (packedAddr === 0) {
        if (storeVar !== null) {
            this.setVariable(storeVar, 0);
        }
        return;
    }

    const addr = this.unpackAddress(packedAddr);

    // Sanity check - routine address should be at least in static memory region
    if (addr < STATIC_MEMORY) {
        console.warn(`Warning: Attempted to call routine at invalid address 0x${addr.toString(16)} (packed: 0x${packedAddr.toString(16)})`);
        if (storeVar !== null) {
            this.setVariable(storeVar, 0);
        }
        return;
    }

    // Read routine header
    const numLocals = this.readByte(addr);

    if (this.debugMode && this.instructionCount < 20) {
        console.error(`  -> Unpacked to addr 0x${addr.toString(16)}, numLocals=${numLocals}`);
    }

    // Sanity check - Z-Machine routines can have at most 15 locals
    if (numLocals > 15) {
        console.error(`[CALL ERROR] Invalid routine - dumping call stack:`);
        for (let i = this.callStack.length - 1; i >= 0; i--) {
            const frame = this.callStack[i];
            console.error(`  Frame ${i}: returnPC=0x${frame.returnPC.toString(16)}, storeVar=${frame.storeVar}`);
        }
        console.error(`[CALL ERROR] Current locals: ${this.locals.slice(0, 16).map((v, i) => `L${i+1}=0x${(v||0).toString(16)}`).join(', ')}`);
        console.error(`[CALL ERROR] Stack top 10: [${this.stack.slice(-10).map(v => '0x' + v.toString(16)).join(', ')}]`);
        throw new Error(`Invalid routine at 0x${addr.toString(16)} (packed: 0x${packedAddr.toString(16)}): numLocals=${numLocals} exceeds maximum of 15`);
    }

    // Save current state (make a copy of locals array!)

    this.callStack.push({
        returnPC: this.pc,
        locals: this.locals.slice(),
        numLocals: numLocals,
        storeVar: storeVar
    });

    // Initialize new locals
    this.locals = new Array(16);

    // Set up locals
    if (VERSION <= 4) {
        // Read default local values
        for (let i = 0; i < numLocals; i++) {
            this.locals[i] = this.readWord(addr + 1 + i * 2);
        }
        this.pc = addr + 1 + numLocals * 2;
    } else {
        // V5+ - locals start at 0
        for (let i = 0; i < numLocals; i++) {
            this.locals[i] = 0;
        }
        this.pc = addr + 1;
    }

    // Copy arguments to locals
    if (this.debugMode) {
        console.error(`[CALL ${this.instructionCount}] To addr 0x${addr.toString(16)}: numLocals=${numLocals}, args=[${args.map(a => '0x'+a.toString(16)).join(', ')}]`);
        console.error(`[CALL ${this.instructionCount}] Defaults: ${this.locals.slice(0, numLocals).map((v,i) => `L${i+1}=0x${v.toString(16)}`).join(' ')}`);
    }
    for (let i = 0; i < args.length && i < numLocals; i++) {
        this.locals[i] = args[i];
    }
    if (this.debugMode) {
        console.error(`[CALL ${this.instructionCount}] Final:    ${this.locals.slice(0, numLocals).map((v,i) => `L${i+1}=0x${v.toString(16)}`).join(' ')}`);
    }
};

// Crash dump generation
ZMachine.prototype.generateCrashDump = function(error) {
    const dump = {
        timestamp: new Date().toISOString(),
        error: {
            message: error.message,
            stack: error.stack,
            name: error.name
        },
        machine: {
            version: VERSION,
            pc: `0x${this.pc.toString(16)}`,
            instructionCount: this.instructionCount,
            running: this.running,
            finished: this.finished
        },
        memory: {
            staticMemoryStart: `0x${STATIC_MEMORY.toString(16)}`,
            highMemoryStart: `0x${HIGH_MEMORY.toString(16)}`,
            pcBytes: Array.from(this.memory.slice(Math.max(0, this.pc - 10), this.pc + 20)).map(b => `0x${b.toString(16).padStart(2, '0')}`)
        },
        stack: {
            evaluationStack: this.stack.slice(-20).map(v => `0x${v.toString(16)}`),
            stackDepth: this.stack.length,
            callStack: this.callStack.map((frame, i) => ({
                frameNumber: i,
                returnPC: `0x${frame.returnPC.toString(16)}`,
                numLocals: frame.numLocals,
                storeVar: frame.storeVar,
                locals: frame.locals.slice(0, frame.numLocals).map(v => v === undefined ? 'undefined' : `0x${v.toString(16)}`)
            })),
            callDepth: this.callStack.length
        },
        locals: this.locals.map((v, i) => v === undefined ? undefined : `0x${v.toString(16)}`),
        globals: {
            sample: Array.from({length: 10}, (_, i) => {
                const addr = GLOBALS_ADDR + i * 2;
                return `g${i.toString().padStart(3, '0')}: 0x${this.readWord(addr).toString(16).padStart(4, '0')}`;
            })
        },
        instructionHistory: this.instructionHistory,
        output: {
            buffer: this.outputBuffer.substring(Math.max(0, this.outputBuffer.length - 500)),
            totalLength: this.outputBuffer.length
        }
    };

    return dump;
};

ZMachine.prototype.saveCrashDump = function(dump) {
    const json = JSON.stringify(dump, null, 2);

    if (typeof window !== "undefined" && typeof document !== "undefined") {
        // Browser environment - offer download
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `zmachine-crash-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.error('Crash dump saved to downloads');
    } else if (typeof require !== "undefined") {
        // Node.js environment
        try {
            const fs = require('fs');
            const filename = `zmachine-crash-${Date.now()}.json`;
            fs.writeFileSync(filename, json);
            console.error(`Crash dump saved to ${filename}`);
        } catch (e) {
            console.error('Failed to save crash dump:', e.message);
            console.error('Crash dump:', json);
        }
    } else {
        console.error('Crash dump:', json);
    }
};

ZMachine.prototype.recordInstruction = function(pc, opcode) {
    if (!this.debugMode) return;

    const record = {
        count: this.instructionCount,
        pc: `0x${pc.toString(16)}`,
        opcode: `0x${opcode.toString(16)}`,
        stackDepth: this.stack.length,
        callDepth: this.callStack.length
    };

    this.instructionHistory.push(record);
    if (this.instructionHistory.length > this.maxHistorySize) {
        this.instructionHistory.shift();
    }
};

// Main execution loop
ZMachine.prototype.run = function() {
    const entryPC = this.pc;
    const entryStack = this.stack.length;
    const entryInst = this.instructionCount;
    this.running = true;
    if (this.debugMode) {
        console.error(`[RUN] Entry: PC=0x${entryPC.toString(16)} stack=${entryStack} inst=${entryInst}`);
    }

    // Always increment instruction count (used for yielding in browser)
    let localInstructionCount = 0;

    while (this.running && !this.finished) {
        try {
            const currentPC = this.pc;
            const opcode = this.readByte(this.pc);

            if (this.debugMode) {
                this.recordInstruction(currentPC, opcode);
                this.instructionCount++;
            }
            localInstructionCount++;

            this.executeInstruction();

            // Safety check - detect infinite loops
            if (this.debugMode && this.instructionCount > 100000) {
                throw new Error(`Instruction count exceeded 100000 - possible infinite loop`);
            }

        } catch (e) {
            console.error(`\n========== Z-MACHINE CRASH ==========`);
            console.error(`Error at PC 0x${this.pc.toString(16)}: ${e.message}`);
            console.error(`Instruction count: ${this.instructionCount}`);
            console.error(`Call depth: ${this.callStack.length}`);
            console.error(`Stack depth: ${this.stack.length}`);
            console.error(`=====================================\n`);

            if (this.debugMode) {
                const dump = this.generateCrashDump(e);
                this.saveCrashDump(dump);
                console.error('Full crash dump has been saved');
            }

            console.error('\nStack trace:', e.stack);
            this.running = false;
            break;
        }

        // Yield periodically for UI updates (every 1000 instructions)
        if (localInstructionCount % 1000 === 0 && typeof window !== "undefined") {
            setTimeout(() => this.run(), 0);
            return;
        }
    }

    if (this.finished) {
        console.error('\n[Z-Machine execution completed]');
    } else if (!this.running) {
        console.error('\n[Z-Machine execution stopped]');
    }
};

// Initialize and start the Z-Machine
function createZMachine() {
    const storyData = decodeStoryData();
    return new ZMachine(storyData);
}

// Module exports
if (typeof module !== "undefined" && module.exports) {
    // Node.js
    module.exports = {
        ZMachine,
        createZMachine,
        VERSION,
        decodeStoryData
    };

    // Auto-run if executed directly (not required as a module)
    if (require.main === module) {
        console.error('Starting Z-Machine game...\n');
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        const m = createZMachine();

        // Check for --debug flag
        if (process.argv.includes('--debug')) {
            m.debugMode = true;
            console.error('[DEBUG MODE ENABLED]\n');
        }

        // Output handler
        m.outputCallback = (text) => {
            process.stdout.write(text);
        };

        // Input handler will be set by read() opcode when needed
        m.inputCallback = null;

        // Input polling function
        function checkForInput() {
            if (m.inputCallback && !m.running) {
                // Game is waiting for input
                rl.question('\n> ', (answer) => {
                    if (m.inputCallback) {
                        m.inputCallback(answer);
                        // Check again after execution
                        setTimeout(checkForInput, 10);
                    }
                });
            } else if (m.finished) {
                // Game is done
                rl.close();
            } else if (!m.running) {
                // Check again soon
                setTimeout(checkForInput, 10);
            } else {
                // Still running, check again
                setTimeout(checkForInput, 10);
            }
        }

        // Start the game
        try {
            m.run();
            // Start polling for input
            setTimeout(checkForInput, 10);
        } catch (e) {
            console.error('Fatal error:', e.message);
            console.error(e.stack);
            rl.close();
            process.exit(1);
        }
    }
} else if (typeof define === "function" && define.amd) {
    // AMD
    define([], function() {
        return {
            ZMachine,
            createZMachine,
            VERSION,
            decodeStoryData
        };
    });
} else {
    // Browser global
    window.ZMachine = ZMachine;
    window.createZMachine = createZMachine;
}