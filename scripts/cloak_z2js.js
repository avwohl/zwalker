/**
 * Z-Machine JavaScript Runtime
 * Generated by z2js compiler
 *
 * Story: 181205
 * Z-Machine Version: 3
 * Release: 1
 */

"use strict";

// Z-Machine Constants
const VERSION = 3;
const INITIAL_PC = 0x167B;  // Direct byte address
const DICTIONARY_ADDR = 0x0D73;
const OBJECT_TABLE_ADDR = 0x0152;
const GLOBALS_ADDR = 0x0102;
const STATIC_MEMORY = 0x0D73;
const ABBREVIATIONS_ADDR = 0x0042;
const HIGH_MEMORY = 0x167A;
// V6/V7 offsets for packed addresses (already multiplied by 8 in header parsing)
const ROUTINES_OFFSET = 0x0000;
const STRINGS_OFFSET = 0x0000;

// Z-Machine Runtime
class ZMachine {
    constructor(storyData) {
        // Memory
        this.memory = new Uint8Array(storyData);
        this.originalMemory = new Uint8Array(storyData);

        // CPU state
        this.pc = INITIAL_PC;
        this.stack = [];
        this.callStack = [];
        this.locals = new Array(16);

        // I/O
        this.outputBuffer = "";
        this.statusLine = { location: "", score: 0, turns: 0 };
        this.windows = [{ text: "", cursor: [1, 1] }, { text: "", cursor: [1, 1] }];
        this.currentWindow = 0;

        // Interpreter state
        this.running = false;
        this.finished = false;
        this.inputCallback = null;
        this.outputCallback = null;
        this.saveCallback = null;
        this.restoreCallback = null;

        // Random state
        this.randomMode = "random";
        this.randomSeed = 0;
        this.randomIndex = 0;

        // Debug state
        this.debugMode = false;  // Enable debug to trace instructions (set to true to enable)
        this.instructionCount = 0;
        this.instructionHistory = [];
        this.maxHistorySize = 100;

        // Multimedia resources (V6 graphics/sound)
        this.pictures = {};       // picture_num -> { data: base64, format: 'png'|'jpeg', width, height }
        this.sounds = {};         // sound_num -> { data: base64, format: 'aiff'|'ogg'|'mod' }
        this.currentSound = null; // Currently playing audio element
        this.graphicsCallback = null;  // Function to call for drawing pictures
        this.soundCallback = null;     // Function to call for playing sounds

        // Transcript recording (zwalker-compatible format)
        this.transcriptEnabled = false;
        this.transcriptData = [];     // Array of { command, from_room, to_room, result }
        this.lastCommand = null;
        this.lastRoomNumber = null;
    }

    // Memory access
    readByte(addr) {
        return this.memory[addr];
    }

    readWord(addr) {
        return (this.memory[addr] << 8) | this.memory[addr + 1];
    }

    writeByte(addr, value) {
        if (addr >= STATIC_MEMORY) {
            throw new Error(`[WRITE PROTECTION] Attempted to write byte to read-only memory at 0x${addr.toString(16)} (value=0x${value.toString(16)}, static memory starts at 0x${STATIC_MEMORY.toString(16)})`);
        }
        const oldValue = this.memory[addr];
        this.memory[addr] = value & 0xFF;
        if (this.debugMode) {
            console.error(`[WRITE #${this.instructionCount}] @0x${addr.toString(16).padStart(4,'0')} byte 0x${oldValue.toString(16).padStart(2,'0')} -> 0x${(value & 0xFF).toString(16).padStart(2,'0')}`);
        }
    }

    writeWord(addr, value) {
        if (addr >= STATIC_MEMORY) {
            throw new Error(`[WRITE PROTECTION] Attempted to write word to read-only memory at 0x${addr.toString(16)} (value=0x${value.toString(16)}, static memory starts at 0x${STATIC_MEMORY.toString(16)})`);
        }
        const oldValue = this.readWord(addr);
        this.memory[addr] = (value >> 8) & 0xFF;
        this.memory[addr + 1] = value & 0xFF;
        if (this.debugMode) {
            console.error(`[WRITE #${this.instructionCount}] @0x${addr.toString(16).padStart(4,'0')} word 0x${oldValue.toString(16).padStart(4,'0')} -> 0x${(value & 0xFFFF).toString(16).padStart(4,'0')}`);
        }
    }

    // Stack operations
    push(value) {
        this.stack.push(value & 0xFFFF);
    }

    pop() {
        if (this.stack.length === 0) {
            throw new Error("Stack underflow");
        }
        return this.stack.pop();
    }

    peek() {
        if (this.stack.length === 0) {
            throw new Error("Stack underflow");
        }
        return this.stack[this.stack.length - 1];
    }

    // Variable access (0=stack, 1-15=locals, 16+=globals)
    getVariable(varNum) {
        if (varNum === 0) {
            return this.pop();
        } else if (varNum < 16) {
            return this.locals[varNum - 1] || 0;
        } else {
            const addr = GLOBALS_ADDR + (varNum - 16) * 2;
            return this.readWord(addr);
        }
    }

    setVariable(varNum, value) {
        value = value & 0xFFFF;
        if (varNum === 0) {
            this.push(value);
        } else if (varNum < 16) {
            this.locals[varNum - 1] = value;
        } else {
            const addr = GLOBALS_ADDR + (varNum - 16) * 2;
            this.writeWord(addr, value);
        }
    }

    // Operand evaluation
    getOperand(operand) {
        if (Array.isArray(operand) && operand[0] === "var") {
            return this.getVariable(operand[1]);
        }
        return operand;
    }

    // Packed address conversion
    // V6/V7 use different offsets for routines vs strings
    // V8 uses divisor of 8 but NO offsets (like V5 semantics)
    unpackAddress(packed, isString = false) {
        switch (VERSION) {
            case 1: case 2: case 3:
                return packed * 2;
            case 4: case 5:
                return packed * 4;
            case 6: case 7:
                // V6/V7: Use appropriate offset based on address type
                if (isString) {
                    return packed * 4 + STRINGS_OFFSET;
                } else {
                    return packed * 4 + ROUTINES_OFFSET;
                }
            case 8:
                // V8 uses divisor of 8 but NO offsets
                return packed * 8;
            default:
                return packed * 2;
        }
    }

    // Z-String decoding with version-specific handling
    // V1: z-char 1 = newline, z-chars 2-3 = shift up/down, z-chars 4-5 = shift lock
    // V2: z-chars 1-3 = abbreviations (only 1 in V2), z-chars 4-5 = shift (temporary in V2)
    // V3+: z-chars 1-3 = abbreviations, z-chars 4-5 = temporary shift
    decodeZString(addr) {
        // A2 alphabet varies by version
        // V1: no newline, digits start at position 1 (z-char 7 = '0')
        // V2+: newline at position 1, digits start at position 2 (z-char 8 = '0')
        const a2_v1 = " 0123456789.,!?_#'\"/<-:()";
        const a2_v2plus = " \n0123456789.,!?_#'\"/-:()";

        const alphabets = [
            "abcdefghijklmnopqrstuvwxyz",      // A0 (lowercase)
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ",      // A1 (uppercase)
            VERSION === 1 ? a2_v1 : a2_v2plus  // A2 (punctuation/digits)
        ];

        let result = "";
        let alphabet = 0;
        let lockAlphabet = 0;  // For V1/V2 shift lock
        let abbrevTable = 0;   // Which abbreviation table (1-3)
        let zsciiState = 0;    // 0=normal, 1=waiting high, 2=waiting low
        let zsciiHigh = 0;

        while (true) {
            const word = this.readWord(addr);
            addr += 2;

            const chars = [
                (word >> 10) & 0x1F,
                (word >> 5) & 0x1F,
                word & 0x1F
            ];

            for (let c of chars) {
                // Handle 10-bit ZSCII escape sequence
                if (zsciiState === 1) {
                    zsciiHigh = c;
                    zsciiState = 2;
                    continue;
                } else if (zsciiState === 2) {
                    const zsciiCode = (zsciiHigh << 5) | c;
                    if (zsciiCode > 0) result += String.fromCharCode(zsciiCode);
                    zsciiState = 0;
                    alphabet = lockAlphabet;
                    continue;
                }

                // Handle abbreviation mode
                if (abbrevTable > 0) {
                    if (VERSION >= 2 && ABBREVIATIONS_ADDR) {
                        const abbrevAddr = ABBREVIATIONS_ADDR + 2 * (32 * (abbrevTable - 1) + c);
                        const wordAddr = this.readWord(abbrevAddr);
                        result += this.decodeZString(wordAddr * 2);
                    }
                    abbrevTable = 0;
                    alphabet = lockAlphabet;
                    continue;
                }

                // Z-char 0: always space
                if (c === 0) {
                    result += " ";
                    alphabet = lockAlphabet;
                    continue;
                }

                // Z-char 1
                if (c === 1) {
                    if (VERSION === 1) {
                        // V1: newline
                        result += "\n";
                        alphabet = lockAlphabet;
                    } else {
                        // V2+: abbreviation table 0
                        abbrevTable = 1;
                    }
                    continue;
                }

                // Z-char 2
                if (c === 2) {
                    if (VERSION === 1) {
                        // V1: temporary shift UP
                        alphabet = (alphabet + 1) % 3;
                    } else if (VERSION === 2) {
                        // V2: temporary shift UP
                        alphabet = (lockAlphabet + 1) % 3;
                    } else {
                        // V3+: abbreviation table 1
                        abbrevTable = 2;
                    }
                    continue;
                }

                // Z-char 3
                if (c === 3) {
                    if (VERSION === 1) {
                        // V1: temporary shift DOWN
                        alphabet = (alphabet + 2) % 3;
                    } else if (VERSION === 2) {
                        // V2: temporary shift DOWN
                        alphabet = (lockAlphabet + 2) % 3;
                    } else {
                        // V3+: abbreviation table 2
                        abbrevTable = 3;
                    }
                    continue;
                }

                // Z-char 4
                if (c === 4) {
                    if (VERSION <= 2) {
                        // V1/V2: shift lock UP
                        lockAlphabet = (lockAlphabet + 1) % 3;
                        alphabet = lockAlphabet;
                    } else {
                        // V3+: temporary shift to A1
                        alphabet = 1;
                    }
                    continue;
                }

                // Z-char 5
                if (c === 5) {
                    if (VERSION <= 2) {
                        // V1/V2: shift lock DOWN
                        lockAlphabet = (lockAlphabet + 2) % 3;
                        alphabet = lockAlphabet;
                    } else {
                        // V3+: temporary shift to A2
                        alphabet = 2;
                    }
                    continue;
                }

                // Z-char 6 in A2: start 10-bit ZSCII escape
                if (c === 6 && alphabet === 2) {
                    zsciiState = 1;
                    continue;
                }

                // Regular character (z-chars 6-31)
                if (c >= 6) {
                    const idx = c - 6;
                    if (alphabet === 0 && idx < alphabets[0].length) {
                        result += alphabets[0][idx];
                    } else if (alphabet === 1 && idx < alphabets[1].length) {
                        result += alphabets[1][idx];
                    } else if (alphabet === 2 && idx < alphabets[2].length) {
                        result += alphabets[2][idx];
                    }
                }

                // Reset alphabet after character
                if (VERSION >= 3) {
                    alphabet = 0;
                } else {
                    alphabet = lockAlphabet;
                }
            }

            if (word & 0x8000) break;
        }

        return result;
    }

    // Object system
    getObject(objNum) {
        if (objNum === 0) return null;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            return {
                attributes: this.readWord(objAddr) << 16 | this.readWord(objAddr + 2),
                parent: this.readByte(objAddr + 4),
                sibling: this.readByte(objAddr + 5),
                child: this.readByte(objAddr + 6),
                properties: this.readWord(objAddr + 7)
            };
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            return {
                attributes: this.readWord(objAddr) << 32 | this.readWord(objAddr + 2) << 16 |
                           this.readWord(objAddr + 4),
                parent: this.readWord(objAddr + 6),
                sibling: this.readWord(objAddr + 8),
                child: this.readWord(objAddr + 10),
                properties: this.readWord(objAddr + 12)
            };
        }
    }

    setObjectParent(objNum, parentNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 4;
            this.writeByte(objAddr, parentNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 6;
            this.writeWord(objAddr, parentNum);
        }
    }

    setObjectSibling(objNum, siblingNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 5;
            this.writeByte(objAddr, siblingNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 8;
            this.writeWord(objAddr, siblingNum);
        }
    }

    setObjectChild(objNum, childNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9 + 6;
            this.writeByte(objAddr, childNum);
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14 + 10;
            this.writeWord(objAddr, childNum);
        }
    }

    testAttribute(objNum, attrNum) {
        if (objNum === 0) return false;

        // Read directly from memory to avoid 32-bit JavaScript bitwise limitations
        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
        }
        const byteNum = Math.floor(attrNum / 8);
        const bitNum = 7 - (attrNum % 8);
        const b = this.readByte(objAddr + byteNum);
        return !!(b & (1 << bitNum));
    }

    setAttribute(objNum, attrNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b | (1 << bitNum));
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b | (1 << bitNum));
        }
    }

    clearAttribute(objNum, attrNum) {
        if (objNum === 0) return;

        let objAddr;
        if (VERSION <= 3) {
            objAddr = OBJECT_TABLE_ADDR + 62 + (objNum - 1) * 9;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b & ~(1 << bitNum));
        } else {
            objAddr = OBJECT_TABLE_ADDR + 126 + (objNum - 1) * 14;
            const byteNum = Math.floor(attrNum / 8);
            const bitNum = 7 - (attrNum % 8);
            const b = this.readByte(objAddr + byteNum);
            this.writeByte(objAddr + byteNum, b & ~(1 << bitNum));
        }
    }

    // Room tracking for transcript
    getCurrentRoom() {
        // Method 1: Infocom convention - global 0 is the room
        const room = this.readWord(GLOBALS_ADDR);
        if (room > 0 && room < 1000) {  // Reasonable object number
            return room;
        }

        // Method 2: Inform convention - find player object and get parent
        // Player is usually object 1 in Inform games
        try {
            const player = this.getObject(1);
            if (player && player.parent > 0) {
                return player.parent;
            }
        } catch (e) {
            // Ignore errors
        }

        // Fallback: return 0 (unknown room)
        return 0;
    }

    // Output functions
    print(text) {
        // If printing to status window (window 1) and transcript is enabled,
        // append room number to the status line
        if (this.currentWindow === 1 && this.transcriptEnabled && text.includes('\n')) {
            const room = this.getCurrentRoom();
            if (room > 0) {
                // Insert room number before the newline
                text = text.replace(/\n/g, ` [Room ${room}]\n`);
                // Also update the statusLine object for external rendering
                this.statusLine.room = room;
            }
        }

        this.outputBuffer += text;
        if (this.outputCallback) {
            this.outputCallback(text);
        }
    }

    printNum(num) {
        // Handle signed 16-bit numbers
        if (num > 32767) {
            num = num - 65536;
        }
        this.print(num.toString());
    }

    printChar(charCode) {
        if (charCode === 13) {
            this.print("\n");
        } else {
            this.print(String.fromCharCode(charCode));
        }
    }

    newLine() {
        this.print("\n");
    }

    // Random number generation
    random(range) {
        // Handle as signed 16-bit
        if (range > 32767) range = range - 65536;

        if (range === 0) {
            // random(0): Reset to truly random mode
            this.randomMode = "random";
            return 0;
        }

        if (range < 0) {
            // random(negative): Seed the predictable generator
            this.randomSeed = -range;
            this.randomMode = "predictable";
            this.randomIndex = this.randomSeed;  // Seed IS the initial state
            return 0;
        }

        if (this.randomMode === "predictable") {
            // Linear congruential generator
            this.randomIndex = (this.randomIndex * 1103515245 + 12345) & 0x7FFFFFFF;
            return (this.randomIndex % range) + 1;
        } else {
            return Math.floor(Math.random() * range) + 1;
        }
    }

    // Game state
    save() {
        if (this.saveCallback) {
            const state = {
                memory: Array.from(this.memory.slice(0, STATIC_MEMORY)),
                stack: this.stack.slice(),
                callStack: this.callStack.map(frame => ({
                    returnPC: frame.returnPC,
                    locals: frame.locals.slice(),
                    numLocals: frame.numLocals,
                    storeVar: frame.storeVar
                })),
                pc: this.pc,
                locals: this.locals.slice()
            };
            return this.saveCallback(state);
        }
        return false;
    }

    restore(state) {
        if (state && state.memory) {
            // Restore dynamic memory
            for (let i = 0; i < state.memory.length; i++) {
                this.memory[i] = state.memory[i];
            }
            this.stack = state.stack.slice();
            this.callStack = state.callStack.map(frame => ({
                returnPC: frame.returnPC,
                locals: frame.locals.slice(),
                numLocals: frame.numLocals,
                storeVar: frame.storeVar
            }));
            this.pc = state.pc;
            this.locals = state.locals.slice();
            return true;
        }
        return false;
    }

    restart() {
        // Restore original memory
        this.memory = new Uint8Array(this.originalMemory);
        this.pc = INITIAL_PC;
        this.stack = [];
        this.callStack = [];
        this.locals = new Array(16);
        this.outputBuffer = "";
        this.running = true;
        this.finished = false;
    }

    quit() {
        this.running = false;
        this.finished = true;
        this.print("\n[Game terminated]\n");
    }

    // Transcript recording (zwalker-compatible format)
    enableTranscript() {
        this.transcriptEnabled = true;
        this.transcriptData = [];
        this.lastRoomNumber = this.getCurrentRoom();
        this.print("\n[Transcript recording enabled]\n");
    }

    disableTranscript() {
        this.transcriptEnabled = false;
        this.print("\n[Transcript recording disabled]\n");
    }

    getTranscript() {
        // Return transcript in zwalker-compatible JSON format
        const rooms = new Set();
        const commands = [];

        this.transcriptData.forEach(entry => {
            rooms.add(entry.from_room);
            rooms.add(entry.to_room);
            commands.push(entry.command);
        });

        return {
            game: "unknown",  // Will be filled in by caller
            solved: false,    // User can set this manually
            rooms_visited: Array.from(rooms).filter(r => r > 0),
            solution_commands: commands,
            full_solution_data: this.transcriptData,
            stats: {
                rooms_found: rooms.size,
                commands_tried: this.transcriptData.length
            }
        };
    }

    exportTranscript() {
        // Return transcript as JSON string
        return JSON.stringify(this.getTranscript(), null, 2);
    }

    // Object name lookup
    getObjectName(objNum) {
        const obj = this.getObject(objNum);
        if (!obj) return "";

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr++;

        if (textLength === 0) return "";

        return this.decodeZString(propAddr);
    }

    // Object tree manipulation
    insertObject(objNum, destNum) {
        if (objNum === 0) return;

        // Remove from current parent
        this.removeObject(objNum);

        // Insert as first child of destination
        const dest = this.getObject(destNum);
        if (dest) {
            this.setObjectSibling(objNum, dest.child);
            this.setObjectChild(destNum, objNum);
            this.setObjectParent(objNum, destNum);
        }
    }

    removeObject(objNum) {
        if (objNum === 0) return;

        const obj = this.getObject(objNum);
        if (!obj || obj.parent === 0) return;

        const parent = this.getObject(obj.parent);
        if (!parent) return;

        // Remove from sibling chain
        if (parent.child === objNum) {
            // Object is first child
            this.setObjectChild(obj.parent, obj.sibling);
        } else {
            // Find previous sibling
            let prevSibling = parent.child;
            while (prevSibling !== 0) {
                const prevObj = this.getObject(prevSibling);
                if (prevObj.sibling === objNum) {
                    this.setObjectSibling(prevSibling, obj.sibling);
                    break;
                }
                prevSibling = prevObj.sibling;
            }
        }

        this.setObjectParent(objNum, 0);
        this.setObjectSibling(objNum, 0);
    }

    // Property access
    getPropertyAddr(objNum, propNum) {
        if (objNum === 0) return 0;

        const obj = this.getObject(objNum);
        if (!obj) return 0;

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr += 1 + textLength * 2;

        // Search for property
        while (propAddr < this.memory.length) {
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) break;

            let num, size, dataOffset;
            if (VERSION <= 3) {
                // V1-3: Property number in bits 4-0, size in bits 7-5
                num = sizeByte & 0x1F;
                size = (sizeByte >> 5) + 1;
                dataOffset = 1;
            } else {
                // V4+: Property number in bits 5-0
                num = sizeByte & 0x3F;
                if (sizeByte & 0x80) {
                    // Two-byte size: second byte bits 5-0 = size (0 means 64)
                    const sizeByte2 = this.readByte(propAddr + 1);
                    size = sizeByte2 & 0x3F;
                    if (size === 0) size = 64;
                    dataOffset = 2;
                } else {
                    // One-byte size: bit 6 set = 2 bytes, clear = 1 byte
                    size = (sizeByte & 0x40) ? 2 : 1;
                    dataOffset = 1;
                }
            }

            if (num === propNum) {
                return propAddr + dataOffset;
            }

            propAddr += dataOffset + size;
        }

        return 0;
    }

    getPropertySize(propAddr) {
        // Get the size of a property given the address of its DATA (after size byte(s))
        // We need to look at the byte(s) before propAddr
        if (VERSION <= 3) {
            const sizeByte = this.readByte(propAddr - 1);
            return (sizeByte >> 5) + 1;
        } else {
            // V4+: Could be 1 or 2 size bytes before the data
            const prevByte = this.readByte(propAddr - 1);
            if (prevByte & 0x80) {
                // This is a second size byte
                const size = prevByte & 0x3F;
                return size === 0 ? 64 : size;
            } else {
                // This is a single size byte
                return (prevByte & 0x40) ? 2 : 1;
            }
        }
    }

    getProperty(objNum, propNum) {
        const propAddr = this.getPropertyAddr(objNum, propNum);
        if (propAddr === 0) {
            // Return default property value
            const defaultAddr = OBJECT_TABLE_ADDR + (propNum - 1) * 2;
            return this.readWord(defaultAddr);
        }

        const size = this.getPropertySize(propAddr);

        if (size === 1) {
            return this.readByte(propAddr);
        } else {
            return this.readWord(propAddr);
        }
    }

    putProperty(objNum, propNum, value) {
        const propAddr = this.getPropertyAddr(objNum, propNum);
        if (propAddr === 0) return;

        const size = this.getPropertySize(propAddr);

        if (size === 1) {
            this.writeByte(propAddr, value);
        } else {
            this.writeWord(propAddr, value);
        }
    }

    getNextProperty(objNum, propNum) {
        if (objNum === 0) return 0;

        const obj = this.getObject(objNum);
        if (!obj) return 0;

        let propAddr = obj.properties;
        const textLength = this.readByte(propAddr);
        propAddr += 1 + textLength * 2;

        if (propNum === 0) {
            // Return first property
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) return 0;
            return VERSION <= 3 ? (sizeByte & 0x1F) : (sizeByte & 0x3F);
        }

        // Search for property
        while (propAddr < this.memory.length) {
            const sizeByte = this.readByte(propAddr);
            if (sizeByte === 0) break;

            let num, size, dataOffset;
            if (VERSION <= 3) {
                num = sizeByte & 0x1F;
                size = (sizeByte >> 5) + 1;
                dataOffset = 1;
            } else {
                num = sizeByte & 0x3F;
                if (sizeByte & 0x80) {
                    const sizeByte2 = this.readByte(propAddr + 1);
                    size = sizeByte2 & 0x3F;
                    if (size === 0) size = 64;
                    dataOffset = 2;
                } else {
                    size = (sizeByte & 0x40) ? 2 : 1;
                    dataOffset = 1;
                }
            }

            if (num === propNum) {
                // Found current property, return next
                propAddr += dataOffset + size;
                const nextSizeByte = this.readByte(propAddr);
                if (nextSizeByte === 0) return 0;
                return VERSION <= 3 ? (nextSizeByte & 0x1F) : (nextSizeByte & 0x3F);
            }

            propAddr += dataOffset + size;
        }

        return 0;
    }

    // Table scanning
    scanTable(value, tableAddr, length, form) {
        const fieldSize = form & 0x7F;
        const isWord = !(form & 0x80);

        for (let i = 0; i < length; i++) {
            const entryAddr = tableAddr + i * fieldSize;
            const entryValue = isWord ? this.readWord(entryAddr) : this.readByte(entryAddr);

            if (entryValue === value) {
                return entryAddr;
            }
        }

        return 0;
    }

    // Input handling
    read(textBuffer, parseBuffer, storeVar) {
        if (this.debugMode) {
            console.error(`[READ] textBuffer=0x${textBuffer.toString(16)}, parseBuffer=0x${parseBuffer.toString(16)}, storeVar=${storeVar}`);
        }

        this.running = false;

        // Set up the input handler - will be called when input arrives
        const self = this;
        this.inputCallback = function(input) {
            if (self.debugMode) {
                console.error(`[INPUT] Received: "${input}"`);
            }

            // Record room before command for transcript
            const roomBefore = self.transcriptEnabled ? self.getCurrentRoom() : null;

            // Store input in text buffer
            const maxLen = self.readByte(textBuffer);
            const actualLen = Math.min(input.length, maxLen);

            if (VERSION <= 4) {
                for (let i = 0; i < actualLen; i++) {
                    self.writeByte(textBuffer + 1 + i, input.toLowerCase().charCodeAt(i));
                }
                self.writeByte(textBuffer + 1 + actualLen, 0);
            } else {
                self.writeByte(textBuffer + 1, actualLen);
                for (let i = 0; i < actualLen; i++) {
                    self.writeByte(textBuffer + 2 + i, input.toLowerCase().charCodeAt(i));
                }
            }

            // Tokenize if parse buffer provided
            if (parseBuffer && parseBuffer !== 0) {
                self.tokenize(textBuffer, parseBuffer);
            }

            // For V5+, store the terminating character (13 = Enter/newline)
            if (storeVar !== null) {
                self.setVariable(storeVar, 13);
            }

            // Record transcript data after command is processed
            if (self.transcriptEnabled) {
                // Use a short delay to let the game process the command first
                setTimeout(() => {
                    const roomAfter = self.getCurrentRoom();
                    self.transcriptData.push({
                        command: input.toUpperCase(),
                        from_room: roomBefore,
                        to_room: roomAfter,
                        result: roomBefore !== roomAfter ? "moved" : "boring"
                    });
                    self.lastCommand = input.toUpperCase();
                    self.lastRoomNumber = roomAfter;
                }, 10);
            }

            // Clear the callback and continue execution
            self.inputCallback = null;
            self.running = true;
            setTimeout(() => self.run(), 0);
        };
    }

    // Single character input (read_char opcode)
    readChar(storeVar) {
        if (this.debugMode) {
            console.error(`[READ_CHAR] storeVar=${storeVar}`);
        }

        this.running = false;

        // Set up the input handler - will be called when input arrives
        const self = this;
        this.inputCallback = function(input) {
            if (self.debugMode) {
                console.error(`[READ_CHAR INPUT] Received: "${input}"`);
            }

            // Get the character code (first character of input, or 13 for empty/enter)
            let charCode;
            if (input.length === 0) {
                charCode = 13; // Enter/newline
            } else {
                charCode = input.charCodeAt(0);
            }

            // Store the character code
            self.setVariable(storeVar, charCode);

            // Clear the callback and continue execution
            self.inputCallback = null;
            self.running = true;
            setTimeout(() => self.run(), 0);
        };
    }

    // Dictionary and tokenization
    tokenize(textBuffer, parseBuffer) {
        // DEBUG: Dump parse buffer BEFORE tokenization
        if (this.debugMode) {
            console.error(`[TOKENIZE] Parse buffer BEFORE (at 0x${parseBuffer.toString(16)}):`);
            console.error(`[TOKENIZE] Text buffer at 0x${textBuffer.toString(16)}`);

            // Show what's currently in the parse buffer
            for (let i = 0; i < 3; i++) {
                const entryAddr = parseBuffer + 2 + i * 4;
                const addr = this.readWord(entryAddr);
                const len = this.readByte(entryAddr + 2);
                const pos = this.readByte(entryAddr + 3);
                console.error(`[TOKENIZE]   Entry ${i}: addr=0x${addr.toString(16)}, len=${len}, pos=${pos}`);
            }
        }

        // Simplified tokenization
        let text;
        if (VERSION <= 4) {
            text = "";
            let addr = textBuffer + 1;
            let ch = this.readByte(addr);
            while (ch !== 0) {
                text += String.fromCharCode(ch);
                addr++;
                ch = this.readByte(addr);
            }
        } else {
            const len = this.readByte(textBuffer + 1);
            text = "";
            for (let i = 0; i < len; i++) {
                text += String.fromCharCode(this.readByte(textBuffer + 2 + i));
            }
        }

        // Split into words
        const words = text.trim().split(/\s+/).filter(w => w.length > 0);
        const maxWords = this.readByte(parseBuffer);

        // Write number of words parsed
        this.writeByte(parseBuffer + 1, Math.min(words.length, maxWords));

        // Write each word entry
        let textPos = 0;  // Track position in original text
        for (let i = 0; i < Math.min(words.length, maxWords); i++) {
            const word = words[i];
            const dictAddr = this.lookupWord(word);

            if (this.debugMode) {
                console.error(`[TOKENIZE] Word ${i}: "${word}" -> dictAddr=0x${dictAddr.toString(16)}`);
            }

            // Find word position in text (1-indexed)
            const wordStart = text.indexOf(word, textPos);
            const position = wordStart + 1;  // 1-indexed position in text
            textPos = wordStart + word.length;

            // Write word entry: dict-addr (2 bytes), length (1 byte), position (1 byte)
            const entryAddr = parseBuffer + 2 + i * 4;
            this.writeWord(entryAddr, dictAddr);
            this.writeByte(entryAddr + 2, word.length);
            this.writeByte(entryAddr + 3, position);

            if (this.debugMode) {
                console.error(`[TOKENIZE]   Wrote to 0x${entryAddr.toString(16)}: addr=0x${dictAddr.toString(16)}, len=${word.length}, pos=${position}`);
            }
        }

        // DEBUG: Dump parse buffer contents
        if (this.debugMode) {
            console.error(`[TOKENIZE] Parse buffer dump (buffer starts at 0x${parseBuffer.toString(16)}):`);
            console.error(`[TOKENIZE]   Max words: ${this.readByte(parseBuffer)}`);
            console.error(`[TOKENIZE]   Num words: ${this.readByte(parseBuffer + 1)}`);
            const numWords = this.readByte(parseBuffer + 1);
            for (let i = 0; i < Math.max(numWords, 3); i++) {  // Show at least 3 entries
                const entryAddr = parseBuffer + 2 + i * 4;
                const addr = this.readWord(entryAddr);
                const len = this.readByte(entryAddr + 2);
                const pos = this.readByte(entryAddr + 3);
                console.error(`[TOKENIZE]   Entry ${i} at 0x${entryAddr.toString(16)}: addr=0x${addr.toString(16)}, len=${len}, pos=${pos}`);
            }
        }
    }

    lookupWord(word) {
        // Simplified dictionary lookup
        // Returns 0 if word not found
        const dict = DICTIONARY_ADDR;
        const numSeparators = this.readByte(dict);
        let addr = dict + 1 + numSeparators;

        const entryLength = this.readByte(addr);
        addr++;
        const numEntries = this.readWord(addr);
        addr += 2;

        // Encode the word using Z-string encoding
        const encoded = this.encodeWord(word);

        // Linear search through dictionary
        for (let i = 0; i < numEntries; i++) {
            const entryAddr = addr + i * entryLength;
            let match = true;

            for (let j = 0; j < Math.min(encoded.length, VERSION <= 3 ? 4 : 6); j++) {
                if (this.readByte(entryAddr + j) !== encoded[j]) {
                    match = false;
                    break;
                }
            }

            if (match) return entryAddr;
        }

        return 0;
    }

    encodeWord(word) {
        // Z-string encoding for dictionary words
        // V1-3 use 4 bytes (2 Z-chars per byte, 6 chars total)
        // V4+ use 6 bytes (9 chars total)
        const maxChars = VERSION <= 3 ? 6 : 9;
        const maxBytes = VERSION <= 3 ? 4 : 6;

        const alphabet = "abcdefghijklmnopqrstuvwxyz";
        const zchars = [];

        for (let i = 0; i < maxChars; i++) {
            if (i < word.length) {
                const ch = word[i].toLowerCase();
                const idx = alphabet.indexOf(ch);
                if (idx >= 0) {
                    zchars.push(idx + 6);  // A0 alphabet starts at 6
                } else {
                    zchars.push(5);  // Default to space character
                }
            } else {
                zchars.push(5);  // Pad with spaces
            }
        }

        // Pack Z-chars into bytes (3 Z-chars per 2-byte word)
        const bytes = [];
        for (let wordIdx = 0; wordIdx < maxBytes / 2; wordIdx++) {
            const z1 = zchars[wordIdx * 3] || 5;
            const z2 = zchars[wordIdx * 3 + 1] || 5;
            const z3 = zchars[wordIdx * 3 + 2] || 5;

            let word = (z1 << 10) | (z2 << 5) | z3;

            // Set top bit on last word only
            if (wordIdx === (maxBytes / 2) - 1) {
                word |= 0x8000;
            }

            bytes.push((word >> 8) & 0xFF);
            bytes.push(word & 0xFF);
        }

        return bytes;
    }
}

// Story Data (Base64 encoded)
const STORY_DATA_BASE64 = [
    "AwAAARZ6FnsNcwFSAQINcwAAMTgxMjA1AEIvxox1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAWkFQRpSlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAg",
    "ACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAA",
    "IAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAg",
    "ACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAAAAAAAAAAAABAAAAAEAAQACA1kDvQAHAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIWgiNCMAAAAAAAAAAAAAA//8AAAAAEf0SpRMfEi8AAAAA",
    "AAAAAAAAAAAAAAAAAAD//wAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAGACAAACDgABAAAKBAECJwAAAAAEAAACNgAAAAAKAAMCTwABAAAKAgACYQAAABoHAAACfwAO",
    "gAAAAAYCiwAAAAAAAAACmgAAAAAAAAACngf///8AAAUCogAAAAAAAAwCqgAAAAALAAACrgBmAAAA",
    "AAACugACAAAAAAACxAZiRkYgHuZjADaUwKUy//4wLkZlDx4QBQAEERFQ0F6UyKUdBTEvBwADSVhg",
    "zKilEv0wLzXlD4AO0RB1Dn0kLhUABBF0eVcAh5rlHwUxLuAkLdgACRF0eVcCiwMtKARSqlzAEbTr",
    "Cj8vqB4EHAIxL1sAAiI0mgUlDhskLcoAAfqaKv//ZQ95D4ckLbYAAZSlAAGUpQADESZeE6sYAAGU",
    "pQACT1KdVyUNiCQTSAAEZbRhQGWuzZgAAmWm5KUkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOwAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7AAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADsAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdc",
    "B4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAezB9sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAgKCDIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAkNCUAAAAlzCdcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAA7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK3wsSAAALRQupAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAABQAAAAAAAAAAAAADLC4iBwClFkWUpQTwABZllKUE7wAWc+pHgAEAFnmqMUHF",
    "ABcFlKUAAAAXJZSlBO4AGKWUpQT/ABj06yUI9wAZhrplQekAGjGUpQT7ABpllKUE/gAaaZSlBP0A",
    "Gn6UpQT8ABsllKUI+wAbOZkQQeAAHubjBSL+AB7qmgVB4AAe7qllQcsAH1fMpUHbAB9ZlKUE+AAg",
    "19/FQeMAIarwpUHnACIuyOVB1QAiNJoFgAEAIjThRUHvACKT4clB8gAik+VSQfIAJKWUpRj8FCTT",
    "oUVB0wAlWOb0QeAAJVvTV0HnACaLrKVB9AAmk5SlQfUAJpzMpRj8FCbmsKVB4wAm7s4FQeYAJvTU",
    "pUH4ACdY5KWAAQAopZSlEx0AKNjkpRMdACjZlKVB5wAqVefFQeEAKnmq5UH9ACtq38UE+gArat/Z",
    "BPkAK6bJ00H2ACuoqrkE9wAt0cSlQeIALi7UpUHrAC400uWAAQAwpZSlQekAMVmUpUH8ADHbqKVB",
    "3wAyhZSlQf4AMuacpUH6ADNR1KVB5wA007ClQfcANVeUpYABADXSlKWAAQA12ZSlQeAANpTApYAB",
    "ADillKVI+PM6ZZSlGP8XOniq+UH3ADp4uSoY/xc6edClGP8XOnuqeUj48zsllKWAAQA/UtSlQdcA",
    "QdHEpUHgAESllKVB/wBGiMClQe4ARpTApUH/AElFlKWAAQBJWODMgAEAS9iqK4ABAEyllKUTHwBN",
    "RZSlExsAToWUpUHRAE6X5aUTHwBOl+WqExsATpflvBMaAE6You5BxwBPhZSlExoAUWWUpQT2AFFr",
    "lKUI+QBSZZSlCPoAUmqUpQT1AFJ50KUI+gBSleClBPEAUqrMpUHwAFNZlKUTFgBTWeHJExYAVUyU",
    "pYABAFVX6wpB6ABVyMClQfkAViahRUH3AFb0zppBxgBXUcSlQeMAV1i0pUHkAFdZlKVB9wBbTuSl",
    "QfsAXUakpUHoAF1Y5NdBzABdWOaXQc0AXobjJUHbAF9HlKVB2gBgpZSlEx4AYNuopUHOAGDcp1iA",
    "AQBhBt1lQecAYRebkSL9AGEXurlByABhRZSlExkAYUbdDUHZAGG07UVB5ABhuuSlQe8AYdOwpUHU",
    "AGJGxiUi/wBiRuGlQeAAYkrGJUHlAGKa5aUTHgBimuWqExkAYprlvBMYAGNVqudBygBjhZSlExgA",
    "Y47IpUHWAGOO5Q1B6wBk0KilQfoAZVHEpUHeAGWqlKUE9ABlqsilgAEAZarMpQTzAGWuzgVB8QBl",
    "t9NMCP4AZbfThUHcAGW36KUI/gBmhZSlCPUAZoyyKkHrAGaXoaVB2wBmmOClQdwAZubPCEHIAGdX",
    "zKVB7ABopZSlGP0Vammq5Qj0AGpp0KVE8s9qcdEQQe0Aanii7kHHAGp8qNdB9ABqpZSlGP0VbVee",
    "mEHJAG1X4dRB0ABwpZSlExwAcM7kpUHqAHDQqKVB2ABw0cClQf4AcNuopUHdAHFG3KVB9QBxWOSl",
    "ExwAcdm0pQj2AHSllKVB9gB4pZSlQdIAeNPApUHjAHlYlKVB0gB8pZSlQeoAAAwPLAD/EY0A/Q5h",
    "APwRJAD+D9QA+g3VAPsPzQD5D0gA+A2rAPcR0wD2ETkA9RFqAPQTmRO6E9MT3BPtE/YUDxQgFCkU",
    "WhRjFGwUdRR+FIcUkBSZFKIUqxS0FNUU3hTnFPAU+RUCFQsVFBUdFSYVLxU4FUEVUhVbFWwVfRWG",
    "FY8VmBWxFboVwxXUFd0V5hXvFfgWARYKFhMWHBYlFi4WNxZAFlkWYhZrIS0lcCWsJckkhiURJlsl",
    "TimEJgQn/Cl5KCMosSnjKg4qUSp+KoMrJitOK3oqiCqiKvwplivIK94rkSupK9Yr2ivqLCAsYix/",
    "LI8slCwDLPAs4SzLLKUsoSyYLKoswivAK8Qpuy0ILRgtKi0zLUstZS1WLXItlg7lLIwAACEcIRwh",
    "HAAAAAAAAAAAAAAAACfvAAAoESigAAAAAAAAAAAAAAAAAAAAAAAAAAAhHAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAALGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAs",
    "ZwQB/wAZAPDwAwH0ABoA8PACAfsAAAD08AEAAAAAAPDwAAMB/gAfACDwBQH/AB8AIPAFAQAAAADw",
    "8AQBAQAAHwAg8AUCAQAAHgA08AYB/wAfACDwBQEAAAAAAPDwBwMB+AAdAPDwCQH5ABsAwvAIAQAA",
    "HgA08AYCAgD9Hh008AYB/QAeADTwBgEBAAAAAMbwCgYCAP8AGczwDQL9+gAazPAMAgD6ABrM8AwB",
    "+gAcAArwCwIA/AAdxvAKAfwAAADG8AoBAQAAAAD08AEBAQAAHAAK8AsBAQAAGwDC8AgBAAAAAADw",
    "8AkBAQAAAADw8A4BAfcAAADw8A4BAQAAGADw8A8BAQAAFwDw8BABAgD2GBbwwhEBAgD2FRbwwhIE",
    "AgD5FB3w8BQB+QAUAPDwFAIA+hQd8PATAfoAFADw8BMBAQAAFADw8BUBAAAAAADw8BYBAAAAAADw",
    "8BcBAQAAEwD48BgBAQAAEgD68BkBAQAAAADw8BoBAQAAAADw8BsBAQAAAADw8BwBAQAAAADw8B0B",
    "AQAAGQDw8B4BAQAAGQDw8B8BAQAAEQDw8CACAgAAEADwwiICAPUAEMLwIQECAPcQAPDwIwIBAAAA",
    "AMrwJQAAAAAA8PAkAgIA+wARyjAmAgD1ABDKMCEBAQAAAADw8CcBAQAAAADw8CgBAQAAGQDw8AMD",
    "AgD9EB3w8CkB/QAQAPDwKQEAABAA8PApAQAAAAAA8PAqAQAAAAAA8PArAgEAAAAA8PAsAAAAAADw",
    "8CwBAAAAAADw8C0BAAAAAADw8C4BAAAAAADw8C8BAAAAAADw8DABAAAAAADw8DEBAAAAAADw8DIB",
    "AAAAAADw8DMBAAAAAADw8DQBAAAAAADw8DUBAAAAAADw8DYBAAAAAADw8DcBAAAAAADw8DgDAfkA",
    "HQDw8DoB+gAdAPDwOQAAAAAA8PA5AQAAAAAA8PA6AQAAAAAA8PA7AQEAABAA8PA8AAIuUi6QALu7",
    "shG6Xv46bAMtXpoxoGWqAuY6eHFVZAROmypHKuBNzDclTB5TRWLqAZEZIGaAYUoDLSgHXcw3IEXM",
    "NzgCiwMtKARSqlzAEbRrChZAEdkXGAMaXrc7Dk2AZaZkGTVXKAZdUxcZAlRdQFVUVioAx1NZAPpk",
    "swGqeLMDjRsgJoB6mgFdVUhkDkwGAQ0o1QEqSoAw0iiyFkXItbu74D8puwC7DRAFLgcQ4D8hLQDg",
    "Pw8UALoABAAAAAD//wAAoAHAUAEEBGcEAlpCAwDBSQQDAGEAA0hQAQUEqwRQAQYEqwQNBACrBAAC",
    "AAAAAFYBAgCWAG8aAAKrAgADAAAAAAAAVgEEAJUAcBoAAlYBBABwGgAAdAIAAFUAAQNwGQIA5b8A",
    "JQIDweh/AIz/8QEAAOKXAQAA4pcBAQDilwEGALAAAwAAAAAAAFABAAPimwIAAzYEAwBPAgEATwEB",
    "AOAqFTIAAAAAUAEBA+KbAgEDNgQDAE8CAgBPAQIA4CoVMgAAAABQAQYA4psCBgCwAAEAAOGbAQAi",
    "4ZsBASXhmwECJuGbAQMnTwEEAOApFTIpADMATwEFAOApFTIqADMA4ZsBBi9PAQgA4CscmRoAAE8B",
    "BwDgKxysGQAA4ZsBCRvimwEUIOKbARUh4psBFiPimwEXJKAfSOh/AIwABei/HeKbARgA4psBGRyw",
    "AwAAAAAAAC0DG08BACJPAQElTwECJk8BAydPAQQA4CkVMgApMwBPAQUA4CkVMgAqMwBPAQYvTwEI",
    "AOArHJkAGgBPAQcA4CscrAAZAE8BCRtQARQgUAEVIVABFiNQARckUAEYH1ABGRygH8stHR8NHwGM",
    "ACFCJAHJUCkAAqACSA0dAIwAEEECAUlQKQEdjAAFDR0NQiQCyVAqAAKgAkgNHgCMABBBAgFJUCoB",
    "HowABQ0eDcGnGwMAwKMbEOA/GkYWqxYHAAAAAAAAAAAAAAAAAABCIAHr4B8LsAEA4C8VQQAAoABL",
    "4B8U1AEAoADT4BEVWwEIAwEHVCABAGEHAMSbAEEcPFItKC2gKMzNTxkF/c1PGgZhx48sQABdx48s",
    "IABJ6D8HrIwABug/B1XgCwvcCAMAAJsDx48sIABILQMqjAAFLQMpUAMAAg0BAC0FK9AfCAMABg0H",
    "AXADBwSgBtnQHwgDAADPHwgDAQDgKhv3AAAEAKAA4NAfCAMBAM8fCAMCAOAqG/cAAAQAoABJlQHi",
    "qwUBBCUHAj/B4psFAAGgAUgNBACMAENBAQFJUAUBBIwAONAfCAMGAEEAAmvnvwEAcAUABOKbBQEE",
    "4pcFAAENAQGyFMLspeAvIqoEALIUwvSlu4wABQ0EDcePLCAASy0qKy0eBIwACC0pKy0dBC0rA6AB",
    "XrITLRsgcNhMuGQGTBRXLlJlyKWNLjy7DSgAmwJBAQHM0B8IAwYAQQABRJsEYgECY7ITLRsgTNde",
    "nCkgOyAmnEwGAi5nMSiygKXgLxvoBQCbAbITLRsgJclMuGQTGvdTgDsgJpxMBmQGRiXIpY0uPLsN",
    "KACbAgAIAAAAAAAAAAAAAAAAAAAAAE8BAAdPAQEIUAIAA1ACAQRPAgEFTwICBqAH9qAIgHVBAwFK",
    "YQcF0UEDAcDgKhyJBQMHAKAAwEEEAUphCAbRQQQBwOAqHHkGBAgAoADAmwOgCIBBQQQBSmEIBtFB",
    "BAHP4CoceQYECACgAMSbAuAlC5cIIAIH6L8HoADAQQMBSmEHBcFBAwHA4CociQUDBwCgAMCwoAfA",
    "QQMBSmEHBcFBAwHA4CociQUDBwCgAMCwAwAAAAAAAE8CAANUAgICBAMAwOArDXsBAgCgAMSrAlQC",
    "CALovwKM/+gAAQAATwEDAONbDgQALS4Qmw4AAQAA4pcrAAHimysBAeArDncBKwC4AAQAAAAAAAAA",
    "AKIBBF2gAsrgrwIEAKAAzZUD4qsrAwRBAzLHoQQEv+fimysAA6ADwUEDAUlQKwEDjAAFDQMN4CsO",
    "dwMrALgCAAAAAMGnARsNwEoBEMBKAQ3A4C8OMwIAuAEAAOAhFTIBDJczALAAAgAAAABhARvAQQEN",
    "xkoBDUDgLw5GAgC4AQAA4CEVMgEMyjMAsAACAAAAAGEBG8BKARBASgELwEoBDcDgLw5bAgC4AQAA",
    "4CEVMgEM/TMAsAACAAAAAGEBG8BKARBASgELQEoBDcDgLw5wAgC4AQAA4CEVMgENMDMAsAAFAAAA",
    "AAAAAAAAAMGXAQAKwFIBCAOgA9+kAwBXAAIAVQABBA0FAG8DBQDgrwACACUFBD/0sOArDiYBAgDg",
    "Kw46AQIA4CsOTQECAOArDmIBAgC4AwAAAAAAAMGPAQ9PTuAJFTIMlwIzAIwANcGPAREPTuAJFTIM",
    "ygIzAIwAI8GPAQ8QTuAJFTIM/QIzAIwAEcGPAQ8JQOAJFTINMAIzAFACAAOgA2KyE9RoDRtqTLhk",
    "GClTANN4BeSlpwGyFyB5WZZFu4v//+AvGdECAKAARYv//0EDAUdQAgEAuJsNALIRxGQSKNPgBeAF",
    "Iz0MlwCYALKWRbuyEyQ0ihJASUbPAOAFIz0MygCYALKWRbuyEaQ4kgJKGniApeAFIz0M/QCYALKW",
    "RbuyEaQolwJKGniApeAFIz0NMACYALOWRQEAAOA/DzwB6L8BoAD+4Coc2BwdHgHBlRwHMRbswZUc",
    "MzQJ5cGVHDI3Nt7BlRw4FznXwZUcOjs80FEQBADgnwACAeA/IDwBoxsQ6H8AjP+1DAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAC0HGy0IEC0JFg0BAA0CAA0DAA0EAEIoAEUNKACgKOLNTxkF/c1PGgZh",
    "QSgBSA0oAIwAH0EXANtBHDzXu4wAEw0bB6MbEOA/GkYW4B8cwQEAUBoBIKAgTLIWRciyuw0oALGg",
    "KABuoCCAauAfC7ABAMGPAA/pAF1BIAJp0B8HTwQAoADP4B8RQwIAUBoBIIwAQ7ISdGWuTYBmgCKX",
    "XUjksruxQSABT7IR2RcYAJQSBcilu7GyE9RoCBpgUnF4CFL3KRkCkygcUukA2QDAZdKosruxDQYA",
    "4hcHTwQA4hcHTwUA4RsHTwAsoCgAisGPGQSr3OAjHKwZBKsA4CMcmRoFDwDNTxkEq81PGgUPoCyA",
    "V+A/DKAFQQUAyy0bBy0QCC0WCUEFAcBBBQJGDSwAsUEFA19QJwElx48sIABPUCcCJg0kAg0GAYwA",
    "Gw0kAYwAFUEFBFHHjywgAEgNBgKMAAUNBgENLACgBU7gPxLqAKAAxlAaASDBlwUDBIIVDSEADSQA",
    "4A8L0gdVAOAPC9IHrAANJQANJgAtCiigCkUNCgFjCiBIDSgAjAFd4C8LsAoLoAt84C8U1AoAoADK",
    "zU8LDYigC2vgLxEtCgANKACyEcAmkxcZAhNTgGWqA5RdIJcl4C8LuQoAshclyKW7scGDCxEWDXpj",
    "VAoBKGMoIEgNKACMAQTgIxysGQX9AOAjHJkaBmEAjADxoCFg4CULlwtAAQygDNWgA8ZBDP5OLSIL",
    "LSMKLSEMjADLoANcwZchAP5W4CULlwsQAwKgAsstAwItBAqMAK7gJQuXCwgAAqAC3aABS6AlSC0l",
    "AowAl0EBAQCSoCYAji0mAowAiOAvFUELAKAAgE+VAUEBAU3gIxVbCgdVAowAMUEBAk3gIxVbCges",
    "AowAIg0oALITLRsgYVNlUyFANNgDNFASGn4Chz1IZwXIpbuxoALILQoCjP7VDSgAseAvES0KAA0o",
    "ALIRwCXJTLhkCnaqIyBlqgOUXSCXJeAvC7kKALIXIGWqXUXIpbuxlQqM/p0tJAGgA+nBlyEA/mOg",
    "AWCgJV2gJloNHwENHAQtHQMNHgBBHBfB4A8MAgjzALCgIVwNKACyEy0bIGFTZVMhQDTYAnQDalzl",
    "yKW7saAD/eAvES0EAA0oALIRwCaTFxkDUyVXYyZNIHGmZAXkpeAvC7kEALIXIDsAJo5NgDpgZaZk",
    "GCp5KmiosruxDR8AoAVX4D8WeACgAMvgLxf5BgCgAFcNKACxQgYCT+AvF/kGAKAARg0oALFBHBfJ",
    "4A8MAgjzAOArDncdKQCwAAEAAMGPGgUP0uAjHKwZBKsA4CMcmRoFDwDiGwdPBSjhGwdPARviGwdP",
    "BAGwDQAAAAAAAAAAAAAAAAAAAAAAAAAABQ8EqwAA4C8LsAEC0B8HTwQDVgMCAJYA4asLAAJWAQQA",
    "lQBwGgAEVgEEAHAaAAVWAwQAlQBwCwAGVgMEAHALAAdWAwQA4qsLAAViBQdrdAwGAHQZBADgKhUy",
    "AAAFAHQGBwBVAAEJVAUBDeKnDA0gJQ0JP/iMAHJjBQcAbeAvHLMMCJUIdQUHCnQICgBCAGTKNWQK",
    "AFUAAQgtDQhwDA0AdA0KAOKrDAAAJA0GP/B0DAYAdBkEAOAqFTIAAAUAUAsBCWIBCWRUAQENVg0E",
    "AJUAcAsAAHQACgBWDQQAlQDiqwsAACUNCT/kLRkMLRoLzx8HTwAs0B8HTwUozx8HTwEb4hcHTwQA",
    "4hcHTwUA4RcHTwAAsAALAAAAAAAAAAAAAAAAAAAAAAUPBKsAAFYBAgCWAOGrCQAC808DAvWnAvM/",
    "//1WAQQAlQBwCQADVgEEAHAJAATPHwL1AAVWAQQA4qsJAAViBQRfdAMEAFUAAQd0AwUAVAABC+Kn",
    "CgsgJQsHP/iMAGJjBQQAXeAvHLMKBpUGdQUECHQGCABCAGTKNWQIAFUAAQYtCwZwCgsAdAsIAOKr",
    "CgAAJAsDP/BQCQEHYgEHZFQBAQtWCwQAlQBwCQAAdAAIAFYLBACVAOKrCQAAJQsHP+R0CgMA1B8C",
    "9QIA4CoVMgAABQCwDAAAAAAFDwSrAAAAAAAAAAAAAAAAAAAAAFADAQVCAQFIDQEBjAAKYwEFRlQF",
    "AQHzTwMC9acC8z///c8fAvUACkEFO0UNBTpjAQX1VgECBlYFAgxvAwwAVAwCAOGrAwAAVQwBAG8D",
    "AABUDAEA4asDAABVDAIMYgwGP9tjAQVP4C8cswQAVAABCIwADFYBBACVAHADAAhWAQIAlgDhqwMA",
    "AlYBBADiqwMAClYBBACVAOKrAwAIVAUBAOKbAwEAYwEFgF3gLxyzBAdUCgELlQd0BwsAQgBkyjVk",
    "CwBVAAEHLQwHcAQMAHQMCwDiqwQAACQMCD/wVAUBCWIBCWRUAQEMVgwEAJUAcAMAAHQACwBWDAQA",
    "lQDiqwMAACUMCT/kdAQIANQfAvUCAOAqFTIAAAoAYwEFSVUIAQCMAAZ0CAoA4qcEACCwAgAAAABC",
    "IALA4B8LsAEA4C8VQQAAoACATuARFVsBCAMBAaABgEFiASB94C8LsAEAwY8ADYFxVAEBAOAvC7AA",
    "AuAnC5cCQACgAEzgJwuXAhAAoADT4CMR1wENegDgExJIAQ2PALDgHwuwAQDBjwARAUDgERVbAggD",
    "AQGgAcBiASBA4C8LsAEAwY8AETlAVAEBAOAvC7AAAuAnC5cCQACgAEzgJwuXAhAAoADA4CMR1wEN",
    "egDgExHXAQ2PALAAQRwBAwDmvy+yAdiApaAvSrJ90aGljALQQS8BYrJlqgI0TVE5WGQTakcq4GWm",
    "ZB5TRWIxAVsq4KaFjAKsQS8CYrJlqgI0TVE5WGQTakcq4GHTIUBlqgJ6SOpcBaSljAKIQS8DULIY",
    "EhmOIBNqR6rljAJ2QS8EAEayZaoCk0fAT1IdVwMtGyA02AMtKBgaSgJ6SOpcFCwINNcZGSr4ANgB",
    "2WAbGjooHDVTA5c7OSpgU1kB0wCKTZG7DYwCLUEvBXKyZaoCk0fAT1IdVwMtGyVjAFTXZBQsElLq",
    "Ay0aYFJqAqY64FFgZ45MFV3SqwWMAflBLwZYsmWqAxIaMSsZAqpdaiMgT1KdV4wB30EvB2SyGAUk",
    "sRYlNAs6MgEuXUhlSQD+AIkbbiQELdMhqtyljAG5QS8IarJlqgFuXxkCekjqXBk02RcYAmo7LSrg",
    "Vu5JQE6XAwpJ1V3SqKWMAY1BLwlwshgFKKgVBUQGTdIbKiQLOjIDlzs5KmAaaQEuXUhlSQD+AJg0",
    "0ygEGRCq5YwBW0EvCnSyGAUksRXlRAs6MgOXOzkqZUwVXolpCiSzANMkCTrqIyokB3gEHiZBQBFJ",
    "cNenBYwBJUEvKn6yZaoAhk8cKuBmgGWqAJpHLkjZKARbSmMuUmBRYBIuLUVMBGWqAJpN2yr4KLMA",
    "0yQEK2pf2TXTsKWMAOXBjy8GwQBSshgbKv4B02VXKxk6bAJ6SOpcpgdgOyA7AGWqAxIaMSsZAnpI",
    "6lwKdrcrGDjxKAZgGTVAY1ICiwM8UAho6mAOTBlygCXLLVcqeQOG+wWMAI7Bjy8wOVqyZaoBFEju",
    "TNk6kwKTAl4COjGGsUWMAHDBgy+AAH//bLJlqoClQi8ASLLJ04wABbLI3bI6WkgFJK4XhzsgYcxN",
    "SQHTZUyq5YwAPrJlqgJ6SOpcBys8KVOApUMvAFhVLwEA5r8AsgDTpAVULwEA5r8AjAAVVC8BAOa/",
    "ALIA06QFVS8BAOa/ALMWYB9ZAy0bJWMATpkB0laXZNNkFzmNZBNThcilwY8iEPpAwZcvBQpA4B8c",
    "2BYAuAAGAAAAAAAAAAAAAAAAVgEEAJUAcBoAAlYBBABwGgAAdAIAAFUAAQOgA8BwGQIFQQUtTQ0G",
    "ASUCA8BwGQIFQgUwwEMFOcDBjwQMzFVBBThRoAbOYQIDSs1PBIAAjAAwwo8EDMzMw48EDMzAQwU3",
    "wFUFMABWBAoAdAAABCUCA8lwGQIFjP+6oAbGNQAEBC0vBFYCAgCWAOGjGgANiJsMAAQAAAAAAAAA",
    "AJYDDQQAbwEEAOGrAgQAJQQDP/SwAAQAAAAAAAAAAJYDDQQAcAEEAOKrAgQAJQQDP/SwAAEAAMGA",
    "AQ2kDcARCMHBgAENuQ6nDq7BwYMBDc4P28HgJwuXASAAoABB4CcLlwGAAKAAQbENAAAAAAAAAAAA",
    "AAAAAAAAAAAAAAAAAAAAAABPAgEE4pcCAQBjASCB5+AvC7ABBqAGfOAvFNQBAKAAys1PBg2IoAZr",
    "oANA4C8RLQEAshHAJpMXGQITU4BlqgOUXSCXJeAvC7kBALIXJcilu7HBgwYRFg16gZugC3TBgwYN",
    "/w68bKAJRaAK1OGbBAAJ4ZsEAQoNCgAtCQqVBeKbAgAFDQsBTwICBA0FAIwBYcGABg25DqcOrsvB",
    "gwYNzg/bAEGgCEigCUWgCt+gA0CyE9RoCBplYyBrCoC5pwayFyBlql1FyKW7scGABg25DqcOrkgN",
    "CAGMAAUNCAItDAGMAQ/gJQuXBiACB+i/B6AAgGugCgEBLQwB4CcLlwaAAKAA6mEBIOBUAQEA4C8L",
    "sAAN4CcLlw0gAKAAUuAnC5cNgACgAEgtCgaMAMdBBQpkoANAshMtGyBVtxsKAkpPLlJ4AzRQEhp+",
    "Aoc9SGcFyKW7saAJAJ0tCQeMAJfgJwuXBoAAoAD1oAoAjkEFCmSgA0CyEy0bIFW3GwoCSk8uUngD",
    "NFASGn4Chz1IZwXIpbuxLQoGLQwBjABawYMGDccNgWKgCUagCoBL4ZsEAAnhmwQBCg0KAC0JClQE",
    "BASVBYwAMsGPBg/GX2IBIFtUAQEA4C8LsAAA4C8VQQAAoADIDQoAjAAP4CcLlwYEAKAAyi0MAZUB",
    "jP4YoAlFoArO4ZsEAAnhmwQBCpUFoAvK4psCAQWMAAfimwIABeKbAgYIVAwBALgFAAAAAAAAAAAA",
    "ADX/IQBvNwABUAEAApUBzU8F/BkEAgDg4C8WqwEDoAPQYwMFTC0FAy0EAUMDAMlUAQgBjP/goATK",
    "UAQHHC0nBLCyEcAmkxcZA1MlV2MmTSBlpmQYKnkqaKiyu7EFAAAAAAAAAAAAAFABAAJQAQEDUAEC",
    "BGEkAkphJQNGYSYEwWIkAkDBpyUDAEDBpyYEAEBBJAFIoAPFoCXAQgIB06AkUKAlTaADylABAwBB",
    "AB3AQQICUKAmTaAEylABBABBAB3AdSQCBaAlSaADxlUFAgVBAgJKoCZHoARElgWrBQEAAKAB06Ib",
    "AMLhGw1jAADhGw1jARuw4D8X1AC4AAEAAKAB06IQAMLhGw1jAADhGw1jARCw4D8X1AC4AAIAAAAA",
    "oAHTkggAwuEbDWMAAOEXDWMBCLDgPxfUAqACwOArHBsCEACgAMSrAuh/AIz/6AABAACgAdOSCQDC",
    "4RsNYwAA4RcNYwEJsOA/F9QAuAABAACgAdOSCwDC4RsNYwAA4RcNYwELsOA/F9QAuAACAAAAAMEv",
    "//8BduEXDWcABZUC4SMNZwIW65UC4SMNZwIW+pUC4SMNZwIXCZUC4SMNZwIXI5UC4SMNZwIXMrBH",
    "AYDGRwFAS5UC4SMNZwIW60cBEMZHASBdlQLhIw1nAhb6lQLhIw1nAhcjlQLhIw1nAhcJ4RsNZwAC",
    "sAMAAAAAAADPHw1nAAKgFklHMgFFDQMBoAPIDTABjAAFDTAADTEAJTECwKADzOAfIWAIAKAAv/HP",
    "Lw1nMQDgnwABAaABycGPAf//QbHofwCM/9YFAAAAAAAAAAAAAM8fDWcAA6AWSUcyAUUNBQFjMQPA",
    "oAXL4B8hYAgAoADlzy8NZzEBoAHcoATK4J8BAQCgANHgvwECoALKwY8C///AqwKVMQ0EAei/BIz/",
    "xAAEAAAAAAAAAADPHw1jAAGgAcDPHw1jAQOiAQJL4C8aaAEAoABfoQEC26MBBMGnBAMASA0CAIwA",
    "DKEEAsijBASM/+zhGw1jAAKrAQQAAAAAAAAAAFAnAARQJwUDQgQBSA0dAIwAgEIBAQB7UCcDAkIk",
    "AXJQJwEA4CoZ+AIDAB2gHVPgPximAM1PLMAADSMALS0osQ0kAeKbKQEd4pcpAAGMAD/QHwdVAABB",
    "AAHIDR0AjAATzx8HVQEATwABAOArDqAAKR2gHVXWjwIBAABoAAMA4AoadAdVKQAdwY8d///AoB1G",
    "saAd2qAfV+ApGPkdAwAAoADA4CsZMCkDAKAAwFAnBgNCBAJIDR4AjACAQgECAHtQJwQCQiQCclAn",
    "AgDgKhn4AgMAHqAeU+A/GKYAzU8s4AANIwAtLSixDSQC4psqAR7ilyoAAYwAP9AfB6wAAEEAAcgN",
    "HgCMABPPHwesAQBPAAEA4CsOoAAqHqAeVdaPAgEAAGgAAwDgChp0B6wqAB7Bjx7//8CgHkaxoB7B",
    "4CkY+R4DAQCgAMDgKxkwKgMAoABBsQAEAAAAAAAAAABQJwABUCcBAlAnAgOgHcygH0lQJwQEjAAG",
    "UCcDBEEcBFGgHU6yE405DQOG+KWMABNBBBBKshON0kWMAAeyE42bJbIBNAPUaByaeUEbB8uygKXg",
    "LyKqGwCyAzSApeA/GPIAoALNsoCl4C8aLQIApwCgHdygH1mygKXgLyKqHQCgA82ygKXgLxotAwCn",
    "ALOWpQCgI8ngLwu5IwC4pyKwAwAAAAAAAEEBDUFHAgTBQRw8ZLIT1GgIGmBScXgGJTcrGAKTKBUq",
    "+FJgGyAYGTpKlkWMADayE9RoCBplYyBrCgJaRy5WKoCloAPFsrplsiXXKRkChz1IZwBx2TQF5KXg",
    "PxjyALIXJciluw0oALEIAAAAAAAAAAAAAAAAAAAAAFABAANHAggAbw0IAXABCADgLxnCAACgAIBZ",
    "shTCbyZB07AF4CEjPQEZwhgGshTC9KW7cAEIBeAvGcIFAKAA7OAnJl8FAQCgAGJDBgFXLQcYDRgB",
    "qgWyl6DgLyZfBQAtGAex4C8mXwUAsSUIAz/GjAAHJQgDP5hHAgJBDQgBcAEIAOAvGcoAAKAA4rIT",
    "1GgGXVMXGQG0RS7NgOAhIz0BGco4ALKWRbsNKACxJQgDP9CwAAIAAAAARwIIceAvGcIBAKAA6LIU",
    "wm8mQdOwBeAvIqoBALIUwvSlu+AnJl8BAQCgAEngLyZfAQCxRwICQeAvGcoBAKAAwbIT1GgGXVMX",
    "GQG0RS7NgOAvIqoBALKWRbsNKACxAQAAZgEbwEoBHkBKAQZBsQEAAOAvH4YBAKAAwbEAAwAAAAAA",
    "AFABAAKgAsENAwFwAQMA4C8fSAAAoABd4CEjPQEZ8VoAsgJ0AjRNilwNKuqWRbsNKACxJQMCP9Ww",
    "AAEAAOAvH0gBAKAAwbEABgAAAAAAAAAAAAAAAEEBHUSbCkEcBMDgLxdBAgANMgHgPxd+AKAA4OA/",
    "F6cGoAbYYQYbv/WgAcdqBgE/7aAEQC0EBoz/5KAEwLIUwuyl4C8aLQMFoAXHpwWygKXgLyKqBACy",
    "FML0pburBAMAAAAAAABPNAAAVgACAFUAAQINAwFUAwEAbzQAAGEAAUdvNAMAuFQDAgNjAwI/6LEA",
    "AQAAShAPweEXDWcABOETDWcBFvrhEw1nAhbr4RMNZwMXI+ETDWcEFwkNMgDgPxd+AKAAwOA/F6cB",
    "oAHASgEPP/WrAQABAABKARrBSgEZQEoBF8FKAQfBSgEYQbEPAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
    "AAAAAAAAAAAAUAEABVABAQZQAQYILQoDoAhGSAPwAw0JAKAFAHLgLxdBAwANMgHgPxd+AKAAgaXg",
    "PxenDqAOgZzPLw1nMQDBgwAXMhcjv+rgLxvGDgCgAL/goAbWUAEBAE8BAgDgKhv3AAAOAKAAP8lC",
    "CTLZshTCbzRQEhp+Aoc9SGcFUKaLpbuMAVGVCeKrAgkOjP+kDQ4BVQ4BADYEAABPAQEAdAAABw0E",
    "AC0LCQ0MAeAvF0EDAA0yAeA/F34AoACAaeA/F6cPoA+AYEoPCr/04CscJAcPDaANv+liDQy/5A0E",
    "AWMNDEgtCQstDA2gBtZQAQEATwECAOAqG/cAAA8AoAA/wEIJMtmyFMJvNFASGn4Chz1IZwVQpoul",
    "u4wADJUJ4qsCCQ+M/5ugBAClRwMQAFNREAcNoA2AS+ArDdoHDQSgBIBEoAbVUAEBAE8BAgDgKhwJ",
    "AAAEAKAAakIJMtmyFMJvNFASGn4Chz1IZwVQpoulu4wAZZUJ4C8N7wQA4qsCCQCgBABLwY8D///P",
    "zU8D///NTwr//4z+hUEwAV+yEdkXGAM0UAka8AM0AwooBk/ZNdMwDSrqlkW7sbIT1GgJUmVjIGFK",
    "Ay0bIDVXqLK7sUIJMkclDgU+wOKbAgAJoAluSAPwBGEDBF2yEy0q6gDXKBNSagDZANFEBmzORMdF",
    "RdClu7EtAwQtCgSM/hJBCQFHUAIBALhBCAHGQwUBRJsNQQgCZ+e/CQBwAgAE4psCAQTilwIAAbIU",
    "wuyl4C8iqgQAshTC9KW7qwRhAwrILQMKjP3M4C8b0wIEoATO4psCAQTilwIAAasE4C8b6AIAwY8B",
    "B1VOzU8sgAANIwAtLSixzU8soAANIwAtLSixAQAASgEKwGEBG8DBlxwGCkFKAR7BSgEGwbEFAAAA",
    "AAAAAAAAAFABAAINBQFwAQUAUQAGA+CvAwEEoATEqwQlBQI/67EBAACyE405DQE0A9RoEijTlmDg",
    "JSM9AQA4ALOWpQAEAAAAAAAAAACgAsANBAHgKxwkAQMAoABBVAEEASUEAj/vsQAEAAAAAAAAAACg",
    "AsANBAHgKw17AQMAoABBVAEEASUEAj/vsQACAAAAAEoBCsDgJhxqAg8BALgEAAAAAAAAAABPAQAD",
    "TwEBBKAD3qAEgETgJhxqAhIDAKAAwOAmHFkCBQQAoADAmwOgBOngJhxZAgUEAKAAxJsC4CULlwQg",
    "AgPovwOgAMDgJhxqAhIDAKAAwLCgA8DgJhxqAhIDAKAAwLAABQAAAAAAAAAAAAByAQIEoATApAQA",
    "VwACAOAqHHkEAAMAuAUAAAAAAAAAAAAAcgECBKAEwKQEAOAqHIkEAAMAuAQAAAAAAAAAAKACwJYC",
    "DQQAbwEEAGEAA8ElBAI/9bEABAAAAAAAAAAAoALAlgINBABwAQQAYQADwSUEAj/1sQADAAAAAAAA",
    "UAEBA+KbAgEDNgIDAFQCAgBUAQIA4CoVIwAAAAC4AAIAAAAA4CkVIwECMgC4AgAAAAANAgGVAnAB",
    "AgCgAEdVAgIAuOh/AIz/7gIAAAAAoAHIu7IUwfgFzU8ZA1nNTxoDveKXGQBiLQIQoBZFDRAK5K8Z",
    "Gi0QArANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABvNgEEbzUBBS0GHC0HHS0IHy0JHi0MGC0c",
    "AS0dAkEBBMUNHwAtHgPgHx1jDABDAAFsshPUaAgaZWMgawoCVF1AZaZMFE1AT1IdVwHTAMAikkjT",
    "pLK7DQoAjACQoB8AX0EdDQBaQR4NdLIT1GgIGmVjIGsKAlpHLlYqAS5dSGQGTSA6aTrqIyBQ7ykZ",
    "YBlRimWq3LK7DQoAjABRDRgBUCkACw0NAXApDR2qHbKXoOArHYsEBQolDQs/7YwAL0EeDWQNGAFQ",
    "KgALDQ0BcCoNHqoespeg4CsdiwQFCiUNCz/tjAAJ4CsdiwQFCi0cBi0dBy0fCC0eCS0YDKsKAAQA",
    "AAAAAAAAAGEdAUeVAowAHEEdDVhQKQADDQQBcCkEAGEAAUSVAiUEAz/zYR4BRpUCqwJBHg1YUCoA",
    "Aw0EAXAqBABhAAFElQIlBAM/86sCBAAAAAAAAAAAURsEA6ADyuCfAw8AoABBoxsEoATRUQQEA6AD",
    "yuCfAwEAoABBoAHJ4L8BAKAAQaAe56MeBKAE0FEEDQOgA8ngvwMAoABBoB7QUR4EA6ADyeC/AwCg",
    "AEGgHe2gH1ajHQSgBNBRBA0DoAPJ4L8DAKAAQaAd06AfUFEdBAOgA8ngvwMAoABB4L8CALgDAAAA",
    "AAAALQIWLRABbhsQUQEEAOCfAAMA4D8aRhagAmagFsvgHyFgCgOMADLgHyFgCwCgAEvgHyFgBACg",
    "AOANAwGMABqgFlfgHyFgCQCgAEvgHyFgBACgAMUNAwGgA1HgLyE2EACgAMjgLyGcEACgFsBLEAyw",
    "CQAAAAAAAAAAAAAAAAAAAAAAAKIBCFBqCAJHlQQtBQihCAi/9KAEY1IBDwagBtykBgeWBw0IAHAG",
    "CAlqCQJHlQQtBQklCAc/8EEEAUCgA9iyFMLspa0DsoCl4C8iqgUAshTC9KW7qwUCAAAAAK0BsAYA",
    "AAAAAAAAAAAAAABPAQACTwEBA3QDBQBvAQAA4SsC9QUAlQV0BQMAYwACP+nnvwUAVQABBM8vAvUE",
    "Bm8BAwB0AwQA4asBAADhqwEDBiUDAkUNAwLhmwEBA6sGAwAAAAAAAE8BAADnvwADbwEDAqsCAAEA",
    "AC0BEKAWRQ0QCrwtEAGrEAMAAAAAAAANKACtAbu74D8e+gC7shOUaikD1GgROgoDNACXEURgmRDE",
    "XJkWYBLkKJgTJFCXEUBS4BLEaI4TJVQFGD6ApeA/HMEAUBoBAKAASA0DAIwABk8aAQPBjwMQS0O3",
    "wY8DEFJVtsKyEupjNF1ALM5FSZZFu4z/m8GPAxA9VLuyEy0acGALUuBWJnnTsLK7usGPAxFxVuA/",
    "LQgAshNTJoAszkVJlkW7jP9pu7IXxFYqGwoDPlVAEuQomBMkGJcTJUwEXIoTBGSUEuQoFFwEWJoR",
    "xGS/AKaHwOh/AYz/ZgAAswAAAKYFRRgqFMEopgVAAJk1QDDSKA5gFG1XAAUYKhTBKKYFRZgqBQAA",
    "AAAAAAAAAACgAslKAhBFDQMBogEEQaEEBcKgA0VMBBugAkepBIwABW4EAi0EBaAEP+awAQAAsgC+",
    "eLpMvwCmh8XgPxzBAFAZAQHBlwFZecHBlwFObsCyF8RWKhsKAz5VQHgUXBMX4BTB+KXofwGM/9ID",
    "AAAAAAAAQQEOR2EQLkCwowECoALA4C8flQEDYQMQ10ECCEzgKxwbARAAoABBwZcCCQtAsMGrAhAb",
    "weAvGmgCAKAAwKMCAui/Aoz/6gACAAAAAKMBAuAvH5UBAGEAEEBKAhlKSgIXxkoCGkDBqwIQG8Gj",
    "AgLovwKM/+cAAgAAAACgAkUtAhugAcCjAQBhAALBowEB6L8BjP/vAQAAowEBoAHARgEKRKsB6H8A",
    "jP/wAACgFsDgPxpGAKAAQA0WAOAfIWANALgBAACgFkDgPxpGAKAAwA0WAUsQDOAfIWAOAaABxKsB",
    "4D8hLQC4AAIAAAAAVBMCE1UTAQDhKwLNAAHhKwLNEwKwAgAAAABUAgICYwITwVUCAQDPLwLNAABh",
    "AAFO4C8f4gIA4D8f6ACw6H8AjP/aAAEAAOEjAs0B//ewAAIAAAAAVAECAWMBE8HPLwLNAQDBjwD/",
    "9wBVLQIBVAIBAM8vAs0AAFUCAQDhKwLNAABUAgIAzy8CzQAA4SsCzQIAYQITYFUCAQDhJwLNAADh",
    "JwLNAgBVEwITVQECAeh/AYz/pFQCAgLovwKM/7LofwCM/5QAAgAAAABUAgICYwITwFUCAQDPLwLN",
    "AABhAAFVzy8CzQIAwZMAAf//weh/AIz/2eh/AIz/0wMAAAAAAACVElQBAgFjARNOQQIBAGjgPx/o",
    "AKsDzy8CzQEAwY8A//9UVQEBAM8vAs0AAOC/AABoAwADzy8CzQEAQwAAP8XPLwLNAQCWAOErAs0B",
    "AM8vAs0BAKAAP61VAQEAzy8CzQAA4L8AAGgDAAPgLx/iAQANAgGM/4+rAwUAAAAAAAAAAAAALQUU",
    "LRQBDQIBURAEAOCfAAIE4D8gPAMlAhTIoARFoAPGLRQFsOh/AIz/4AEAALIRwCaTFxkDLTpwgKWg",
    "AcjovwGMAAXovx3gLyKqAACzA5RqKQDVVuohxmVAZabksgAFAAAAAAAAAAAAAKADyy0EHi0FHYwA",
    "CC0EHS0FHq0BoATf5X8g4C8iqgQAoALT5X8grQKgBcvlfyDgLyKqBQCzATQrExcZAwoqQEXQKA5k",
    "HDoxAapGpcilAQAADSgAshMtGyVjAE6ZAxRJWTXTMB5TQCDTgKWtAbOWRQCzEy0bIHDYAMBdqmaX",
    "OQZEFmlYZdTMsgANKACzE9RouEYgNNsoGVAHKBJS6gMVKQ4tyJZFAAANKACzE9RoEmsZAOoB9EHT",
    "sLIAAA0oALMSdGQNKuoWYE6ZAnTwsgAAoBZADSgAsxHZFxgDNFAJGvADNAMKKAZP2TXTMA0q6pZF",
    "AOAnITYQAQCgAMDgLyGcEAC4AwAAAAAAAGEBEEygFkngHyFgBACxqgG7oAJYQRcAwEoBDFBBFwLM",
    "UQEEAOCfAAUAsFEBBADgnwAEAKAATFEBEQOgA8WtA7tRAQQA4J8ABQBLAQywAQAAQQEEY7MR2QHY",
    "Aq5lDQDxGRAWQBPUaAgaZWMgYUoAwGWuTYXIpUEBCFPPLw1nMQDBgAAXMhbrFyNAsEEBDVmzE9Ro",
    "Bl1AVjpNiiQOTzQBJl4TKxiWRUEBDkCyE9RoCBpgYUoD1GrgY1demk0uTZgCdPCyu7uxBgAAAAAA",
    "AAAAAAAAAKIBBgBpSgYJgEdRBgwCoALRu+CfAgcA4C8N+AYAjAAxSgYMyVEGEAKgAklRBhECoALf",
    "u60Cu+AvDfgGAOAvGmgGAKAAzKIGAEjgLyLeBgChBga/s6IBBlbgLyIaBgCgAMgNBAGMAAehBga/",
    "7qAE47uyEy0q6oCl4CEjPQEiGgQAsgGqXUXIpbvgIw4DASIaAKIBBmPgLxpoBgCgANXgLyIaBgCg",
    "AMyiBgBI4C8i3gYAoQYGv+ENBACiAQZW4C8iNAYAoADIDQQBjAAHoQYGv+6gBMC74CEjPQEiNEIA",
    "sgGqXUXIpbvgIw4DASI0ALgAAgAAAABhARvASgEJwEoBEMBKAQzJUQEQAKAAQFEBEQCgAEBRAQwC",
    "oALB4J8CBgCgAMGxAAIAAAAASgEQQGEBG8BKAQnASgEMyVEBEACgAEBRAREAoABAUQEMAqACweCf",
    "AgYAoADBsQAEAAAAAAAAAADzTwMC9a0B8z///c8fAvUAAqACwJUCDQQC0C8C9QQDQQQCTkIDYcpD",
    "A3rGVQMgA+W/AyUEAj/ksAAEAAAAAAAAAADzTwMC9aoB8z///c8fAvUAAqACwJUCDQQC0C8C9QQD",
    "QQQCTkIDYcpDA3rGVQMgA+W/AyUEAj/ksAACAAAAAEoBDupRAQkCoALKrQLlfyCMABtKAQ1KsmKS",
    "qAWMAA9KAQVIsppgjAAFspgFqgGwAQAASgEOx7JlqoClqgGwAAIAAAAASgEOSeAvIm8BALBRAQkC",
    "oALO4C8iTgIA5X8gjAAdSgENSrITFMlAjAARSgEFSrIQ04CljAAFspDAqgGwAAEAAEoBDkngLyJv",
    "AQCwshMtqAWqAbABAABKARpIspKTjAAFspHTsoCl4C8iqgEAsoCl4CUjPQEAAQCylkW74C8OAwEA",
    "uAAEAAAAAAAAAABKARpOsgC+NpEl07AFjAANsgC+IpNkzk3TsAWiAQPKsk6ZNdOwv7CiAQRJlQKh",
    "BAS/+0ECAUvgLyKQAwCMAENBAgJa4C8ikAMAsgDTpAWhAwDC4C8ikAAAjAAnogEEY+AvIpAEAJYC",
    "oALTQQIBTLIWYBppgKWMAAWylmChBAS/4bKX5bAACQAAAAAAAAAAAAAAAAAAAAAAAEcDQEZIAwID",
    "RwMCxkcDBEZIAwEDRwMIdVABAAegB4BSDQkBcAEJCKACyuCvAggAoADToAVILQUIjAAIoAZFLQYI",
    "lQQlCQc/3YwAJ6IBCWOgAsrgrwIJAKAA06AFSC0FCYwACKAGRS0GCZUEoQkJv+GgBHhHA0BNshJ0",
    "Za5NgLsFqwRHAwJNsk6ZNdMwDuClqwRHAwFNsjsATpk107ClqwSyTpk107ClqwRBBAEAV0cDQFrg",
    "KSRaBQMBAEoFDUmyANeopasEsoHYqwRHAwJa4CkkWgUDAABKBQ1JsgDXqKWrBLKB2KsERwMBUUoF",
    "DUqyGuqApYwABbK7AOApJFoFAwAAqwRBBAIATUcDAVlHAwLVRwMERkoFDUqyGuqApYwABbK7AEkD",
    "QADgKiRaBQMAAEcDIEqyApeApYwAB7IA06QF4CkkWgYDAABHAwJHsgDXqKWrBEcDAVlHAwLVRwME",
    "RkoFDUqyGuqApYwABbK7AEcDCABZDQkBcAEJCKACyuCvAggAoAD/RwNAUUEJAU3gKSRaCAMBAIwA",
    "CuApJFoIAwAAlgSgBN9BBAFYRwMgSrIWYNLgjAAPshZgGmmApYwABbKWYCUJBz+xjABUogEJAE+g",
    "AsrgrwIJAKAA/0cDQFFhCQVN4CkkWgkDAQCMAArgKSRaCQMAAJYEoATfQQQBWEcDIEqyFmDS4IwA",
    "D7IWYBppgKWMAAWylmChCQm/tUcDAkeyANeopasEAwAAAAAAAEEBDmdHAoBjoAPI5X9TjAAF5X9z",
    "slJKAwgqat/FYS4QwbIB04Clqi6woAPURwIQSeAvItMBALDgLyKyAQCwRwIQSeAvIqoBALDgLyKQ",
    "AQCwAAUAAAAAAAAAAAAAoB9dsxPUaBJrGQGObUAYCTrqIy5SYGaAcNFADsyychAdAaABVqAWS+Af",
    "IWAMAKAARo0vn7sNKACwpAECQQIBSVABAAOMAL5BAgJNTwEAAK0Auw0oALBBAgNSTwEAAOC/AAOg",
    "AwCfDSgAsEECBHRQAQEArgAAoADJUAEAA4wAhk8BAQOgA8itA7uMABKgFkvgHyFgDACgAEaNL5+7",
    "DSgAsEECBQBIUAEBBUoFF0lQAQADjABRTwEBA6ADya0Duw0oALDgLw34BQCyE9RouEYgNNsoGVAU",
    "VVOApeAvIqoFALIBbl8ZlkW7DSgAsLIQ91IKTAp12YC+5r8CshflyKW7DSgAsOAvHdQDALgAAEod",
    "H0/gLyUtHQDgLyUeAACw4A8g3C6VALAFAAAAAAAAAAAAAC0EHw0fAeAbHNgEAQUtHwSrBQADAAAA",
    "AAAADQIgBAIUwHIQAgOgA7/2pAMAQQAFP+5QAwEAYQABP+WrAgACAAAAAOAvJS0BAqACwHIQAgBQ",
    "AAAAuAAAshDXKB5TQGNXKB5TQHDTZBlQFmnZlqXgPx8pAKAA1LuyEy0acGALUuBWJnnTsLK7uruz",
    "EoRABXATUyBbTmcuTYXIpQIAAAAAUR0OAaABSVEdEQGgAcitAbsNAgFKHRhk4C8i0x0AsgHYgKVK",
    "HRdKslKqzLKMAAmyIjRhSZZFuw0CAaIdAFTgLxpoHQCgAMvgLyLeHQANAgGgAkCyE9RoGClATpk1",
    "0zAYVUg40QDHU1mApeAvIqodALOWRQBhHRvMSh0QSOA/IJYAsKAWT7MR2RcYAzRQCRrwlkWzE9Ro",
    "CBplYyBhSgDTey06bAKLAdNlVysZlkUAYR0bSeAfHNgJALhKHRBI4D8glgC4Sh0ZyuAPINwupwC4",
    "Sh0YaeAvGmgdAKAAYOAvItMdAEodDUnoPy4zjAAG6D8uO60AswERUwqksqIdAODgLyLTHQBKHQ1J",
    "6D8uM4wABug/LjutALMBUlc+lkXgLyLeHQC4AQAAoBaAiKIbAAByshPUaAZdQCDXX85NhfSlu6Ib",
    "AUGygADgLyKQAQBKARtJsgC+cpfMv0oBD1GyAL5W9G3JOmwCLjG5l+VKARlsSgEYWUoBF0yyAL5S",
    "qsy/jAALsgC+IjRhSZfl4C8aaAEAoADI4C8i9gEAu6EBAb+nsLMT1GgGXUAqVWfFcaZNKqSysxHZ",
    "FxgDNFAJGvADNAMKKBw02QPUaLhdQCDXX85NhcilAOAvJl8dALAFAAAAAAAAAAAAAGEBGwBDoAJA",
    "wY8iDt9NshJ0ZBZp2aiyu7HBgyIQ+g70SOA/IRIAscGPIhATVbIT1GgGXVMXGQJeAz5VRcilu7Hg",
    "PyEIALFKARBLoAJA4D8glgCxSgEezaACQOAPINwurQCxZgEbWKACQLIT1GgGRuoZPgGmbUBlpuSy",
    "u7HgKydEARsDoAOA00oDEGOgAkCyEy0bIGFKSwBmgB1RUmwDNICl4C8iqgMAspZFu7HgLyeNAwCg",
    "AODgLw34AwCgAkDgLyLTAwCyAdgB0wMtKBwbxcilu7HgLye0AQCgAIB9SgMZAHjgKx+GAQMAoACA",
    "beArH4YbAwCgAABiSwEMbgEboAJAQRgBS7ITJkFTlkW7sbIT1GgXKMi0BeArH4YbAwCgAMyyU1kC",
    "i4CljAAFsrpg4C8iqgMAsgDTpAVKARxNsnFG3AVLARuMAAeyZNCoBeAvIqoBALKWRbux4CsntAEC",
    "AKAAwEoBHHNLARtuARtLAQygAkFBGAFRsxMmQVMAvhppA5ReZfyyshPUaBwo14Cl4C8iqgEAs5ZF",
    "SwEMbgEboAJBQRgBSbMTJkFTlkWyE9RoFTkQA1WApeAvIqoBALOWRQcAAAAAAAAAAAAAAAAAAOAq",
    "J5cBAhADoANEmwphAQPyowEHwZsHAAPp4C8njQcAoADILQQHjAAUSgcZRkoHGkZGBwpIoAVFLQUH",
    "owcHjP/VLQYFYQID9aMCB8GbBwAD7OAvJ40HAKAAy6AEWi0EB4wAFEoHGUZKBxpGRgcKSKAGRS0F",
    "B6MHB4z/0qAExKsEqwUAAQAASgEQwUoBGUBKARhASgEXQbEHAAAAAAAAAAAAAAAAAACgA8DBqwMB",
    "AkSrA6IDB1vgKieXAQIHBqAGyy0FBgUEAUSrA6EHB7/pqwUABgAAAAAAAAAAAAAAAFEbCgNCAwDB",
    "4C8pXhsGURsTAHUGAATgLyleAQV0BAUAYwADQaACQEEYAVmyE9RouF1AINdfzk2AZpQCWiGlyKW7",
    "sbIT1Gi4XUAg11/OTYBmlAJaIaBmgFXIQBrUBeAvIqoBALKWRbuxAABmHRvADSgAsxPUaAlSZWMg",
    "NNsoGTTZlkUAAG4dEEsdDEwdG0EYAUuzETdStSklyKWyE9RoCV6VgKXgLyKqHQCzlkUAAGEeG0rg",
    "GxzYCx0AsGEdG0rgGxzYBR4AsOAnGZEdAgCgAMGxBgAAAAAAAAAAAAAAAEoeEEngLyCWHgCwSh4Z",
    "RkoeGsrgDyDcLrsAsGYdG9OzE9RoCVJlYyA02ygZNNmWRWEdHszgKx+GHh0AoADdsxPUaAgaZWMg",
    "V1kDFElZNdMwFEwOZwpFZcilUR0TAVEeCgJCAgBIDQIFDQYBUR4TA2MBAsZjAQNashMtGyBykxcZ",
    "AW5kFMwF4C8iqh4As5ZFoAZu4C8pUB4FdAUBBGMEAmCyEy0q6hcYAnRkCk6aMaBelEgUzAXgLyKq",
    "HgCzlkVuHR5LHQxMHRtBGAFJsxE0TUXIpbIT1GgV6yDgLyKqHQCyApOApeAvIqoeALOWRQBhHhtI",
    "4D8hEgCwYR0bSuAbHNgFHgCw4CcZkR0CAKAAwbEGAAAAAAAAAAAAAAAASh4QSeAvIJYeALBKHhlG",
    "Sh4aSuAPINwutgCwSh4X/0oeGFHgLyLTHgCzAdgBEVMKpLJKHhfoSh4ZZLIT1GgYKUBOgHDeAzQC",
    "umQZNdMzADp50AXgLyKqHgCzlkVmHRvVsxPUaAZdUxcZAbRFLk2AZabksmEdHszgKx+GHh0AoADd",
    "sxPUaAgaZWMgV1kDFElZNdMwDkwOZwpFZcilUR0TAVEeCgJCAgBIDQIFDQYBUR4TA2MBAsZjAQNa",
    "shMtGyBykxcZAW5kDswF4C8iqh4As5ZFoAZu4C8pUB4FdAUBBGMEAmCyEy0q6hcYAnRkCk6aMaBe",
    "lEgOzAXgLyKqHgCzlkVuHR5LHQxMHRtBGAFJsxE0TUXIpbIT1GgV6yDgLyKqHQCyAdOApeAvIqoe",
    "ALOWRQAEAAAAAAAAAACiAQRPUQQTAHQDAAOhBAS/9asDBAAAAAAAAAAAUQETA6IBBGRKBBnGSgQQ",
    "T+AvKV4EAnQDAgOMAApRBBMAdAMAA6EEBL/gqwMAAEodHErgGxzYBh0AsOAPINwvWQCwAABKHRtO",
    "Zh0bSuAbHNgKHQC4sxPUaAZdUxcZA4oa7k2AZabksgBhHRtI4D8hEgCwSh0QSOA/IJYAsEodEmGp",
    "HUEYAUmzEUZlU5ZFshPUaAkrdOrg4C8iqh0As5ZFsxMtGyVjADTXJj4BSTjxqLIAAQAAjS5YshTk",
    "XVEo2KgFDwABAMmPAAf/AOa/ALIAugCYKu4aIE9SHVeApQ0BEjAAAQDlvwAFARc/9rMAugCfEcRE",
    "iwCoFkVAETjgEeWwpQAAYR0bXbMTymCzA8pgswPUaLhdQG1XeA5KtF8mTyXIpbIT1GgIUnkqVUTZ",
    "qAXgLyKqHQCzAXRcBgDuZLMA+mQTUy06bAF3adkvUQEUSVgDNAJOTSXIpQBKHRBI4D8glgCwSh0Y",
    "yuAPINwuqwCwSh0XUbMR2RcYANFdRifAUqrMskodFVuzE9RouEYgNNsoGVAaTjQiADsgLddjJcil",
    "Sx0MSx0XQRgBTbISlSpqpLK7jAAmshPUaBRVU4Cl4C8iqh0AspZFu6AW0EodGUxKHQfI4C8i3h0A",
    "4D8fqwC4AEodEEjgPyCWALBKHRjK4A8g3C6OALBKHRfTsxHZFxgA0V1GJ8AiNGFJlkVLHQxMHRdB",
    "GAFNshERUwqksruMABWyE9RoCEaYqAXgLyKqHQCylkW74D8foAC4AOAPINwupQCwAADgDyDcL08A",
    "sAADAAAAAAAADQEBshMuSUBU2GFYlkW7URAEAOCfAAID4D8gPAIlARTBoANBoAJB6H8AjP/kAQAA",
    "4A8MAgrFAOAPDD8I8wCgHICIoB3koB9h4C8Z0SkAoADQUCcFAOArGTApAACgAErgDww/CsUAsKAe",
    "4eAvGdEqAKAA0FAnBgDgKxkwKgAAoABK4A8MPwrFALDgKhzYHB0eAcGVHAcxFuzBlRwzNAnlwZUc",
    "Mjc23sGVHDgXOdfBlRw6OzzQURAEAOCfAAIB4D8gPAGjGxCMABKyEnRlrk2AZoBdVSjZlkW74A8M",
    "PwrFALAAAQAASh0TyuAPINwuwACwUR0OAaABxq0Bu7BRHQsBoAHtZh0bRq0Bu7CzE9RoEmsZAOoB",
    "tEUuTYBlpmQZUAcoBh4qAzQC6hkgOyXIpeAbHNgBHQC4AGEdG0jgPyESALBKHRTK4A8g3C7NALBK",
    "HQhRsxHZFxgA0V1GJ8BSZcilSx0IQRgBTbMTHDsoNUkCk5ZFshPUaBhx2SGg0mDgLyKqHQCzlkUA",
    "YR0bTeAPHnUWdACtALuwSh0UyuAPINwuzQCwSh0I0bMR2RcYANFdRifAUWuWRUwdCEEYAU2zExw7",
    "KDVJAoussrIT1GgYcdkhoFFrgKXgLyKqHQCzlkUAAEodFNZKHRpK4A8gsC7TALDgDyDcLs0AsEod",
    "CErgGxzYFB0AsOAbHNgTHQCwAABhHRtbsxJ0FmB6mgMKKkAiNGFAZoBlqgFJMUXIpUodEEjgPyCW",
    "ALDgDyCwLrMAsABhHRtZsxMtGyBymkUgJVIo0wD0ZaBRYGsFyKVKHRBI4D8glgCw4A8gsC6wALAA",
    "4D8g7QCwAADgPyDtALAAALIT1GgGXVMXGYCl4A8eQy7eALMDLTr4Z8XIpQDgPyD5ALAAAOA/IPkA",
    "sAAAsxPUaBhJUUQTUy06bANTK7UpGSklyKUAYR0bXbMSKmS4YA1SqgHZATQrExcZARRJQGaAZabk",
    "skodEEjgPyCWALDgDyCwLtMAsABhHRthshGK5AVKHQ1J6D8vM4wABug/Lp6tALMD1Gr4KiuWRUoe",
    "EEngLyCWHgCw4AUgsC7TAAEAsAAAYR4be+AvH4YdAKAA07MT1GgGRuoZPgGmbUBlpuSyshGK5AVK",
    "HQ1J6D8vM4wABug/Lp6tALMD1Gr4KiuWRWEdG0jgPyEIALhKHRBI4D8glgC4Sh4QyuAPINwumQC4",
    "4C8i0x4ASh4NSeg/LjiMAAboPy41rQCyAybBQOAvIqodALOWRQAA4Boc2CEeHQCwAGEdG8ZKHRDA",
    "DSgAshMmRg5NgOaAYR0bTLJ6ml8KxWWMAAjgLyKQHQCzFmA3TZalAOAvItMdALMBNCsTFxkDCipA",
    "Onkq6mMqpLIALRsdsAAA4A8gsC9TALAAAOA/IQgAsAAAoB3K4A8g3C5WALDgPyEIALAA4D8hCACw",
    "AADgDyCwLp8AsAAAsxPUaAw7agDAYy5e7k2AVVcul0jTIUBRYBckSMgQ12W6XARU10C5FkAQ9xt0",
    "loUAsxEmTQ5NgDsALpcdySVTlkUAYR0bV7MRywKTR8BlrmAcKuoAwCbqGkXIpUodEEjgPyCWALjg",
    "DyDcL1EAuABhHRtI4D8hEgC4Sh0QSOA/IJYAuOAPILAuygC4AABhHRtbsxONGyA7AGWuYLMDLSgE",
    "Lu4a+ACIR0eWpUodEEjgPyCWALjgDyCwLsIAuAEAALMTUyaAOwBOmQDbGdEY8SgOTBk12ANqXw5S",
    "ZcilAQAAshMGbdMwshZFyKW7u7VI4D8hLQC4sxMGbUAszkVJlkUAAQAAtsCzEupjNF1ALM5FSZZF",
    "ALIQ1ygeU0BjVygeU0Bw02QZUBcrGRr5lqXgPx8pAKAAw7ezEupjJl8gGPRfKqSyALIQ9zlLASph",
    "Fzq5OpPgsrsNFwGrFwCyE2pc9GFAJVgi7lcuUniWRbu7DRcC4D8hLQC4AACyExpVVx7uKWAlWCLu",
    "Vy5SeJZFuw0XAKsXAA8ACABHAAFTsxM3Gngi7lcgGjcoyXgUzLLzfwIPAAgARwABXbITLTsAHUw6",
    "eADAZuZPCF3VZBSsBeA/KbsAsLMRZjoqpLIAAA8ACABHAAHVsxM3Gngi7lcgGjcoyXgULWXIpbuy",
    "EVMkFCwZXNNhFzq5lkW78z///g8ACABHAAFAsxFmOiqksgAhBx1AQRwBQLMT1GgRUpACLkFAepoX",
    "FygaVAtS4BpgGTsqeWrqlkUAQRwBQLMTLSgIRoZADmAaTmZnVxoxeAka8JZFAQAAQQEDTgoGG0YM",
    "BA+wCwQPsEEBAUAKBA/AwZUcBzEWwMGVHDM0CcDBlRwyNzbAwZUcOBc5wMGVHDo7PMBBHADAQRwE",
    "RkEdH8CyE9RoDF6VKAZemk0gIjpLDkfAOmBlqgEmXgVIBB1ZZVcA6gEGXUtqJcilu5UzqzMAwZcc",
    "ARhAshMtKBIrGBmKAw5KsXgXKMlgvQC5E9ToBUMzAUqyRpiosowAB7Jx05ZFspclu+A/JU4AuAAA",
    "16ilATQrE5cZATRMuOSlgdgAmV/AXVU25mHTMBk1QCKSSNOkshDAYkZGIB7mYwA2lEAOYBRMGTVA",
    "cNHEshDmYUcaMZZFIi7I5RERUNACiwCJGvBNWGCnEMAc2DkAEcQsCSpUTxlc2TqTFkUclF3MOmZE",
    "DBpKAP4Al1GKXAQt12WlHJ8RxEQIUnsq+DqTAP4AjysYKARJBDLqcLMAjxvYUmATEjstFmAaaQCP",
    "Uw0AkRuXKmiopSI04UURFEUgYbRxV+CyMVkB02HJqKUx2ygZNdMzAOaFuyUR+kquTYA6YFYmoUVG",
    "iMClRpRADk8OpUVSqsylVchAGtSlErpGLs2FErphrs2FV1kDLTpsYA7MpVdZAy06bGAUzKVdRqSl",
    "EuoiESsYR8A6aDpqXNm6bBL6HO7NhWOOZQ0CkwDTJBStZRMmQdMwHlNXAXdrGVzZOpMCmmQUzKVl",
    "puSlEy0oBxrlTBJpDQL0aY0q4GWmTB5TRWEgNNsoDGlYYUkAy2VXAy0oFFdRKmgoFCwZNUAunirg",
    "ZoBlqgJ0Xy0WYDsAIpJWKmVReApKufiyEy0oHBoxYBQsGTXYAxIaMQL0UkBxVygIRUZePgKTIUBF",
    "0ykgcdk0DVKQYLMDLVNMNBNTgFJxeBRNQF1SGdNgsgCZNUArrmQOYAYBNFLgZoBlqgFGYyXIpWWq",
    "yKUTLSrqAwoqWAM0AOoDFElAYpdkFCwSKxgZigMIXNxFSQHTAy0oGBuJaxkCkwMtKAtGlNyyanHR",
    "EHDQqKUThm3TMB5TVwGmzThxRtylE9RoBl1AYyZNLk2AOmAYGFTIOppgDRoxFmBisSppOTF4CSkU",
    "XNkpIDpgXUkA0yQMUikWYHHZNAxF2WVXOmwBDRppKi4q+AKbKu0oyRZAEy0oCk83GmgoC16SAy0o",
    "GGbqKyA7AGaAZaoCdF8tFmAaaQMtKuoA1ygJUpdw3mAYU1k0Bk0gcVjkshPUaAgaZWMgMoBlpmQc",
    "G8XIpRPUaLhtQFJxeA9rGQDXXdspJUwGTSAdWDkqYLMDLSgcKNk1VwKaZw4lQGFKSwBmgB1AMVll",
    "0zAcUviosg=="
].join("");

// Decode base64 to Uint8Array
function decodeStoryData() {
    if (typeof atob !== "undefined") {
        // Browser
        const binary = atob(STORY_DATA_BASE64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
    } else {
        // Node.js
        return new Uint8Array(Buffer.from(STORY_DATA_BASE64, "base64"));
    }
}

// Opcode Implementations
ZMachine.prototype.executeInstruction = function() {
    const instrPC = this.pc;
    const opcode = this.readByte(this.pc);
    this.pc++;

    // Add comprehensive debug logging matching frotz output format
    if (this.debugMode) {
        // Get local variables from current frame
        const l1 = this.locals[0] || 0;
        const l2 = this.locals[1] || 0;
        const l3 = this.locals[2] || 0;
        const l4 = this.locals[3] || 0;
        const l5 = this.locals[4] || 0;

        console.error(`[STEP ${this.instructionCount}] PC=0x${instrPC.toString(16).padStart(4, '0')} Op=0x${opcode.toString(16).padStart(2, '0')} L1=0x${l1.toString(16).padStart(4, '0')} L2=0x${l2.toString(16).padStart(4, '0')} L3=0x${l3.toString(16).padStart(4, '0')} L4=0x${l4.toString(16).padStart(4, '0')} L5=0x${l5.toString(16).padStart(4, '0')}`);
    }

    // Decode instruction form
    if (opcode === 0xBE && VERSION >= 5) {
        return this.executeExtended();
    } else if ((opcode & 0xC0) === 0xC0) {
        // Variable form
        if (opcode < 0xE0) {
            return this.execute2OPVar(opcode & 0x1F);
        } else {
            return this.executeVAR(opcode & 0x1F);
        }
    } else if ((opcode & 0x80) === 0x80) {
        // Short form
        const operandType = (opcode >> 4) & 0x03;
        const opcodeNum = opcode & 0x0F;

        if (operandType === 0x03) {
            return this.execute0OP(opcodeNum);
        } else {
            let operand;
            if (operandType === 0x00) {
                operand = this.readWord(this.pc);
                this.pc += 2;
            } else if (operandType === 0x01) {
                operand = this.readByte(this.pc);
                this.pc++;
            } else {
                operand = ["var", this.readByte(this.pc)];
                this.pc++;
            }
            return this.execute1OP(opcodeNum, operand);
        }
    } else {
        // Long form
        const opcodeNum = opcode & 0x1F;
        const op1 = (opcode & 0x40) ? ["var", this.readByte(this.pc)] : this.readByte(this.pc);
        this.pc++;
        const op2 = (opcode & 0x20) ? ["var", this.readByte(this.pc)] : this.readByte(this.pc);
        this.pc++;
        return this.execute2OP(opcodeNum, op1, op2);
    }
};

// 0OP Instructions
ZMachine.prototype.execute0OP = function(opcode) {
    switch (opcode) {
        case 0x00: // rtrue
            this.returnFromRoutine(1);
            break;
        case 0x01: // rfalse
            this.returnFromRoutine(0);
            break;
        case 0x02: // print
            this.printLiteral();
            break;
        case 0x03: // print_ret
            this.printLiteral();
            this.newLine();
            this.returnFromRoutine(1);
            break;
        case 0x08: // ret_popped
            {
                const value = this.pop();
                this.returnFromRoutine(value);
            }
            break;
        case 0x09: // pop (discard top of stack)
            this.pop();
            break;
        case 0x0A: // quit
            this.quit();
            break;
        case 0x0B: // new_line
            this.newLine();
            break;
        case 0x0C: // show_status (V3 only)
            // In V3, this updates the status line at the top of the screen
            // We just no-op this since we don't have a proper status line implementation
            // Games call this frequently but it's not critical for gameplay
            break;
        case 0x0D: // verify
            this.branch(true); // Always succeed for now
            break;
        default:
            throw new Error(`Unimplemented 0OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 1OP Instructions
ZMachine.prototype.execute1OP = function(opcode, operand) {
    const value = this.getOperand(operand);

    switch (opcode) {
        case 0x00: // jz
            this.branch(value === 0);
            break;
        case 0x01: // get_sibling
            {
                const obj = this.getObject(value);
                const sibling = obj ? obj.sibling : 0;
                this.store(sibling);
                this.branch(sibling !== 0);
            }
            break;
        case 0x02: // get_child
            {
                const obj = this.getObject(value);
                const child = obj ? obj.child : 0;
                this.store(child);
                this.branch(child !== 0);
            }
            break;
        case 0x03: // get_parent
            {
                const obj = this.getObject(value);
                this.store(obj ? obj.parent : 0);
            }
            break;
        case 0x04: // get_prop_len
            {
                const propAddr = value;
                if (propAddr === 0) {
                    this.store(0);
                } else {
                    // Use the shared getPropertySize function
                    this.store(this.getPropertySize(propAddr));
                }
            }
            break;
        case 0x05: // inc
            {
                const varNum = value;
                const val = this.getVariable(varNum);
                this.setVariable(varNum, val + 1);
            }
            break;
        case 0x06: // dec
            {
                const varNum = value;
                const val = this.getVariable(varNum);
                this.setVariable(varNum, val - 1);
            }
            break;
        case 0x07: // print_addr
            {
                const addr = value;
                const text = this.decodeZString(addr);
                this.print(text);
            }
            break;
        case 0x08: // call_1s (V4+)
            if (VERSION >= 4) {
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(value, [], storeVar);
            }
            break;
        case 0x09: // remove_obj
            {
                const objNum = value;
                const obj = this.getObject(objNum);
                if (obj && obj.parent) {
                    const parent = this.getObject(obj.parent);
                    if (parent) {
                        // Remove from parent's child list
                        if (parent.child === objNum) {
                            this.setObjectChild(obj.parent, obj.sibling);
                        } else {
                            // Find in sibling chain
                            let prev = parent.child;
                            while (prev) {
                                const prevObj = this.getObject(prev);
                                if (prevObj && prevObj.sibling === objNum) {
                                    this.setObjectSibling(prev, obj.sibling);
                                    break;
                                }
                                prev = prevObj ? prevObj.sibling : 0;
                            }
                        }
                    }
                    this.setObjectParent(objNum, 0);
                    this.setObjectSibling(objNum, 0);
                }
            }
            break;
        case 0x0A: // print_obj
            {
                const name = this.getObjectName(value);
                this.print(name);
            }
            break;
        case 0x0B: // ret
            this.returnFromRoutine(value);
            break;
        case 0x0C: // jump
            {
                // Sign extend 16-bit value
                let offset = value;
                if (offset > 32767) offset -= 65536;
                this.pc += offset - 2;
            }
            break;
        case 0x0D: // print_paddr - packed string address
            {
                // This is a packed STRING address, so pass isString=true for V6/V7
                const addr = this.unpackAddress(value, true);
                const text = this.decodeZString(addr);
                this.print(text);
            }
            break;
        case 0x0E: // load
            {
                const varNum = value;
                if (this.debugMode && this.instructionCount < 20) {
                    console.error(`  LOAD from var ${varNum} (stack size: ${this.stack.length})`);
                }
                // When loading from sp (var 0) indirectly, peek instead of pop
                const val = (varNum === 0) ? this.peek() : this.getVariable(varNum);
                this.store(val);
            }
            break;
        case 0x0F: // not (V4) / call_1n (V5+)
            if (VERSION >= 5) {
                // call_1n
                this.callRoutine(value, [], null);
            } else if (VERSION >= 4) {
                // not (bitwise complement)
                this.store(~value & 0xFFFF);
            }
            break;
        default:
            throw new Error(`Unimplemented 1OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 2OP Instructions (Long form)
ZMachine.prototype.execute2OP = function(opcode, operand1, operand2) {
    const val1 = this.getOperand(operand1);
    const val2 = this.getOperand(operand2);

    switch (opcode) {
        case 0x00: // Illegal opcode - reserved
            // This should never be encountered in valid Z-code
            // If we hit this, something is very wrong with our implementation
            throw new Error(`Illegal 2OP opcode 0x00 encountered at PC 0x${(this.pc - 3).toString(16)} - this indicates a serious bug in instruction decoding or PC management`);
        case 0x01: // je (jump if equal)
            this.branch(val1 === val2);
            break;
        case 0x02: // jl (jump if less than - signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(a < b);
            }
            break;
        case 0x03: // jg (jump if greater than - signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(a > b);
            }
            break;
        case 0x04: // dec_chk
            {
                const varNum = val1;
                const currentVal = this.getVariable(varNum);
                const newVal = (currentVal - 1) & 0xFFFF;
                this.setVariable(varNum, newVal);
                const signedNew = newVal > 32767 ? newVal - 65536 : newVal;
                const signedCheck = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(signedNew < signedCheck);
            }
            break;
        case 0x05: // inc_chk
            {
                const varNum = val1;
                const currentVal = this.getVariable(varNum);
                const newVal = (currentVal + 1) & 0xFFFF;
                this.setVariable(varNum, newVal);
                const signedNew = newVal > 32767 ? newVal - 65536 : newVal;
                const signedCheck = val2 > 32767 ? val2 - 65536 : val2;
                this.branch(signedNew > signedCheck);
            }
            break;
        case 0x06: // jin (jump if object is in another object)
            {
                const obj1 = this.getObject(val1);
                this.branch(obj1 && obj1.parent === val2);
            }
            break;
        case 0x07: // test (test bitmap)
            this.branch((val1 & val2) === val2);
            break;
        case 0x08: // or
            this.store(val1 | val2);
            break;
        case 0x09: // and
            this.store(val1 & val2);
            break;
        case 0x0A: // test_attr
            this.branch(this.testAttribute(val1, val2));
            break;
        case 0x0B: // set_attr
            this.setAttribute(val1, val2);
            break;
        case 0x0C: // clear_attr
            this.clearAttribute(val1, val2);
            break;
        case 0x0D: // store (variable)
            // When storing to sp (var 0) indirectly, replace top instead of push
            if (val1 === 0) {
                this.pop();  // Remove current top
                this.push(val2);  // Push new value
            } else {
                this.setVariable(val1, val2);
            }
            break;
        case 0x0E: // insert_obj
            this.insertObject(val1, val2);
            break;
        case 0x0F: // loadw (load word from array)
            {
                const addr = val1 + 2 * val2;
                this.store(this.readWord(addr));
            }
            break;
        case 0x10: // loadb (load byte from array)
            {
                const addr = val1 + val2;
                this.store(this.readByte(addr));
            }
            break;
        case 0x11: // get_prop
            this.store(this.getProperty(val1, val2));
            break;
        case 0x12: // get_prop_addr
            this.store(this.getPropertyAddr(val1, val2));
            break;
        case 0x13: // get_next_prop
            this.store(this.getNextProperty(val1, val2));
            break;
        case 0x14: // add (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a + b;
                if (result < -32768) result += 65536;
                if (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x15: // sub (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a - b;
                if (result < -32768) result += 65536;
                if (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x16: // mul (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                let result = a * b;
                while (result < -32768) result += 65536;
                while (result > 32767) result -= 65536;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x17: // div (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                if (b === 0) throw new Error("Division by zero");
                const result = Math.trunc(a / b);
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x18: // mod (signed)
            {
                const a = val1 > 32767 ? val1 - 65536 : val1;
                const b = val2 > 32767 ? val2 - 65536 : val2;
                if (b === 0) throw new Error("Division by zero");
                const result = a % b;
                this.store(result < 0 ? result + 65536 : result);
            }
            break;
        case 0x19: // call_2s (V4+)
            if (VERSION >= 4) {
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(val1, [val2], storeVar);
            }
            break;
        case 0x1A: // call_2n (V5+)
            if (VERSION >= 5) {
                this.callRoutine(val1, [val2], null);
            }
            break;
        case 0x1B: // set_colour (V5+)
            // Not implemented - no-op
            break;
        case 0x1C: // throw (V5+)
            // Not implemented
            break;
        default:
            throw new Error(`Unimplemented 2OP opcode: 0x${opcode.toString(16)}`);
    }
};

// 2OP Instructions (Variable form) - reads operands and redirects to execute2OP
// Note: Some 2OP instructions like 'je' can take more than 2 operands in variable form!
ZMachine.prototype.execute2OPVar = function(opcode) {
    // Read operand types
    const types = this.readByte(this.pc);
    this.pc++;

    const operands = [];
    // Read up to 4 operands (je and some others can use all 4)
    for (let i = 0; i < 4; i++) {
        const opType = (types >> (6 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // For je opcode (0x01), handle multiple operands specially
    if (opcode === 0x01 && operands.length > 2) {
        // je with more than 2 operands: check if first equals any of the rest
        const val1 = this.getOperand(operands[0]);
        let result = false;
        for (let i = 1; i < operands.length; i++) {
            if (val1 === this.getOperand(operands[i])) {
                result = true;
                break;
            }
        }
        this.branch(result);
        return;
    }

    // For other 2OP instructions, just use first 2 operands
    return this.execute2OP(opcode, operands[0], operands[1]);
};

// VAR Instructions
ZMachine.prototype.executeVAR = function(opcode) {
    // Double-VAR opcodes (call_vs2 = 0x0C, call_vn2 = 0x1A) use 2 types bytes for up to 8 operands
    const isDoubleVar = (opcode === 0x0C || opcode === 0x1A);

    // Read operand types (1 or 2 bytes depending on opcode)
    let types;
    let maxOperands;
    if (isDoubleVar) {
        types = (this.readByte(this.pc) << 8) | this.readByte(this.pc + 1);
        this.pc += 2;
        maxOperands = 8;
    } else {
        types = this.readByte(this.pc) << 8;  // Shift to high byte for consistent handling
        this.pc++;
        maxOperands = 4;
    }

    const operands = [];
    for (let i = 0; i < maxOperands; i++) {
        const opType = (types >> (14 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // Get actual values
    const values = operands.map(op => this.getOperand(op));

    if (this.debugMode && this.instructionCount < 20 && (opcode === 0x00 || opcode === 0x01)) {
        console.error(`  -> VAR operand types: 0x${types.toString(16)}, operands:`, operands, 'values:', values);
    }

    switch (opcode) {
        case 0x00: // call (call routine with 0-3 args)
            {
                const packedAddr = values[0];
                const args = values.slice(1);
                const storeVar = this.readByte(this.pc);
                this.pc++;
                if (this.debugMode && this.instructionCount < 20) {
                    console.error(`  CALL routine 0x${packedAddr.toString(16)} with args [${args.map(a => '0x' + a.toString(16)).join(', ')}] store to var ${storeVar}`);
                }
                this.callRoutine(packedAddr, args, storeVar);
            }
            break;
        case 0x01: // storew
            this.writeWord(values[0] + 2 * values[1], values[2]);
            break;
        case 0x02: // storeb
            {
                const addr = values[0] + values[1];
                this.writeByte(addr, values[2]);
            }
            break;
        case 0x03: // put_prop
            this.putProperty(values[0], values[1], values[2]);
            break;
        case 0x04: // read (sread V1-4, aread V5+)
            if (this.debugMode) {
                console.error(`[VAR 0x04 READ] Called with values[0]=0x${values[0].toString(16)}, values[1]=0x${values[1].toString(16)}`);
            }
            if (VERSION >= 5) {
                // V5+: aread has a store byte
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.read(values[0], values[1], storeVar);
            } else {
                // V1-4: sread has no store byte
                this.read(values[0], values[1], null);
            }
            break;
        case 0x05: // print_char
            this.printChar(values[0]);
            break;
        case 0x06: // print_num
            this.printNum(values[0]);
            break;
        case 0x07: // random
            {
                const result = this.random(values[0]);
                this.store(result);
            }
            break;
        case 0x08: // push
            this.push(values[0]);
            break;
        case 0x09: // pull - version-specific behavior!
            // V1-5, V8: pull (variable) - operand is target variable number, no store byte
            // V6-7: pull stack -> (result) - has store byte, operand defaults to user stack
            if (VERSION === 6 || VERSION === 7) {
                // V6/V7: Pop from user stack (if specified) or evaluation stack
                // The operand (if provided) is a user stack address, result goes to store variable
                // For now, we just pop from evaluation stack like other versions
                const value = this.pop();
                this.store(value);
            } else {
                // V1-5, V8: Pop and store in variable specified by operand
                const value = this.pop();
                // When pulling to sp (var 0) indirectly, replace top instead of push
                if (values[0] === 0) {
                    this.pop();  // Remove current top
                    this.push(value);  // Push the pulled value
                } else {
                    this.setVariable(values[0], value);
                }
            }
            break;
        case 0x0A: // split_window (V3+)
            // Not implemented - no-op
            break;
        case 0x0B: // set_window (V3+)
            this.currentWindow = values[0];
            break;
        case 0x0C: // call_vs2 (V4+)
            if (VERSION >= 4) {
                const packedAddr = values[0];
                const args = values.slice(1);
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.callRoutine(packedAddr, args, storeVar);
            }
            break;
        case 0x0D: // erase_window (V4+)
            // Not implemented - no-op
            break;
        case 0x0E: // erase_line (V4+)
            // Not implemented - no-op
            break;
        case 0x0F: // set_cursor (V4+)
            // Not implemented - no-op
            break;
        case 0x10: // get_cursor (V4+)
            // Not implemented - no-op
            break;
        case 0x11: // set_text_style (V4+)
            // Not implemented - no-op
            break;
        case 0x12: // buffer_mode (V4+)
            // Not implemented - no-op
            break;
        case 0x13: // output_stream (V3+)
            // Not implemented - no-op
            break;
        case 0x14: // input_stream (V3+)
            // Not implemented - no-op
            break;
        case 0x15: // sound_effect (V3+)
            {
                // sound_effect number effect volume routine
                // effect: 1=prepare, 2=start, 3=stop, 4=finish
                // volume: high byte = repeats (255=forever), low byte = volume (1-8, 8=loudest)
                const soundNum = values[0] || 0;
                const effect = values[1] || 2;  // Default to start
                const volume = values[2] || 8;  // Default to max volume
                // values[3] would be interrupt routine (V5+)

                if (this.soundCallback) {
                    this.soundCallback(soundNum, effect, volume);
                } else if (typeof Audio !== 'undefined' && this.sounds[soundNum]) {
                    // Basic browser audio support
                    const sound = this.sounds[soundNum];
                    if (effect === 2) {
                        // Start playing
                        if (this.currentSound) {
                            this.currentSound.pause();
                        }
                        try {
                            const audio = new Audio('data:audio/' + sound.format + ';base64,' + sound.data);
                            audio.volume = (volume & 0xFF) / 8;
                            const repeats = (volume >> 8) & 0xFF;
                            if (repeats === 255) {
                                audio.loop = true;
                            }
                            audio.play().catch(() => {});
                            this.currentSound = audio;
                        } catch (e) {
                            if (this.debugMode) console.error('[SOUND] Failed to play:', e);
                        }
                    } else if (effect === 3 || effect === 4) {
                        // Stop/finish
                        if (this.currentSound) {
                            this.currentSound.pause();
                            this.currentSound = null;
                        }
                    }
                }
            }
            break;
        case 0x16: // read_char (V4+)
            {
                // read_char device [time routine] -> (result)
                // device is always 1 (keyboard)
                // For now we ignore timed input
                const storeVar = this.readByte(this.pc);
                this.pc++;
                this.readChar(storeVar);
            }
            break;
        case 0x17: // scan_table (V4+)
            {
                const result = this.scanTable(values[0], values[1], values[2], values[3] || 0x82);
                this.store(result);
                this.branch(result !== 0);
            }
            break;
        case 0x18: // not (bitwise not) - V5+, but also used in V1-4 as VAR form
            this.store(~values[0] & 0xFFFF);
            break;
        case 0x19: // call_vn (V5+)
            if (VERSION >= 5) {
                this.callRoutine(values[0], values.slice(1), null);
            }
            break;
        case 0x1A: // call_vn2 (V5+)
            if (VERSION >= 5) {
                this.callRoutine(values[0], values.slice(1), null);
            }
            break;
        case 0x1B: // tokenise (V5+)
            // Not implemented - no-op
            break;
        case 0x1C: // encode_text (V5+)
            // Not implemented - no-op
            break;
        case 0x1D: // copy_table (V5+)
            // Not implemented - no-op
            break;
        case 0x1E: // print_table (V5+)
            // Not implemented - no-op
            break;
        case 0x1F: // check_arg_count (V5+)
            {
                // Check if argument number N was provided to current routine
                const argNum = values[0];
                // For now, assume all explicitly passed args are present
                // This is a simplification - would need to track actual arg count
                this.branch(argNum <= this.locals.length);
            }
            break;
        default:
            throw new Error(`Unimplemented VAR opcode: 0x${opcode.toString(16)}`);
    }
};

// Extended Instructions (V5+ only, opcode 0xBE prefix)
ZMachine.prototype.executeExtended = function() {
    // Read the extended opcode number
    const extOpcode = this.readByte(this.pc);
    this.pc++;

    // Read operand types
    const types = this.readByte(this.pc);
    this.pc++;

    const operands = [];
    for (let i = 0; i < 4; i++) {
        const opType = (types >> (6 - i * 2)) & 0x03;
        if (opType === 3) break; // No more operands
        if (opType === 0) {
            operands.push(this.readWord(this.pc));
            this.pc += 2;
        } else if (opType === 1) {
            operands.push(this.readByte(this.pc));
            this.pc++;
        } else if (opType === 2) {
            operands.push(["var", this.readByte(this.pc)]);
            this.pc++;
        }
    }

    // Get actual values
    const values = operands.map(op => this.getOperand(op));

    if (this.debugMode) {
        console.error(`[EXT 0x${extOpcode.toString(16)}] values: [${values.map(v => '0x' + v.toString(16)).join(', ')}]`);
    }

    switch (extOpcode) {
        case 0x00: // save (extended form, V5+)
            {
                // V5+ save with optional table/bytes/name
                // Returns 0 on failure, 1 on save, 2 on restore
                const result = this.save() ? 1 : 0;
                this.store(result);
            }
            break;

        case 0x01: // restore (extended form, V5+)
            {
                // V5+ restore with optional table/bytes/name
                if (this.restoreCallback) {
                    const state = this.restoreCallback();
                    if (this.restore(state)) {
                        // Restore succeeded - store 2 to indicate success
                        this.store(2);
                    } else {
                        this.store(0);
                    }
                } else {
                    this.store(0);
                }
            }
            break;

        case 0x02: // log_shift - logical shift
            {
                const number = values[0];
                const places = values[1] > 32767 ? values[1] - 65536 : values[1]; // signed
                let result;
                if (places >= 0) {
                    result = (number << places) & 0xFFFF;
                } else {
                    result = (number >>> -places) & 0xFFFF;
                }
                this.store(result);
            }
            break;

        case 0x03: // art_shift - arithmetic shift
            {
                let number = values[0] > 32767 ? values[0] - 65536 : values[0]; // signed
                const places = values[1] > 32767 ? values[1] - 65536 : values[1]; // signed
                let result;
                if (places >= 0) {
                    result = (number << places);
                } else {
                    result = (number >> -places); // arithmetic right shift preserves sign
                }
                result = result & 0xFFFF;
                this.store(result);
            }
            break;

        case 0x04: // set_font
            {
                // Font 1 = normal, 3 = character graphics, 4 = fixed-pitch
                // Return previous font number, or 0 if requested font not available
                const font = values[0];
                // For now, accept font 1 (normal) and 4 (fixed)
                if (font === 1 || font === 4) {
                    this.store(1); // Pretend we were using font 1
                } else {
                    this.store(0); // Font not available
                }
            }
            break;

        case 0x05: // draw_picture (V6 graphics)
            {
                // draw_picture picture-number y x
                const picNum = values[0];
                const y = values.length > 1 ? values[1] : 1;
                const x = values.length > 2 ? values[2] : 1;

                if (this.graphicsCallback) {
                    this.graphicsCallback('draw', picNum, x, y);
                } else if (this.pictures[picNum]) {
                    // Basic browser support - create an img element
                    if (typeof document !== 'undefined') {
                        const pic = this.pictures[picNum];
                        const img = document.createElement('img');
                        img.src = 'data:image/' + pic.format + ';base64,' + pic.data;
                        img.style.position = 'absolute';
                        img.style.left = x + 'px';
                        img.style.top = y + 'px';
                        const container = document.getElementById('graphics-container');
                        if (container) container.appendChild(img);
                    }
                }
                if (this.debugMode) console.error(`[EXT] draw_picture: pic=${picNum} at (${x},${y})`);
            }
            break;

        case 0x06: // picture_data (V6 graphics)
            {
                // picture_data picture-number array -> (result)
                // If picture-number is 0, returns number of pictures
                // Otherwise stores width and height in array and branches if exists
                const picNum = values[0];
                const array = values.length > 1 ? values[1] : 0;

                if (picNum === 0) {
                    // Return total number of pictures
                    this.store(Object.keys(this.pictures).length);
                } else if (this.pictures[picNum]) {
                    const pic = this.pictures[picNum];
                    if (array) {
                        this.writeWord(array, pic.height || 0);
                        this.writeWord(array + 2, pic.width || 0);
                    }
                    this.branch(true);
                } else {
                    this.branch(false);
                }
            }
            break;

        case 0x07: // erase_picture (V6 graphics)
            {
                // erase_picture picture-number y x - erase area same size as picture
                const picNum = values[0];
                const y = values.length > 1 ? values[1] : 1;
                const x = values.length > 2 ? values[2] : 1;

                if (this.graphicsCallback) {
                    this.graphicsCallback('erase', picNum, x, y);
                }
                if (this.debugMode) console.error(`[EXT] erase_picture: pic=${picNum} at (${x},${y})`);
            }
            break;

        case 0x08: // set_margins (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] set_margins: not implemented');
            break;

        case 0x09: // save_undo
            {
                // Save undo state
                // Returns -1 if undo not available, 0 on failure, 1 on save, 2 on successful restore
                if (!this.undoStates) {
                    this.undoStates = [];
                }
                try {
                    const state = {
                        memory: this.memory.slice(0, STATIC_MEMORY),
                        stack: this.stack.slice(),
                        callStack: JSON.parse(JSON.stringify(this.callStack)),
                        pc: this.pc,
                        locals: this.locals.slice()
                    };
                    this.undoStates.push(state);
                    // Limit undo history
                    if (this.undoStates.length > 10) {
                        this.undoStates.shift();
                    }
                    this.store(1);
                } catch (e) {
                    this.store(0);
                }
            }
            break;

        case 0x0A: // restore_undo
            {
                if (!this.undoStates || this.undoStates.length === 0) {
                    this.store(0);
                } else {
                    const state = this.undoStates.pop();
                    // Restore dynamic memory
                    for (let i = 0; i < state.memory.length; i++) {
                        this.memory[i] = state.memory[i];
                    }
                    this.stack = state.stack.slice();
                    this.callStack = JSON.parse(JSON.stringify(state.callStack));
                    this.pc = state.pc;
                    this.locals = state.locals.slice();
                    this.store(2); // Successful restore
                }
            }
            break;

        case 0x0B: // print_unicode
            {
                const charCode = values[0];
                this.print(String.fromCharCode(charCode));
            }
            break;

        case 0x0C: // check_unicode
            {
                // Check if unicode character can be printed (bit 0) or read (bit 1)
                // For simplicity, assume all characters can be printed and read
                this.store(3); // Both bits set
            }
            break;

        case 0x0D: // set_true_colour (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] set_true_colour: not implemented');
            break;

        case 0x10: // move_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] move_window: not implemented');
            break;

        case 0x11: // window_size (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] window_size: not implemented');
            break;

        case 0x12: // window_style (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] window_style: not implemented');
            break;

        case 0x13: // get_wind_prop (V6)
            // Return 0 for all window properties
            this.store(0);
            break;

        case 0x14: // scroll_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] scroll_window: not implemented');
            break;

        case 0x15: // pop_stack (V6)
            {
                // Pop items from a stack
                const items = values[0];
                const stack = values.length > 1 ? values[1] : 0; // 0 = evaluation stack
                for (let i = 0; i < items; i++) {
                    this.pop();
                }
            }
            break;

        case 0x16: // read_mouse (V6)
            // Not implemented - just return zeros
            if (values[0]) {
                this.writeWord(values[0], 0);     // Y coordinate
                this.writeWord(values[0] + 2, 0); // X coordinate
                this.writeWord(values[0] + 4, 0); // Buttons
                this.writeWord(values[0] + 6, 0); // Menu selection
            }
            break;

        case 0x17: // mouse_window (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] mouse_window: not implemented');
            break;

        case 0x18: // push_stack (V6)
            {
                // Push value onto a user stack, branch on success
                // For simplicity, just push to evaluation stack
                this.push(values[0]);
                this.branch(true);
            }
            break;

        case 0x19: // put_wind_prop (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] put_wind_prop: not implemented');
            break;

        case 0x1A: // print_form (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] print_form: not implemented');
            break;

        case 0x1B: // make_menu (V6)
            // Not implemented - always fail
            this.branch(false);
            break;

        case 0x1C: // picture_table (V6)
            // Not implemented - no-op
            if (this.debugMode) console.error('[EXT] picture_table: not implemented');
            break;

        case 0x1D: // buffer_screen (V6)
            // Return 0 (buffer screen mode not supported)
            this.store(0);
            break;

        default:
            throw new Error(`Unimplemented extended opcode: 0x${extOpcode.toString(16)}`);
    }
};

// Helper functions
ZMachine.prototype.printLiteral = function() {
    const text = this.decodeZString(this.pc);
    this.print(text);
    // Skip past the Z-string (which uses 2-byte words)
    // The high bit of each word indicates if it's the last word
    let addr = this.pc;
    while (true) {
        const word = this.readWord(addr);
        addr += 2;
        if (word & 0x8000) {
            // This was the last word
            break;
        }
    }
    this.pc = addr;
};

ZMachine.prototype.branch = function(condition) {
    // Save the address of the branch data for offset calculation
    const branchDataAddr = this.pc;
    const branchByte = this.readByte(this.pc);
    this.pc++;

    const branchOnTrue = !!(branchByte & 0x80);
    let offset;
    let offsetSize;

    if (branchByte & 0x40) {
        // Short form (6-bit offset)
        offset = branchByte & 0x3F;
        offsetSize = 1;  // 1 byte total
    } else {
        // Long form (14-bit signed offset)
        const secondByte = this.readByte(this.pc);
        offset = ((branchByte & 0x3F) << 8) | secondByte;
        this.pc++;
        offsetSize = 2;  // 2 bytes total

        if (offset & 0x2000) {
            offset |= 0xC000; // Sign extend
        }
        // Convert to signed
        if (offset > 32767) offset -= 65536;
    }

    if (condition === branchOnTrue) {
        if (offset === 0) {
            this.returnFromRoutine(0);
        } else if (offset === 1) {
            this.returnFromRoutine(1);
        } else {
            // Offset is relative to the address AFTER the branch data
            // The offset of 2 means "branch to the instruction immediately after this one"
            // So we calculate: (address of branch data) + (size of branch data) + (offset) - 2
            const newPC = branchDataAddr + offsetSize + offset - 2;

            // Safety check: don't branch to header area (first 64 bytes)
            if (newPC < 0x40) {
                if (this.debugMode) {
                    console.error(`[BRANCH] WARNING: Attempted to branch to 0x${newPC.toString(16)} which is in the header`);
                    console.error(`[BRANCH] This usually indicates a bug in parsing or variable handling`);
                    console.error(`[BRANCH] Branch from 0x${branchDataAddr.toString(16)} with offset ${offset}`);
                    console.error(`[BRANCH] This is likely a parse error - returning 0 to indicate failure`);
                }
                // Treat this as a catastrophic error and return false from the routine
                this.returnFromRoutine(0);
            } else {
                this.pc = newPC;
            }
        }
    }
};

ZMachine.prototype.store = function(value) {
    const varNum = this.readByte(this.pc);
    this.pc++;
    this.setVariable(varNum, value);
};

ZMachine.prototype.returnFromRoutine = function(value) {
    if (this.callStack.length === 0) {
        this.quit();
        return;
    }

    const frame = this.callStack.pop();

    this.pc = frame.returnPC;
    this.locals = frame.locals;

    if (frame.storeVar !== null) {
        this.setVariable(frame.storeVar, value);
    }
};

ZMachine.prototype.getObjectName = function(objNum) {
    const obj = this.getObject(objNum);
    if (!obj) return "";

    let propAddr = obj.properties;
    const textLength = this.readByte(propAddr);
    propAddr++;

    if (textLength === 0) return "";

    return this.decodeZString(propAddr);
};

// Routine call handling
ZMachine.prototype.callRoutine = function(packedAddr, args, storeVar) {
    if (packedAddr === 0) {
        if (storeVar !== null) {
            this.setVariable(storeVar, 0);
        }
        return;
    }

    const addr = this.unpackAddress(packedAddr);

    // Sanity check - routine address should be at least in static memory region
    if (addr < STATIC_MEMORY) {
        console.warn(`Warning: Attempted to call routine at invalid address 0x${addr.toString(16)} (packed: 0x${packedAddr.toString(16)})`);
        if (storeVar !== null) {
            this.setVariable(storeVar, 0);
        }
        return;
    }

    // Read routine header
    const numLocals = this.readByte(addr);

    if (this.debugMode && this.instructionCount < 20) {
        console.error(`  -> Unpacked to addr 0x${addr.toString(16)}, numLocals=${numLocals}`);
    }

    // Sanity check - Z-Machine routines can have at most 15 locals
    if (numLocals > 15) {
        console.error(`[CALL ERROR] Invalid routine - dumping call stack:`);
        for (let i = this.callStack.length - 1; i >= 0; i--) {
            const frame = this.callStack[i];
            console.error(`  Frame ${i}: returnPC=0x${frame.returnPC.toString(16)}, storeVar=${frame.storeVar}`);
        }
        console.error(`[CALL ERROR] Current locals: ${this.locals.slice(0, 16).map((v, i) => `L${i+1}=0x${(v||0).toString(16)}`).join(', ')}`);
        console.error(`[CALL ERROR] Stack top 10: [${this.stack.slice(-10).map(v => '0x' + v.toString(16)).join(', ')}]`);
        throw new Error(`Invalid routine at 0x${addr.toString(16)} (packed: 0x${packedAddr.toString(16)}): numLocals=${numLocals} exceeds maximum of 15`);
    }

    // Save current state (make a copy of locals array!)

    this.callStack.push({
        returnPC: this.pc,
        locals: this.locals.slice(),
        numLocals: numLocals,
        storeVar: storeVar
    });

    // Initialize new locals
    this.locals = new Array(16);

    // Set up locals
    if (VERSION <= 4) {
        // Read default local values
        for (let i = 0; i < numLocals; i++) {
            this.locals[i] = this.readWord(addr + 1 + i * 2);
        }
        this.pc = addr + 1 + numLocals * 2;
    } else {
        // V5+ - locals start at 0
        for (let i = 0; i < numLocals; i++) {
            this.locals[i] = 0;
        }
        this.pc = addr + 1;
    }

    // Copy arguments to locals
    if (this.debugMode) {
        console.error(`[CALL ${this.instructionCount}] To addr 0x${addr.toString(16)}: numLocals=${numLocals}, args=[${args.map(a => '0x'+a.toString(16)).join(', ')}]`);
        console.error(`[CALL ${this.instructionCount}] Defaults: ${this.locals.slice(0, numLocals).map((v,i) => `L${i+1}=0x${v.toString(16)}`).join(' ')}`);
    }
    for (let i = 0; i < args.length && i < numLocals; i++) {
        this.locals[i] = args[i];
    }
    if (this.debugMode) {
        console.error(`[CALL ${this.instructionCount}] Final:    ${this.locals.slice(0, numLocals).map((v,i) => `L${i+1}=0x${v.toString(16)}`).join(' ')}`);
    }
};

// Crash dump generation
ZMachine.prototype.generateCrashDump = function(error) {
    const dump = {
        timestamp: new Date().toISOString(),
        error: {
            message: error.message,
            stack: error.stack,
            name: error.name
        },
        machine: {
            version: VERSION,
            pc: `0x${this.pc.toString(16)}`,
            instructionCount: this.instructionCount,
            running: this.running,
            finished: this.finished
        },
        memory: {
            staticMemoryStart: `0x${STATIC_MEMORY.toString(16)}`,
            highMemoryStart: `0x${HIGH_MEMORY.toString(16)}`,
            pcBytes: Array.from(this.memory.slice(Math.max(0, this.pc - 10), this.pc + 20)).map(b => `0x${b.toString(16).padStart(2, '0')}`)
        },
        stack: {
            evaluationStack: this.stack.slice(-20).map(v => `0x${v.toString(16)}`),
            stackDepth: this.stack.length,
            callStack: this.callStack.map((frame, i) => ({
                frameNumber: i,
                returnPC: `0x${frame.returnPC.toString(16)}`,
                numLocals: frame.numLocals,
                storeVar: frame.storeVar,
                locals: frame.locals.slice(0, frame.numLocals).map(v => v === undefined ? 'undefined' : `0x${v.toString(16)}`)
            })),
            callDepth: this.callStack.length
        },
        locals: this.locals.map((v, i) => v === undefined ? undefined : `0x${v.toString(16)}`),
        globals: {
            sample: Array.from({length: 10}, (_, i) => {
                const addr = GLOBALS_ADDR + i * 2;
                return `g${i.toString().padStart(3, '0')}: 0x${this.readWord(addr).toString(16).padStart(4, '0')}`;
            })
        },
        instructionHistory: this.instructionHistory,
        output: {
            buffer: this.outputBuffer.substring(Math.max(0, this.outputBuffer.length - 500)),
            totalLength: this.outputBuffer.length
        }
    };

    return dump;
};

ZMachine.prototype.saveCrashDump = function(dump) {
    const json = JSON.stringify(dump, null, 2);

    if (typeof window !== "undefined" && typeof document !== "undefined") {
        // Browser environment - offer download
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `zmachine-crash-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.error('Crash dump saved to downloads');
    } else if (typeof require !== "undefined") {
        // Node.js environment
        try {
            const fs = require('fs');
            const filename = `zmachine-crash-${Date.now()}.json`;
            fs.writeFileSync(filename, json);
            console.error(`Crash dump saved to ${filename}`);
        } catch (e) {
            console.error('Failed to save crash dump:', e.message);
            console.error('Crash dump:', json);
        }
    } else {
        console.error('Crash dump:', json);
    }
};

ZMachine.prototype.recordInstruction = function(pc, opcode) {
    if (!this.debugMode) return;

    const record = {
        count: this.instructionCount,
        pc: `0x${pc.toString(16)}`,
        opcode: `0x${opcode.toString(16)}`,
        stackDepth: this.stack.length,
        callDepth: this.callStack.length
    };

    this.instructionHistory.push(record);
    if (this.instructionHistory.length > this.maxHistorySize) {
        this.instructionHistory.shift();
    }
};

// Main execution loop
ZMachine.prototype.run = function() {
    const entryPC = this.pc;
    const entryStack = this.stack.length;
    const entryInst = this.instructionCount;
    this.running = true;
    if (this.debugMode) {
        console.error(`[RUN] Entry: PC=0x${entryPC.toString(16)} stack=${entryStack} inst=${entryInst}`);
    }

    // Always increment instruction count (used for yielding in browser)
    let localInstructionCount = 0;

    while (this.running && !this.finished) {
        try {
            const currentPC = this.pc;
            const opcode = this.readByte(this.pc);

            if (this.debugMode) {
                this.recordInstruction(currentPC, opcode);
                this.instructionCount++;
            }
            localInstructionCount++;

            this.executeInstruction();

            // Safety check - detect infinite loops
            if (this.debugMode && this.instructionCount > 100000) {
                throw new Error(`Instruction count exceeded 100000 - possible infinite loop`);
            }

        } catch (e) {
            console.error(`\n========== Z-MACHINE CRASH ==========`);
            console.error(`Error at PC 0x${this.pc.toString(16)}: ${e.message}`);
            console.error(`Instruction count: ${this.instructionCount}`);
            console.error(`Call depth: ${this.callStack.length}`);
            console.error(`Stack depth: ${this.stack.length}`);
            console.error(`=====================================\n`);

            if (this.debugMode) {
                const dump = this.generateCrashDump(e);
                this.saveCrashDump(dump);
                console.error('Full crash dump has been saved');
            }

            console.error('\nStack trace:', e.stack);
            this.running = false;
            break;
        }

        // Yield periodically for UI updates (every 1000 instructions)
        if (localInstructionCount % 1000 === 0 && typeof window !== "undefined") {
            setTimeout(() => this.run(), 0);
            return;
        }
    }

    if (this.finished) {
        console.error('\n[Z-Machine execution completed]');
    } else if (!this.running) {
        console.error('\n[Z-Machine execution stopped]');
    }
};

// Initialize and start the Z-Machine
function createZMachine() {
    const storyData = decodeStoryData();
    return new ZMachine(storyData);
}

// Module exports
if (typeof module !== "undefined" && module.exports) {
    // Node.js
    module.exports = {
        ZMachine,
        createZMachine,
        VERSION,
        decodeStoryData
    };

    // Auto-run if executed directly (not required as a module)
    if (require.main === module) {
        console.error('Starting Z-Machine game...\n');
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        const m = createZMachine();

        // Check for --debug flag
        if (process.argv.includes('--debug')) {
            m.debugMode = true;
            console.error('[DEBUG MODE ENABLED]\n');
        }

        // Output handler
        m.outputCallback = (text) => {
            process.stdout.write(text);
        };

        // Input handler will be set by read() opcode when needed
        m.inputCallback = null;

        // Input polling function
        function checkForInput() {
            if (m.inputCallback && !m.running) {
                // Game is waiting for input
                rl.question('\n> ', (answer) => {
                    if (m.inputCallback) {
                        m.inputCallback(answer);
                        // Check again after execution
                        setTimeout(checkForInput, 10);
                    }
                });
            } else if (m.finished) {
                // Game is done
                rl.close();
            } else if (!m.running) {
                // Check again soon
                setTimeout(checkForInput, 10);
            } else {
                // Still running, check again
                setTimeout(checkForInput, 10);
            }
        }

        // Start the game
        try {
            m.run();
            // Start polling for input
            setTimeout(checkForInput, 10);
        } catch (e) {
            console.error('Fatal error:', e.message);
            console.error(e.stack);
            rl.close();
            process.exit(1);
        }
    }
} else if (typeof define === "function" && define.amd) {
    // AMD
    define([], function() {
        return {
            ZMachine,
            createZMachine,
            VERSION,
            decodeStoryData
        };
    });
} else {
    // Browser global
    window.ZMachine = ZMachine;
    window.createZMachine = createZMachine;
}